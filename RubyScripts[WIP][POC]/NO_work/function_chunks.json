[
  {
    "name": "init()",
    "kind": "Instance Method",
    "offset": 363,
    "length": 9,
    "sourcetext": " init() {"
  },
  {
    "name": "getNavigationFrom(deeplinkString:)",
    "kind": "Static Method",
    "offset": 874,
    "length": 538,
    "sourcetext": " static func getNavigationFrom(deeplinkString: String) -> DismissCardType? {\n            if deeplinkString.isEqual(\"snbdvneo://loyalty/dashboard\") {\n                return DismissCardType.goToLoyaltyDashboard\n            } else if deeplinkString.isEqual(\"snbdvneo://transfers/hub\") {\n                return DismissCardType.goToTransferMenu\n            } else if deeplinkString.isEqual(\"snbdvneo://pfm/dashboard\") {\n                return DismissCardType.goToPersonalFinanceManagementDashboard\n            }\n            return nil\n        "
  },
  {
    "name": "init(navigationController:closeAction:)",
    "kind": "Instance Method",
    "offset": 2110,
    "length": 266,
    "sourcetext": " init(navigationController: UINavigationController,\n             closeAction: ((DiscoverCardsJourney.Configuration.DismissCardType) -> Void)?\n        ) {\n            self.navigationController = navigationController\n            self.closeAction = closeAction\n        "
  },
  {
    "name": "dismiss()",
    "kind": "Instance Method",
    "offset": 2386,
    "length": 84,
    "sourcetext": " func dismiss() {\n            navigationController?.dismiss(animated: true)\n        "
  },
  {
    "name": "didTapOnButton(redirectionType:)",
    "kind": "Instance Method",
    "offset": 2480,
    "length": 202,
    "sourcetext": " func didTapOnButton(redirectionType: DiscoverCardsJourney.Configuration.DismissCardType?) {\n            if let thisType = redirectionType {\n                closeAction?(thisType)\n            }\n        "
  },
  {
    "name": "showGenericError(from:for:)",
    "kind": "Instance Method",
    "offset": 2692,
    "length": 341,
    "sourcetext": " func showGenericError(from viewController: UIViewController,\n                              for option: GenericErrorScreen.Configuration.Option) {\n            let errorScreen = GenericErrorScreen.build(configuration: GenericErrorScreen.Configuration.make(for: option))\n            viewController.present(errorScreen, animated: true)\n        "
  },
  {
    "name": "build(navigationController:configuration:closeAction:)",
    "kind": "Static Method",
    "offset": 7728,
    "length": 707,
    "sourcetext": " static func build(\n        navigationController: UINavigationController,\n        configuration: Self.Configuration = Resolver.resolve(),\n        closeAction: ((Self.Configuration.DismissCardType) -> Void)?\n    ) -> UIViewController {\n\n        let router = DiscoverCardsJourney.Router(\n            navigationController: navigationController,\n            closeAction: closeAction\n        )\n\n        let viewModel = DiscoverCardsViewModel.init(\n            configuration: DiscoverCardsJourney.Configuration(),\n            router: router\n        )\n\n        let discoverVC = DiscoverCardsViewController(viewModel: viewModel)\n        discoverVC.modalPresentationStyle = .fullScreen\n        return discoverVC\n    "
  },
  {
    "name": "pauseProgressBarAnimation()",
    "kind": "Instance Method",
    "offset": 9014,
    "length": 32,
    "sourcetext": " func pauseProgressBarAnimation("
  },
  {
    "name": "resumeProgressBarAnimation()",
    "kind": "Instance Method",
    "offset": 9051,
    "length": 33,
    "sourcetext": " func resumeProgressBarAnimation("
  },
  {
    "name": "init(viewModel:)",
    "kind": "Instance Method",
    "offset": 11506,
    "length": 128,
    "sourcetext": " init(viewModel: DiscoverCardsViewModel) {\n        self.viewModel = viewModel\n        super.init(nibName: nil, bundle: nil)\n    "
  },
  {
    "name": "init(coder:)",
    "kind": "Instance Method",
    "offset": 11649,
    "length": 89,
    "sourcetext": " init?(coder: NSCoder) {\n        fatalError(\"init(coder:) has not been implemented\")\n    "
  },
  {
    "name": "loadView()",
    "kind": "Instance Method",
    "offset": 11753,
    "length": 99,
    "sourcetext": " func loadView() {\n        super.loadView()\n        view.configureBackgroundView(type: .plain)\n    "
  },
  {
    "name": "viewDidLoad()",
    "kind": "Instance Method",
    "offset": 11867,
    "length": 130,
    "sourcetext": " func viewDidLoad() {\n        super.viewDidLoad()\n        bind()\n        addConstraints()\n        viewDidLoadPublisher.send()\n    "
  },
  {
    "name": "bind()",
    "kind": "Instance Method",
    "offset": 12042,
    "length": 1998,
    "sourcetext": " func bind() {\n        closeButton.publisher(for: .touchUpInside)\n            .sink { [weak self] _ in self?.viewModel.didTapCloseButton() }\n            .store(in: &cancellables)\n        StoryProgressBar.changeSegmentPublisher.sink { [weak self] index in\n            guard index >= 0 && index < self?.cards.count ?? 0 else { return }\n            let indexPath = IndexPath(row: index, section: 0)\n            self?.collectionView.scrollToItem(at: indexPath, at: .centeredHorizontally, animated: true)\n        }.store(in: &cancellables)\n        let input = DiscoverCardsViewModelInput(\n            viewDidLoad: viewDidLoadPublisher.eraseToAnyPublisher(),\n            tryAgain: tryAgain.eraseToAnyPublisher(),\n            didScroll: didScroll.eraseToAnyPublisher(),\n            didTap: didTap.eraseToAnyPublisher(),\n            didTapRegion: didTapRegion.eraseToAnyPublisher()\n        )\n        let output = viewModel.bind(input: input)\n        output.state.sink { [weak self] in\n            switch $0 {\n            case .error:\n                self?.activityView.deactivate()\n                self?.showGenericError()\n            case .loading:\n                self?.activityView.activate()\n            case .success:\n                self?.activityView.deactivate()\n            }\n        }.store(in: &cancellables)\n        output.cards.sink { [weak self] in\n            self?.cards = $0\n            self?.collectionView.reloadData()\n            self?.setupProgressbar(segmentCount: $0.count)\n        }.store(in: &cancellables)\n        output.scroll.sink { [weak self] in\n            let indexPath = IndexPath(row: $0.scrollIndex, section: 0)\n            if $0.scrollDirection == .previous {\n                self?.progressBarManager.animateToPreviousSegment()\n            } else {\n                self?.progressBarManager.animateToNextSegment()\n            }\n            self?.collectionView.scrollToItem(at: indexPath, at: .centeredHorizontally, animated: true)\n        }.store(in: &cancellables)\n    "
  },
  {
    "name": "setupProgressbar(segmentCount:)",
    "kind": "Instance Method",
    "offset": 14054,
    "length": 281,
    "sourcetext": " func setupProgressbar(segmentCount: Int) {\n        progressBarManager = StoryProgressBarManager(parentView: view,\n                                                     segmentCount: segmentCount,\n                                                     parentViewController: self)\n    "
  },
  {
    "name": "addConstraints()",
    "kind": "Instance Method",
    "offset": 14349,
    "length": 827,
    "sourcetext": " func addConstraints() {\n        view.addSubview(collectionView)\n        view.addSubview(closeButton)\n        view.addSubview(activityView)\n\n        closeButton.snp.makeConstraints { make in\n            make.height.width.equalTo(24.0)\n            make.trailing.equalToSuperview().inset(DesignSystem.shared.spacer.md)\n            make.top.equalTo(view.safeAreaLayoutGuide).offset(28.0)\n        }\n        collectionView.snp.makeConstraints { make in\n            make.leading.trailing.equalToSuperview().inset(DesignSystem.shared.spacer.md)\n            make.bottom.equalTo(view.safeAreaLayoutGuide)\n            make.top.equalTo(closeButton.snp.bottom).offset(DesignSystem.shared.spacer.md)\n        }\n\n        activityView.snp.makeConstraints { make in\n            make.leading.top.trailing.bottom.equalToSuperview()\n        }\n    "
  },
  {
    "name": "showGenericError()",
    "kind": "Instance Method",
    "offset": 15182,
    "length": 260,
    "sourcetext": " func showGenericError() {\n        if viewModel.isInternetConnected {\n            self.viewModel.showErrorWithRetry(viewController: self)\n        } else {\n            self.viewModel.router.showGenericError(from: self, for: .noInternetConnection)\n        }\n    "
  },
  {
    "name": "collectionView(_:numberOfItemsInSection:)",
    "kind": "Instance Method",
    "offset": 15518,
    "length": 127,
    "sourcetext": " func collectionView(_ collectionView: UICollectionView, numberOfItemsInSection section: Int) -> Int {\n        cards.count\n    "
  },
  {
    "name": "collectionView(_:cellForItemAt:)",
    "kind": "Instance Method",
    "offset": 15651,
    "length": 1032,
    "sourcetext": " func collectionView(_ collectionView: UICollectionView, cellForItemAt indexPath: IndexPath) -> UICollectionViewCell {\n        guard let cell = collectionView.dequeueReusableCell(\n            withReuseIdentifier: DiscoverCardCollectionViewCell.reuseID,\n            for: indexPath\n        ) as? DiscoverCardCollectionViewCell else { return UICollectionViewCell() }\n        let card = cards[indexPath.row]\n        cell.indexPath = indexPath\n        cell.configure(card: card)\n        cell.buttonTapped = { [weak self] in\n            guard let indexPath = $0 else { return }\n            self?.didTap.send(indexPath.row)\n        }\n        cell.previousCardTapped = { [weak self] in\n            guard let index = $0?.row else { return }\n            self?.didTapRegion.send(.previousCard(index: index))\n        }\n        cell.nextCardTapped = { [weak self] in\n            guard let index = $0?.row else { return }\n            self?.didTapRegion.send(.nextCard(index: index))\n        }\n        cell.delegate = self\n        return cell\n    "
  },
  {
    "name": "scrollViewDidEndDecelerating(_:)",
    "kind": "Instance Method",
    "offset": 16757,
    "length": 317,
    "sourcetext": " func scrollViewDidEndDecelerating(_ scrollView: UIScrollView) {\n        if let collectionView = scrollView as? UICollectionView {\n            let currentIndex = Int(collectionView.contentOffset.x / collectionView.bounds.width)\n            progressBarManager.progressBar?.animateToSegment(currentIndex)\n        }\n    "
  },
  {
    "name": "collectionView(_:layout:sizeForItemAt:)",
    "kind": "Instance Method",
    "offset": 17158,
    "length": 226,
    "sourcetext": " func collectionView(\n        _ collectionView: UICollectionView,\n        layout collectionViewLayout: UICollectionViewLayout,\n        sizeForItemAt indexPath: IndexPath\n    ) -> CGSize {\n        collectionView.frame.size\n    "
  },
  {
    "name": "viewWillAppear(_:)",
    "kind": "Instance Method",
    "offset": 17441,
    "length": 171,
    "sourcetext": " func viewWillAppear(_ animated: Bool) {\n        super.viewWillAppear(animated)\n        progressBarManager?.startStoryAnimations()\n        collectionView.reloadData()\n    "
  },
  {
    "name": "viewWillDisappear(_:)",
    "kind": "Instance Method",
    "offset": 17627,
    "length": 136,
    "sourcetext": " func viewWillDisappear(_ animated: Bool) {\n        super.viewWillDisappear(animated)\n        progressBarManager?.resetAnimations()\n    "
  },
  {
    "name": "pauseProgressBarAnimation()",
    "kind": "Instance Method",
    "offset": 17851,
    "length": 96,
    "sourcetext": " func pauseProgressBarAnimation() {\n        progressBarManager?.pauseProgressBarAnimation()\n    "
  },
  {
    "name": "resumeProgressBarAnimation()",
    "kind": "Instance Method",
    "offset": 17953,
    "length": 98,
    "sourcetext": " func resumeProgressBarAnimation() {\n        progressBarManager?.resumeProgressBarAnimation()\n    "
  },
  {
    "name": "init(parentView:segmentCount:parentViewController:)",
    "kind": "Instance Method",
    "offset": 18597,
    "length": 523,
    "sourcetext": " init(parentView: UIView, segmentCount: Int, parentViewController: UIViewController) {\n        self.parentViewController = parentViewController\n        progressBar = StoryProgressBar(segmentCount: segmentCount)\n        progressBar?.translatesAutoresizingMaskIntoConstraints = false\n        progressBar?.allSegmentAnimationsFinishedCompletion = { [weak self] in\n            self?.handleAllSegmentAnimationsFinished()\n        }\n        parentView.addSubview(progressBar!)\n        setupConstraints(parentView: parentView)\n    "
  },
  {
    "name": "setupConstraints(parentView:)",
    "kind": "Instance Method",
    "offset": 19134,
    "length": 504,
    "sourcetext": " func setupConstraints(parentView: UIView) {\n        NSLayoutConstraint.activate([\n            progressBar!.heightAnchor.constraint(equalToConstant: 3), // Adjust segment height\n            progressBar!.leadingAnchor.constraint(equalTo: parentView.leadingAnchor, constant: 8),\n            progressBar!.trailingAnchor.constraint(equalTo: parentView.trailingAnchor, constant: -8),\n            progressBar!.topAnchor.constraint(equalTo: parentView.safeAreaLayoutGuide.topAnchor, constant: 8)\n        ])\n    "
  },
  {
    "name": "startStoryAnimations()",
    "kind": "Instance Method",
    "offset": 19644,
    "length": 72,
    "sourcetext": " func startStoryAnimations() {\n        progressBar?.startProgress()\n    "
  },
  {
    "name": "resetAnimations()",
    "kind": "Instance Method",
    "offset": 19722,
    "length": 69,
    "sourcetext": " func resetAnimations() {\n        progressBar?.resetAnimations()\n    "
  },
  {
    "name": "animateToNextSegment()",
    "kind": "Instance Method",
    "offset": 19797,
    "length": 79,
    "sourcetext": " func animateToNextSegment() {\n        progressBar?.animateToNextSegment()\n    "
  },
  {
    "name": "animateToPreviousSegment()",
    "kind": "Instance Method",
    "offset": 19882,
    "length": 87,
    "sourcetext": " func animateToPreviousSegment() {\n        progressBar?.animateToPreviousSegment()\n    "
  },
  {
    "name": "animateToSegment(_:)",
    "kind": "Instance Method",
    "offset": 19975,
    "length": 102,
    "sourcetext": " func animateToSegment(_ segmentIndex: Int) {\n        progressBar?.animateToSegment(segmentIndex)\n    "
  },
  {
    "name": "pauseProgressBarAnimation()",
    "kind": "Instance Method",
    "offset": 20083,
    "length": 78,
    "sourcetext": " func pauseProgressBarAnimation() {\n        progressBar?.pauseAnimation()\n    "
  },
  {
    "name": "resumeProgressBarAnimation()",
    "kind": "Instance Method",
    "offset": 20167,
    "length": 80,
    "sourcetext": " func resumeProgressBarAnimation() {\n        progressBar?.resumeAnimation()\n    "
  },
  {
    "name": "handleAllSegmentAnimationsFinished()",
    "kind": "Instance Method",
    "offset": 20253,
    "length": 482,
    "sourcetext": " func handleAllSegmentAnimationsFinished() {\n        DispatchQueue.main.async { [weak self] in\n            if let presentedViewController = self?.parentViewController?.presentedViewController {\n                presentedViewController.dismiss(animated: true) { [weak self] in\n                    self?.parentViewController?.dismiss(animated: true)\n                }\n            } else {\n                self?.parentViewController?.dismiss(animated: true)\n            }\n        }\n    "
  },
  {
    "name": "init(frame:)",
    "kind": "Instance Method",
    "offset": 21698,
    "length": 76,
    "sourcetext": " init(frame: CGRect) {\n        super.init(frame: frame)\n        setUp()\n    "
  },
  {
    "name": "init(coder:)",
    "kind": "Instance Method",
    "offset": 21789,
    "length": 89,
    "sourcetext": " init?(coder: NSCoder) {\n        fatalError(\"init(coder:) has not been implemented\")\n    "
  },
  {
    "name": "setUp()",
    "kind": "Instance Method",
    "offset": 21892,
    "length": 168,
    "sourcetext": " func setUp() {\n        addSubview(loadingImage)\n        loadingImage.snp.makeConstraints {\n            $0.leading.trailing.top.bottom.equalToSuperview()\n        }\n    "
  },
  {
    "name": "loadImage()",
    "kind": "Instance Method",
    "offset": 22074,
    "length": 943,
    "sourcetext": " func loadImage() {\n        task?.cancel()\n        guard let urlStr = urlString, let url = URL(string: urlStr) else {\n            loadingImage.stopAnimating()\n            image = defaultImage\n            return\n        }\n        loadingImage.isHidden = false\n        loadingImage.startAnimating()\n        let nextTask = Task {\n            do {\n                let imageDownloaded = try await imageLoader.loadImage(withURL: url)\n                if !Task.isCancelled {\n                    await MainActor.run {\n                        loadingImage.stopAnimating()\n                        image = imageDownloaded\n                    }\n                }\n            } catch {\n                if !Task.isCancelled {\n                    await MainActor.run {\n                        loadingImage.stopAnimating()\n                        image = defaultImage\n                    }\n                }\n            }\n        }\n        task = nextTask\n    "
  },
  {
    "name": "init(configuration:router:)",
    "kind": "Instance Method",
    "offset": 24159,
    "length": 194,
    "sourcetext": " init(\n        configuration: DiscoverCardsJourney.Configuration,\n        router: DiscoverCardsJourney.Router\n    ) {\n        self.configuration = configuration\n        self.router = router\n    "
  },
  {
    "name": "getCards()",
    "kind": "Instance Method",
    "offset": 24367,
    "length": 523,
    "sourcetext": " func getCards() {\n        self.state.send(.loading)\n        Task { [weak self] in\n            do {\n                guard let cards = try await self?.useCase.getCards() else { return }\n                await MainActor.run { [weak self] in\n                    self?.state.send(.success)\n                    self?.cardsResponse.send(cards)\n                }\n            } catch _ {\n                await MainActor.run { [weak self] in\n                    self?.state.send(.error)\n                }\n            }\n        }\n    "
  },
  {
    "name": "didTapCloseButton()",
    "kind": "Instance Method",
    "offset": 24958,
    "length": 57,
    "sourcetext": " func didTapCloseButton() {\n        router.dismiss()\n    "
  },
  {
    "name": "showErrorWithRetry(viewController:)",
    "kind": "Instance Method",
    "offset": 25021,
    "length": 822,
    "sourcetext": " func showErrorWithRetry(viewController: UIViewController) {\n        var config = GenericErrorScreen.Configuration()\n        config.designs.icon = configuration.images.genericErrorIcon\n        config.strings.title = configuration.strings.error.title\n        config.strings.body = configuration.strings.error.message\n        config.strings.primaryActionButtonTitle = configuration.strings.error.tryAgainButtonTitle\n        config.actionButtonDisplayMode = .primaryOnly\n        config.router.didSelectPrimaryActionButton = { [weak self] alertVC in\n            return { _ in\n                self?.getCards()\n                viewController.dismiss(animated: true)\n            }\n        }\n        let bottomSheet = GenericErrorScreen.build(configuration: config)\n        viewController.present(bottomSheet, animated: true)\n    "
  },
  {
    "name": "bind(input:)",
    "kind": "Instance Method",
    "offset": 25905,
    "length": 1517,
    "sourcetext": " func bind(input: DiscoverCardsViewModelInput) -> DiscoverCardsViewModelOutput {\n        input.viewDidLoad.sink { [weak self] in\n            self?.getCards()\n        }.store(in: &cancellables)\n        input.tryAgain.sink { [weak self] in\n            self?.getCards()\n        }.store(in: &cancellables)\n        input.didTap.sink { [weak self] in\n            guard let card = self?.cardsResponse.value?.stories[safe: $0] else { return }\n            self?.router.didTapOnButton(redirectionType: DiscoverCardsJourney.Configuration.getNavigationFrom(\n                deeplinkString: card.deepLink\n            ))\n        }.store(in: &cancellables)\n        input.didTapRegion.sink { [weak self] in\n            switch $0 {\n            case .previousCard(let index):\n                if index > 0 {\n                    self?.scroll.send(DiscoverCardsParameters(scrollIndex: index - 1, scrollDirection: .previous))\n                }\n            case .nextCard(let index):\n                guard let cardsCount = self?.cardsResponse.value?.stories.count else { return }\n                if index < cardsCount - 1 {\n                    self?.scroll.send(DiscoverCardsParameters(scrollIndex: index + 1, scrollDirection: .next))\n                }\n            }\n        }.store(in: &cancellables)\n        return DiscoverCardsViewModelOutput(\n            cards: cardsResponse.compactMap({$0?.toCards}).eraseToAnyPublisher(),\n            scroll: scroll.eraseToAnyPublisher(),\n            state: state.eraseToAnyPublisher()\n        )\n    "
  },
  {
    "name": "init(segmentCount:)",
    "kind": "Instance Method",
    "offset": 29903,
    "length": 131,
    "sourcetext": " init(segmentCount: Int) {\n        self.segmentCount = max(1, segmentCount)\n        super.init(frame: .zero)\n        setupUI()\n    "
  },
  {
    "name": "didMoveToSuperview()",
    "kind": "Instance Method",
    "offset": 30049,
    "length": 208,
    "sourcetext": " func didMoveToSuperview() {\n        super.didMoveToSuperview()\n\n        // Call startProgress when the view is added to its superview (e.g., when the ViewController is presented)\n        startProgress()\n    "
  },
  {
    "name": "init(coder:)",
    "kind": "Instance Method",
    "offset": 30272,
    "length": 89,
    "sourcetext": " init?(coder: NSCoder) {\n        fatalError(\"init(coder:) has not been implemented\")\n    "
  },
  {
    "name": "setupUI()",
    "kind": "Instance Method",
    "offset": 30375,
    "length": 136,
    "sourcetext": " func setupUI() {\n        backgroundColor = .clear\n        clipsToBounds = true\n        layer.cornerRadius = self.segmentHeight / 2\n    "
  },
  {
    "name": "startProgress()",
    "kind": "Instance Method",
    "offset": 30517,
    "length": 278,
    "sourcetext": " func startProgress() {\n        // Check if animation is already in progress\n        guard !isAnimating else { return }\n        // Reset the current segment and progress\n        currentSegment = 0\n        progress = 0\n        isAnimating = true\n        animateNextSegment()\n    "
  },
  {
    "name": "animateNextSegmentWithRemainingTime(_:)",
    "kind": "Instance Method",
    "offset": 30809,
    "length": 2822,
    "sourcetext": " func animateNextSegmentWithRemainingTime(_ remainingTime: TimeInterval = 7.0) {\n        animationCancellable?.cancel()\n        progress = pausedProgress\n        setNeedsDisplay()\n        isAnimating = true // Set animation state\n        let animationSteps = Int(remainingTime * 60) // 60 frames per second for smooth animation\n        let stepIncrement = 1.0 / CGFloat(animationSteps)\n        var currentStep = Int(progress * CGFloat(animationSteps))\n        let animationCompletionPublisher = PassthroughSubject<Void, Never>()\n        animationCancellable = Timer.publish(every: animationDuration / Double(animationSteps), on: .main, in: .default)\n            .autoconnect()\n            .receive(on: DispatchQueue.main)\n            .sink { _ in\n                guard !self.isPaused else { return }\n                currentStep += 1\n                self.progress = CGFloat(currentStep) * stepIncrement\n                self.setNeedsDisplay()\n\n                if currentStep >= animationSteps {\n                    self.animationCancellable?.cancel()\n\n                    self.currentSegment += 1\n                    self.progress = 0\n                    self.pausedProgress = 0 // Reset paused progress\n                    self.setNeedsDisplay()\n                    self.isAnimating = false // Reset animation state\n\n                    if self.currentSegment < self.segmentCount {\n                        DispatchQueue.main.async {\n                            animationCompletionPublisher.send()\n                        }\n                    } else {\n                        if self.currentSegment >= self.segmentCount {\n                            self.allSegmentAnimationsFinishedCompletion?()\n                        }\n                    }\n                }\n                animationCompletionPublisher\n                    .sink { [weak self] in\n                        Self.changeSegmentPublisher\n                            .send(self?.currentSegment ?? 0) // Call the publisher for each segment animation completion\n                        self?.animateNextSegment() // Start animating the next segment\n                    }\n                    .store(in: &self.cancellables)\n            }\n\n        // Resume from the stored progress state if the animation was paused\n        if isPaused {\n            progress = pausedProgress\n            // Adjust the remaining time for subsequent segments\n            let remainingTimeForSubsequentSegments = animationDuration - remainingTime\n            // Resume the animation from the adjusted remaining time (using default of 7 seconds if remainingTimeForSubsequentSegments is 0)\n            self.animateNextSegmentWithRemainingTime(\n                remainingTimeForSubsequentSegments > 0 ? remainingTimeForSubsequentSegments : animationDuration\n            )\n        }\n    "
  },
  {
    "name": "animateNextSegment()",
    "kind": "Instance Method",
    "offset": 33637,
    "length": 165,
    "sourcetext": " func animateNextSegment() {\n        pausedProgress = 0 // set this when other than current pause segment selected\n        animateNextSegmentWithRemainingTime()\n    "
  },
  {
    "name": "animateToPreviousSegment()",
    "kind": "Instance Method",
    "offset": 33840,
    "length": 212,
    "sourcetext": " func animateToPreviousSegment() {\n        guard currentSegment > 0 else {\n            return\n        }\n        currentSegment -= 1\n        progress = 0\n        setNeedsDisplay()\n        animateNextSegment()\n    "
  },
  {
    "name": "animateToNextSegment()",
    "kind": "Instance Method",
    "offset": 34086,
    "length": 223,
    "sourcetext": " func animateToNextSegment() {\n        guard currentSegment < segmentCount - 1 else {\n            return\n        }\n        currentSegment += 1\n        progress = 0\n        setNeedsDisplay()\n        animateNextSegment()\n    "
  },
  {
    "name": "animateToSegment(_:)",
    "kind": "Instance Method",
    "offset": 34375,
    "length": 160,
    "sourcetext": " func animateToSegment(_ segmentIndex: Int) {\n        currentSegment = segmentIndex\n        progress = 0\n        setNeedsDisplay()\n        updateProgress()\n    "
  },
  {
    "name": "resetAnimations()",
    "kind": "Instance Method",
    "offset": 34598,
    "length": 161,
    "sourcetext": " func resetAnimations() {\n        currentSegment = 0\n        progress = 0\n        isAnimating = false\n        setNeedsDisplay()\n        animateNextSegment()\n    "
  },
  {
    "name": "cancelAnimation()",
    "kind": "Instance Method",
    "offset": 34765,
    "length": 133,
    "sourcetext": " func cancelAnimation() {\n        // Cancel ongoing animation\n        animationCancellable?.cancel()\n        isAnimating = false\n    "
  },
  {
    "name": "pauseAnimation()",
    "kind": "Instance Method",
    "offset": 34904,
    "length": 276,
    "sourcetext": " func pauseAnimation() {\n        guard isAnimating else { return }\n        // Store the current progress state\n        pausedProgress = progress\n        // Cancel ongoing animation\n        animationCancellable?.cancel()\n        isAnimating = false\n        isPaused = true\n    "
  },
  {
    "name": "resumeAnimation()",
    "kind": "Instance Method",
    "offset": 35186,
    "length": 581,
    "sourcetext": " func resumeAnimation() {\n        guard !isAnimating, isPaused else { return }\n        // Resume animation from the stored progress state\n        isAnimating = true\n        isPaused = false\n        // Calculate the remaining time for the current segment based on the remaining progress\n        let remainingTime = TimeInterval((1.0 - pausedProgress) * animationDuration)\n        // Resume the animation from the remaining time (using default of 7 seconds if remainingTime is 0)\n        animateNextSegmentWithRemainingTime(remainingTime > 0 ? remainingTime : animationDuration)\n    "
  },
  {
    "name": "updateProgress()",
    "kind": "Instance Method",
    "offset": 35781,
    "length": 58,
    "sourcetext": " func updateProgress() {\n        animateNextSegment()\n    "
  },
  {
    "name": "draw(_:)",
    "kind": "Instance Method",
    "offset": 35854,
    "length": 2143,
    "sourcetext": " func draw(_ rect: CGRect) {\n        super.draw(rect)\n\n        guard segmentCount > 0 else { return }\n\n        layer.sublayers?.forEach { $0.removeFromSuperlayer() }\n\n        let totalSpacing = CGFloat(segmentCount - 1) * segmentSpacing\n        let availableWidth = frame.width - totalSpacing\n        let segmentWidth = availableWidth / CGFloat(segmentCount)\n        let blueWidth = segmentWidth * progress\n\n        for i in 0..<segmentCount {\n            let x = CGFloat(i) * (segmentWidth + segmentSpacing)\n\n            let segmentLayer = CAShapeLayer()\n            segmentLayer.frame = CGRect(x: x, y: (frame.height - segmentHeight) / 2, width: segmentWidth, height: segmentHeight)\n            segmentLayer.cornerRadius = segmentHeight / 2\n\n            if i < currentSegment {\n                segmentLayer.backgroundColor = UIColor(hex: \"#0DB4BA\").cgColor\n            } else {\n                segmentLayer.backgroundColor = UIColor(hex: \"#D9E4E8\").cgColor\n            }\n\n            layer.addSublayer(segmentLayer)\n\n            if i == currentSegment {\n                let blueLayer = CAShapeLayer()\n                blueLayer.frame = CGRect(x: x, y: (frame.height - segmentHeight) / 2, width: blueWidth, height: segmentHeight)\n                blueLayer.cornerRadius = segmentHeight / 2\n                blueLayer.backgroundColor = UIColor(hex: \"#0DB4BA\").cgColor\n\n                // Add rounded mask to the blue layer for rounded start and end\n                let maskPath = UIBezierPath(\n                    roundedRect: blueLayer.bounds,\n                    byRoundingCorners: [\n                        .topLeft,\n                        .bottomLeft,\n                        .topRight,\n                        .bottomRight\n                    ],\n                    cornerRadii: CGSize(\n                        width: segmentHeight / 2,\n                        height: segmentHeight / 2\n                    )\n                )\n                let maskLayer = CAShapeLayer()\n                maskLayer.path = maskPath.cgPath\n                blueLayer.mask = maskLayer\n\n                layer.addSublayer(blueLayer)\n            }\n        }\n    "
  },
  {
    "name": "init(frame:)",
    "kind": "Instance Method",
    "offset": 38679,
    "length": 82,
    "sourcetext": " init(frame: CGRect) {\n        super.init(frame: frame)\n        setUpLayout()\n    "
  },
  {
    "name": "init(coder:)",
    "kind": "Instance Method",
    "offset": 38776,
    "length": 89,
    "sourcetext": " init?(coder: NSCoder) {\n        fatalError(\"init(coder:) has not been implemented\")\n    "
  },
  {
    "name": "activate()",
    "kind": "Instance Method",
    "offset": 38878,
    "length": 91,
    "sourcetext": " func activate() {\n        isHidden = false\n        activityIndicator.startAnimating()\n    "
  },
  {
    "name": "deactivate()",
    "kind": "Instance Method",
    "offset": 38982,
    "length": 49,
    "sourcetext": " func deactivate() {\n        isHidden = true\n    "
  },
  {
    "name": "setUpLayout()",
    "kind": "Instance Method",
    "offset": 39045,
    "length": 173,
    "sourcetext": " func setUpLayout() {\n        addSubview(activityIndicator)\n        activityIndicator.snp.makeConstraints { make in\n            make.center.equalToSuperview()\n        }\n    "
  },
  {
    "name": "init(frame:)",
    "kind": "Instance Method",
    "offset": 41272,
    "length": 89,
    "sourcetext": " init(frame: CGRect) {\n        super.init(frame: frame)\n        self.setUpSubviews()\n    "
  },
  {
    "name": "init(coder:)",
    "kind": "Instance Method",
    "offset": 41375,
    "length": 89,
    "sourcetext": " init?(coder: NSCoder) {\n        fatalError(\"init(coder:) has not been implemented\")\n    "
  },
  {
    "name": "setUpSubviews()",
    "kind": "Instance Method",
    "offset": 41477,
    "length": 1743,
    "sourcetext": " func setUpSubviews() {\n        let spacer1 = UIView()\n        let spacer2 = UIView()\n        [messageLabel, spacer1, imageView, spacer2, button].forEach {\n            addSubview($0)\n        }\n        addSubview(previousCard)\n        addSubview(nextCard)\n        addGestureRecognizer(regionTapGestureRecognizer)\n        addGestureRecognizer(longPressGestureRecognizer)\n        messageLabel.snp.makeConstraints {\n            $0.leading.top.trailing.equalToSuperview()\n        }\n        spacer1.snp.makeConstraints {\n            $0.top.equalTo(messageLabel.snp.bottom)\n            $0.leading.trailing.equalToSuperview()\n        }\n        imageView.snp.makeConstraints {\n            $0.width.equalToSuperview().multipliedBy(0.96)\n            $0.height.equalTo(imageView.snp.width)\n            $0.centerX.equalToSuperview()\n            $0.top.equalTo(spacer1.snp.bottom)\n        }\n        spacer2.snp.makeConstraints {\n            $0.top.equalTo(imageView.snp.bottom)\n            $0.leading.trailing.equalToSuperview()\n            $0.height.equalTo(spacer1.snp.height)\n        }\n        button.snp.makeConstraints {\n            $0.top.equalTo(spacer2.snp.bottom)\n            $0.leading.trailing.equalToSuperview()\n            $0.bottom.equalToSuperview().inset(DesignSystem.shared.spacer.sm)\n            $0.height.equalTo(56.0)\n        }\n        previousCard.snp.makeConstraints {\n            $0.top.leading.equalToSuperview()\n            $0.bottom.equalTo(button.snp.top)\n            $0.width.equalToSuperview().multipliedBy(0.25)\n        }\n        nextCard.snp.makeConstraints {\n            $0.top.trailing.equalToSuperview()\n            $0.bottom.equalTo(button.snp.top)\n            $0.width.equalToSuperview().multipliedBy(0.25)\n        }\n    "
  },
  {
    "name": "didTapButton()",
    "kind": "Instance Method",
    "offset": 43239,
    "length": 60,
    "sourcetext": " func didTapButton() {\n        buttonTapped?(indexPath)\n    "
  },
  {
    "name": "didTapRegion(sender:)",
    "kind": "Instance Method",
    "offset": 43318,
    "length": 498,
    "sourcetext": " func didTapRegion(sender: UITapGestureRecognizer) {\n        if sender == regionTapGestureRecognizer {\n            let location = sender.location(in: previousCard)\n            if previousCard.bounds.contains(location) {\n                previousCardTapped?(indexPath)\n            } else {\n                let location = sender.location(in: nextCard)\n                if nextCard.bounds.contains(location) {\n                    nextCardTapped?(indexPath)\n                }\n            }\n        }\n    "
  },
  {
    "name": "handleLongPress(_:)",
    "kind": "Instance Method",
    "offset": 43835,
    "length": 372,
    "sourcetext": " func handleLongPress(_ gesture: UILongPressGestureRecognizer) {\n        switch gesture.state {\n        case .began:\n            // Pause animation\n            delegate?.pauseProgressBarAnimation()\n        case .ended, .cancelled, .failed:\n            // Resume animation\n            delegate?.resumeProgressBarAnimation()\n        default:\n            break\n        }\n    "
  },
  {
    "name": "configure(card:)",
    "kind": "Instance Method",
    "offset": 44212,
    "length": 193,
    "sourcetext": " func configure(card: DiscoverCard) {\n        messageLabel.text = card.description\n        imageView.urlString = card.imageURLString\n        button.setTitle(card.buttonTitle, for: .normal)\n    "
  },
  {
    "name": "init()",
    "kind": "Instance Method",
    "offset": 44945,
    "length": 9,
    "sourcetext": " init() {"
  },
  {
    "name": "getCards()",
    "kind": "Instance Method",
    "offset": 45032,
    "length": 112,
    "sourcetext": " func getCards() async throws -> DiscoverCardsResponse {\n        try await client.requestCards().toResponse\n    "
  },
  {
    "name": "getCards()",
    "kind": "Instance Method",
    "offset": 46434,
    "length": 53,
    "sourcetext": " func getCards() async throws -> DiscoverCardsRespons"
  },
  {
    "name": "requestCards()",
    "kind": "Instance Method",
    "offset": 46954,
    "length": 60,
    "sourcetext": " func requestCards() async throws -> DiscoverCardsResponseDT"
  },
  {
    "name": "init()",
    "kind": "Instance Method",
    "offset": 48713,
    "length": 59,
    "sourcetext": " init() {\n        fatalError(\"init() not implemented\")\n    "
  },
  {
    "name": "init(baseURL:dataProvider:)",
    "kind": "Instance Method",
    "offset": 48782,
    "length": 172,
    "sourcetext": " init(baseURL: URL, dataProvider: DBSDataProvider? = Resolver.optional(DBSDataProvider.self)) {\n        self.dataProvider = dataProvider\n        self.baseURL = baseURL\n    "
  },
  {
    "name": "requestCards()",
    "kind": "Instance Method",
    "offset": 49030,
    "length": 621,
    "sourcetext": " func requestCards() async throws -> DiscoverCardsResponseDTO {\n        let endpointConfiguration = Endpoint.getStories\n        \n        guard let dataProvider = dataProvider else { throw CallError.missingDataProvider }\n        \n        let request = try RequestBuilder.makeRequest(baseURL: baseURL, configuration: endpointConfiguration)\n        let call = Call<DiscoverCardsResponseDTO>(dataProvider: dataProvider, request: request)\n        let callResponse = try await call.execute()\n        \n        guard let responseBody = callResponse.body else { throw CallError.emptyDataResponse }\n        return responseBody\n    "
  },
  {
    "name": "makeClient()",
    "kind": "Static Method",
    "offset": 49707,
    "length": 450,
    "sourcetext": " static func makeClient() -> DiscoverCardsClientProtocol {\n        guard let serverURL = URL(string: Backbase.configuration().backbase.serverURL) else {\n            fatalError(\"Invalid or no serverURL found in the SDK configuration.\")\n        }\n        \n        let requestURL = serverURL.appendingPathComponent(\"/api/discovery-service/client-api/v1/\")\n        let client = DiscoverCardsClient(baseURL: requestURL)\n        \n        return client\n    "
  },
  {
    "name": "validateAccountID(_:)",
    "kind": "Instance Method",
    "offset": 50650,
    "length": 117,
    "sourcetext": " func validateAccountID(_ requestObject: AccountIDValidationRequestDTO) async throws -> AccountIDValidationResponseDT"
  },
  {
    "name": "getBeneficiaryDetails(_:)",
    "kind": "Instance Method",
    "offset": 50772,
    "length": 94,
    "sourcetext": " func getBeneficiaryDetails(_ requestId: String) async throws -> AccountIDValidationResponseDT"
  },
  {
    "name": "init()",
    "kind": "Instance Method",
    "offset": 51036,
    "length": 59,
    "sourcetext": " init() {\n        fatalError(\"init() not implemented\")\n    "
  },
  {
    "name": "init(baseURL:dataProvider:)",
    "kind": "Instance Method",
    "offset": 51101,
    "length": 172,
    "sourcetext": " init(baseURL: URL, dataProvider: DBSDataProvider? = Resolver.optional(DBSDataProvider.self)) {\n        self.dataProvider = dataProvider\n        self.baseURL = baseURL\n    "
  },
  {
    "name": "validateAccountID(_:)",
    "kind": "Instance Method",
    "offset": 52621,
    "length": 1121,
    "sourcetext": " func validateAccountID(_ requestObject: AccountIDValidationRequestDTO) async throws -> AccountIDValidationResponseDTO {\n        do {\n            if requestObject.customerType == .NEO {\n                return try await performRequest(\n                    endpoint: Endpoint.validateNeoAccountID(requestObject: requestObject)\n                )\n            } else {\n                return try await performRequest(\n                    endpoint: Endpoint.validateAccountID(requestObject: requestObject)\n                )\n            }\n        } catch ClientCommon.ErrorResponse.error(let code, let data, let error) {\n            if code == 400, let data {\n                do {\n                    let error: AccountIDValidationResponseDTO.Error = try JSONDecoder().decode(\n                        AccountIDValidationResponseDTO.Error.self,\n                        from: data\n                    )\n                    throw error.toResponse\n                } catch let error {\n                    throw error\n                }\n            }\n            throw ClientCommon.ErrorResponse.error(code, data, error)\n        }\n    "
  },
  {
    "name": "getBeneficiaryDetails(_:)",
    "kind": "Instance Method",
    "offset": 53748,
    "length": 214,
    "sourcetext": " func getBeneficiaryDetails(_ requestId: String) async throws -> AccountIDValidationResponseDTO {\n        try await performRequest(\n            endpoint: Endpoint.getBeneficiary(requestId: requestId)\n        )\n    "
  },
  {
    "name": "makeClient()",
    "kind": "Static Method",
    "offset": 54054,
    "length": 475,
    "sourcetext": " static func makeClient() -> AccountIDValidationClientProtocol {\n            guard let serverURL = URL(string: Backbase.configuration().backbase.serverURL) else {\n                fatalError(\"Invalid or no serverURL found in the SDK configuration.\")\n            }\n\n            let requestURL = serverURL.appendingPathComponent(\"api/beneficiary-manager/client-api/v2/\")\n            let client = AccountIDValidationClient(baseURL: requestURL)\n\n            return client\n        "
  },
  {
    "name": "encode(to:)",
    "kind": "Instance Method",
    "offset": 55545,
    "length": 558,
    "sourcetext": " func encode(to encoder: Encoder) throws {\n        var container = encoder.container(keyedBy: CodingKeys.self)\n        switch accountID {\n        case .accountNumber(let value):\n            try container.encode(value, forKey: .accountNumber)\n        case .iban(let value):\n            try container.encode(value, forKey: .iban)\n        case .phoneNumber(let value):\n            try container.encode(value, forKey: .phoneNumber)\n        }\n        try container.encode(accountType, forKey: .accountType)\n        try container.encode(alias, forKey: .alias)\n    "
  },
  {
    "name": "init(accountID:alias:validationType:)",
    "kind": "Instance Method",
    "offset": 56814,
    "length": 225,
    "sourcetext": " init(\n        accountID: AccountID,\n        alias: String? = nil,\n        validationType: ValidationType\n    ) {\n        self.accountID = accountID\n        self.alias = alias\n        self.validationType = validationType\n    "
  },
  {
    "name": "init(name:iban:accountNumber:bankCode:bankName:phoneNumber:additions:)",
    "kind": "Instance Method",
    "offset": 57400,
    "length": 550,
    "sourcetext": " init(\n            name: String,\n            iban: String? = nil,\n            accountNumber: String? = nil,\n            bankCode: String? = nil,\n            bankName: String? = nil,\n            phoneNumber: String? = nil,\n            additions: [String: String]? = nil\n        ) {\n            self.name = name\n            self.iban = iban\n            self.accountNumber = accountNumber\n            self.bankCode = bankCode\n            self.bankName = bankName\n            self.phoneNumber = phoneNumber\n            self.additions = additions\n        "
  },
  {
    "name": "init(name:account:)",
    "kind": "Instance Method",
    "offset": 58217,
    "length": 101,
    "sourcetext": " init(name: String, account: Account?) {\n        self.name = name\n        self.account = account\n    "
  },
  {
    "name": "init(content:)",
    "kind": "Instance Method",
    "offset": 63103,
    "length": 58,
    "sourcetext": " init(content: Data) {\n        self.content = content\n    "
  },
  {
    "name": "fetchReceipt(_:)",
    "kind": "Instance Method",
    "offset": 63509,
    "length": 82,
    "sourcetext": " func fetchReceipt(_ requestObject: ReceiptRequest) async throws -> ReceiptRespons"
  },
  {
    "name": "init(baseURL:service:dataProvider:)",
    "kind": "Instance Method",
    "offset": 65017,
    "length": 254,
    "sourcetext": " init(baseURL: URL,\n                service: Service,\n                dataProvider: DBSDataProvider? = Resolver.optional(DBSDataProvider.self)) {\n\n        self.dataProvider = dataProvider\n        self.baseURL = baseURL\n        self.service = service\n    "
  },
  {
    "name": "fetchReceipt(_:)",
    "kind": "Instance Method",
    "offset": 65284,
    "length": 654,
    "sourcetext": " func fetchReceipt(_ requestObject: ReceiptRequest) async throws -> ReceiptResponse {\n        let endpointConfiguration = Endpoint.receipt(requestObject: requestObject, service: service)\n        guard let dataProvider = dataProvider else { throw CallError.missingDataProvider }\n\n        let request = try RequestBuilder.makeRequest(baseURL: baseURL, configuration: endpointConfiguration)\n        let call = Call<ReceiptResponse>(dataProvider: dataProvider, request: request)\n        let callResponse = try await call.execute()\n\n        guard let responseBody = callResponse.body else { throw CallError.emptyDataResponse }\n        return responseBody\n    "
  },
  {
    "name": "init(id:)",
    "kind": "Instance Method",
    "offset": 66249,
    "length": 45,
    "sourcetext": " init(id: String) {\n        self.id = id\n    "
  },
  {
    "name": "performRequest(endpoint:bodyEncoder:)",
    "kind": "Instance Method",
    "offset": 67315,
    "length": 1419,
    "sourcetext": " func performRequest<Response: Decodable>(\n        endpoint: EndpointConfiguration,\n        bodyEncoder: RequestBodyEncoder = JSONEncoder()\n    ) async throws -> Response {\n        guard let dataProvider = dataProvider else { throw CallError.missingDataProvider }\n        let request = try RequestBuilder.makeRequest(baseURL: baseURL, configuration: endpoint, bodyEncoder: bodyEncoder)\n        let call = Call<Response>(dataProvider: dataProvider, request: request)\n        let callResponse = try await withTaskCancellationHandler {\n            do {\n                return try await call.execute()\n            } catch ClientCommon.ErrorResponse.error(let code, let data, let error) {\n                let restrictionError = userRestriction(from: data)\n\n                if restrictionError?.has(error: .serviceAgreement) == true {\n                    throw CommonError.serviceAgreementMissing\n                } else if code == 403 {\n                    throw CommonError.stepUpCancelledByUser\n                } else if restrictionError?.has(error: .serviceDenied) == true {\n                    throw CommonError.serviceDenied\n                }\n\n                throw ClientCommon.ErrorResponse.error(code, data, error)\n            }\n        } onCancel: {\n            _ = call.cancel()\n        }\n        guard let responseBody = callResponse.body else { throw CallError.emptyDataResponse }\n        return responseBody\n    "
  },
  {
    "name": "userRestriction(from:)",
    "kind": "Instance Method",
    "offset": 68748,
    "length": 210,
    "sourcetext": " func userRestriction(from data: Data?) -> UserRestrictionErrorResponse? {\n        guard let data else { return nil }\n        return try? JSONDecoder().decode(UserRestrictionErrorResponse.self, from: data)\n    "
  },
  {
    "name": "performRequest(endpoint:)",
    "kind": "Instance Method",
    "offset": 68964,
    "length": 140,
    "sourcetext": " func performRequest(endpoint: EndpointConfiguration) async throws {\n        try await performRequest(endpoint: endpoint) as NoResponse\n    "
  },
  {
    "name": "has(error:)",
    "kind": "Instance Method",
    "offset": 69312,
    "length": 102,
    "sourcetext": " func has(error code: ErrorKey) -> Bool {\n        errors.first { $0.key == code.rawValue } != nil\n    "
  },
  {
    "name": "init(extraHeaders:)",
    "kind": "Instance Method",
    "offset": 70672,
    "length": 91,
    "sourcetext": " init(extraHeaders: [String: String] = [:]) {\n        self.extraHeaders = extraHeaders\n    "
  },
  {
    "name": "execute(_:completionHandler:)",
    "kind": "Instance Method",
    "offset": 70776,
    "length": 824,
    "sourcetext": " func execute(_ request: URLRequest, completionHandler: ((URLResponse?, Data?, Error?) -> Void)? = nil) {\n        let session = URLSession(configuration: Backbase.securitySessionConfiguration())\n        var mutableRequest = request\n\n        extraHeaders.forEach { key, value in\n            mutableRequest.allHTTPHeaderFields?[key] = value\n        }\n        Backbase.securitySessionConfiguration().httpAdditionalHeaders?.forEach { header in\n            if let key = header.key as? String, let value = header.value as? String {\n                mutableRequest.allHTTPHeaderFields?[key] = value\n            }\n        }\n\n        session.dataTask(with: mutableRequest) { data, response, error in\n            DispatchQueue.main.async {\n                completionHandler?(response, data, error)\n            }\n        }.resume()\n    "
  },
  {
    "name": "execute()",
    "kind": "Instance Method",
    "offset": 73540,
    "length": 237,
    "sourcetext": " func execute() async throws -> ClientCommon.Response<T> {\n        try await withCheckedThrowingContinuation { continuation in\n            execute { result in\n                continuation.resume(with: result)\n            }\n        }\n    "
  },
  {
    "name": "init()",
    "kind": "Instance Method",
    "offset": 74335,
    "length": 59,
    "sourcetext": " init() {\n        fatalError(\"init() not implemented\")\n    "
  },
  {
    "name": "init(baseURL:dataProvider:)",
    "kind": "Instance Method",
    "offset": 74407,
    "length": 172,
    "sourcetext": " init(baseURL: URL, dataProvider: DBSDataProvider? = Resolver.optional(DBSDataProvider.self)) {\n        self.dataProvider = dataProvider\n        self.baseURL = baseURL\n    "
  },
  {
    "name": "makeRequest(baseURL:configuration:bodyEncoder:requiresMfa:)",
    "kind": "Static Method",
    "offset": 75946,
    "length": 2040,
    "sourcetext": " static func makeRequest(\n        baseURL: URL,\n        configuration: EndpointConfiguration,\n        bodyEncoder: RequestBodyEncoder = JSONEncoder(),\n        requiresMfa: Bool = true\n    ) throws -> URLRequest {\n        var requestURL = baseURL.appendingPathComponent(configuration.path)\n        var components = URLComponents(url: requestURL, resolvingAgainstBaseURL: true)\n        var queryItems = components?.queryItems ?? []\n        if requiresMfa == true && queryItems.first(where: {$0.name == \"mfaState\"}) == nil {\n            queryItems.append(.init(name: \"mfaState\", value: \"initiate\"))\n        }\n        // Condtion added, because empty queryItems set to URLComponents, add an extra '?' to the components?.url generated\n        components?.queryItems = queryItems.isEmpty ? nil : queryItems\n        if let newURL = components?.url {\n            requestURL = newURL\n        }\n        let queryKeyPairs = (configuration.queryParameters ?? []).map { ($0.name, $0.value) }\n        var queryParameters = Dictionary(queryKeyPairs, uniquingKeysWith: { (first, _) in return first }) as [String: Any]\n        if requiresMfa == true && queryParameters[\"mfaState\"] == nil {\n            queryParameters[\"mfaState\"] = \"initiate\"\n        }\n        var request = try Self.createURLRequest(\n            requestUrl: requestURL,\n            method: configuration.method.rawValue,\n            queryParameters: queryParameters,\n            bodyParameters: nil,\n            bodyType: configuration.body != nil ? .json : .none)\n\n        if let body = configuration.body {\n            request.httpBody = try bodyEncoder.encode(body)\n            request.setValue(\"application/json\", forHTTPHeaderField: \"Content-Type\")\n        }\n\n        if let header = configuration.header {\n            var allHTTPHeaderFields = request.allHTTPHeaderFields ?? [:]\n            for (key, value) in header {\n                allHTTPHeaderFields[key] = value\n            }\n            request.allHTTPHeaderFields = allHTTPHeaderFields\n        }\n\n        return request\n    "
  },
  {
    "name": "encode(_:)",
    "kind": "Instance Method",
    "offset": 78031,
    "length": 60,
    "sourcetext": " func encode<T>(_ value: T) throws -> Data where T: Encodabl"
  },
  {
    "name": "init(images:strings:styles:)",
    "kind": "Instance Method",
    "offset": 78717,
    "length": 197,
    "sourcetext": " init(images: Images = .init(), strings: Strings = .init(), styles: Styles = .init()) {\n            self.images = images\n            self.strings = strings\n            self.styles = styles\n        "
  },
  {
    "name": "init()",
    "kind": "Instance Method",
    "offset": 80831,
    "length": 9,
    "sourcetext": " init() {"
  },
  {
    "name": "init()",
    "kind": "Instance Method",
    "offset": 83663,
    "length": 9,
    "sourcetext": " init() {"
  },
  {
    "name": "init()",
    "kind": "Instance Method",
    "offset": 84599,
    "length": 9,
    "sourcetext": " init() {"
  },
  {
    "name": "imagePicker(_:grantedAccess:to:)",
    "kind": "Instance Method",
    "offset": 85239,
    "length": 116,
    "sourcetext": " func imagePicker(_ imagePicker: ImagePicker, grantedAccess: Bool, to sourceType: UIImagePickerController.SourceType"
  },
  {
    "name": "imagePicker(_:didSelect:)",
    "kind": "Instance Method",
    "offset": 85360,
    "length": 70,
    "sourcetext": " func imagePicker(_ imagePicker: ImagePicker, didSelect image: UIImage"
  },
  {
    "name": "cancelButtonDidClick(on:)",
    "kind": "Instance Method",
    "offset": 85435,
    "length": 52,
    "sourcetext": " func cancelButtonDidClick(on imageView: ImagePicker"
  },
  {
    "name": "title(with:)",
    "kind": "Static Method",
    "offset": 86540,
    "length": 81,
    "sourcetext": " static func title(with target: String) -> String { String(format: title, target)"
  },
  {
    "name": "description(with:)",
    "kind": "Static Method",
    "offset": 86634,
    "length": 93,
    "sourcetext": " static func description(with target: String) -> String { String(format: description, target)"
  },
  {
    "name": "dismiss()",
    "kind": "Instance Method",
    "offset": 87558,
    "length": 71,
    "sourcetext": " func dismiss() { controller?.dismiss(animated: true, completion: nil) "
  },
  {
    "name": "present(parent:sourceType:)",
    "kind": "Instance Method",
    "offset": 87641,
    "length": 400,
    "sourcetext": " func present(parent viewController: UIViewController, sourceType: UIImagePickerController.SourceType) {\n        let controller = UIImagePickerController()\n        controller.delegate = self\n        controller.sourceType = sourceType\n        self.controller = controller\n        DispatchQueue.main.async {\n            viewController.present(controller, animated: true, completion: nil)\n        }\n    "
  },
  {
    "name": "showAlert(targetName:completion:)",
    "kind": "Instance Method",
    "offset": 88055,
    "length": 1377,
    "sourcetext": " func showAlert(targetName: TargetName, completion: ((Bool) -> Void)?) {\n        DispatchQueue.main.async { [weak self] in\n            guard let self else { return }\n            let alertController = UIAlertController(title: Strings.AccessRequest.title(with: targetName.string),\n                                                    message: Strings.AccessRequest.description(with: targetName.string),\n                                                    preferredStyle: .alert)\n            alertController.addAction(UIAlertAction(title: Strings.AccessRequest.settingsButton, style: .default, handler: { action in\n                guard   let settingsUrl = URL(string: UIApplication.openSettingsURLString),\n                        UIApplication.shared.canOpenURL(settingsUrl) else { completion?(false); return }\n                UIApplication.shared.open(settingsUrl, options: [:]) { [weak self] _ in\n                    self?.showAlert(targetName: targetName, completion: completion)\n                }\n            }))\n            alertController.addAction(UIAlertAction(\n                title: Strings.AccessRequest.cancelButton, style: .cancel, handler: { _ in completion?(false) }\n            ))\n            UIApplication.shared.windows.filter { $0.isKeyWindow }.first?\n                .rootViewController?.present(alertController, animated: true, completion: nil)\n        }\n    "
  },
  {
    "name": "cameraAccessRequest()",
    "kind": "Instance Method",
    "offset": 89445,
    "length": 990,
    "sourcetext": " func cameraAccessRequest() {\n        if delegate == nil { return }\n        let source = UIImagePickerController.SourceType.camera\n        if AVCaptureDevice.authorizationStatus(for: .video) ==  .authorized {\n            delegate?.imagePicker(self, grantedAccess: true, to: source)\n        } else {\n            // Ensure it doesn't try to run on simulator\n            guard UIImagePickerController.isSourceTypeAvailable(.camera) else { return }\n\n            AVCaptureDevice.requestAccess(for: .video) { [weak self] granted in\n                guard let self else { return }\n                if granted {\n                    self.delegate?.imagePicker(self, grantedAccess: granted, to: source)\n                } else {\n                    if self.isCameraAccessDenied == false { self.isCameraAccessDenied = true ; return }\n                    self.showAlert(targetName: .camera) { self.delegate?.imagePicker(self, grantedAccess: $0, to: source) }\n                }\n            }\n        }\n    "
  },
  {
    "name": "photoGalleryAccessRequest()",
    "kind": "Instance Method",
    "offset": 90448,
    "length": 775,
    "sourcetext": " func photoGalleryAccessRequest() {\n        PHPhotoLibrary.requestAuthorization { [weak self] result in\n            guard let self else { return }\n            let source = UIImagePickerController.SourceType.photoLibrary\n            if result == .authorized {\n                DispatchQueue.main.async { [weak self] in\n                    guard let self else { return }\n                    self.delegate?.imagePicker(self, grantedAccess: result == .authorized, to: source)\n                }\n            } else {\n                if self.isPhotoLibraryAccessDenied == false { self.isPhotoLibraryAccessDenied = true; return }\n                self.showAlert(targetName: .photoGallery) { self.delegate?.imagePicker(self, grantedAccess: $0, to: source) }\n            }\n        }\n    "
  },
  {
    "name": "imagePickerController(_:didFinishPickingMediaWithInfo:)",
    "kind": "Instance Method",
    "offset": 91354,
    "length": 539,
    "sourcetext": " func imagePickerController(\n        _ picker: UIImagePickerController,\n        didFinishPickingMediaWithInfo info: [UIImagePickerController.InfoKey: Any]\n    ) {\n        if let image = info[.editedImage] as? UIImage {\n            delegate?.imagePicker(self, didSelect: image)\n            return\n        }\n\n        if let image = info[.originalImage] as? UIImage {\n            delegate?.imagePicker(self, didSelect: image)\n        } else {\n            // Other source\n            // TODO: Handle it in a future US, if needed\n        }\n    "
  },
  {
    "name": "imagePickerControllerDidCancel(_:)",
    "kind": "Instance Method",
    "offset": 91906,
    "length": 127,
    "sourcetext": " func imagePickerControllerDidCancel(_ picker: UIImagePickerController) {\n        delegate?.cancelButtonDidClick(on: self)\n    "
  },
  {
    "name": "prepaidOriginationDisabled()",
    "kind": "Instance Method",
    "offset": 92517,
    "length": 241,
    "sourcetext": " func prepaidOriginationDisabled() -> Bool {\n        if disabledCardfeatures == nil || disabledCardfeatures?.prepaidOriginationDisabled == \"true\" {\n            refreshRestrictions()\n            return true\n        }\n        return false\n    "
  },
  {
    "name": "prepaidViewDetailsDisabled()",
    "kind": "Instance Method",
    "offset": 92771,
    "length": 241,
    "sourcetext": " func prepaidViewDetailsDisabled() -> Bool {\n        if disabledCardfeatures == nil || disabledCardfeatures?.prepaidViewDetailsDisabled == \"true\" {\n            refreshRestrictions()\n            return true\n        }\n        return false\n    "
  },
  {
    "name": "prepaidAppleWalletDisabled()",
    "kind": "Instance Method",
    "offset": 93025,
    "length": 241,
    "sourcetext": " func prepaidAppleWalletDisabled() -> Bool {\n        if disabledCardfeatures == nil || disabledCardfeatures?.prepaidAppleWalletDisabled == \"true\" {\n            refreshRestrictions()\n            return true\n        }\n        return false\n    "
  },
  {
    "name": "fetchRestrictions()",
    "kind": "Instance Method",
    "offset": 93804,
    "length": 37,
    "sourcetext": " func fetchRestrictions() async throw"
  },
  {
    "name": "isLocalTransferDisabled()",
    "kind": "Instance Method",
    "offset": 93847,
    "length": 38,
    "sourcetext": " func isLocalTransferDisabled() -> Boo"
  },
  {
    "name": "isRequestMoneyDisabled()",
    "kind": "Instance Method",
    "offset": 93890,
    "length": 37,
    "sourcetext": " func isRequestMoneyDisabled() -> Boo"
  },
  {
    "name": "isQuickPayDisabled()",
    "kind": "Instance Method",
    "offset": 93932,
    "length": 33,
    "sourcetext": " func isQuickPayDisabled() -> Boo"
  },
  {
    "name": "isInternationalTransferDisabled()",
    "kind": "Instance Method",
    "offset": 93970,
    "length": 46,
    "sourcetext": " func isInternationalTransferDisabled() -> Boo"
  },
  {
    "name": "isMCDCDisabled()",
    "kind": "Instance Method",
    "offset": 94022,
    "length": 29,
    "sourcetext": " func isMCDCDisabled() -> Boo"
  },
  {
    "name": "prepaidOriginationDisabled()",
    "kind": "Instance Method",
    "offset": 94057,
    "length": 41,
    "sourcetext": " func prepaidOriginationDisabled() -> Boo"
  },
  {
    "name": "prepaidViewDetailsDisabled()",
    "kind": "Instance Method",
    "offset": 94103,
    "length": 41,
    "sourcetext": " func prepaidViewDetailsDisabled() -> Boo"
  },
  {
    "name": "prepaidAppleWalletDisabled()",
    "kind": "Instance Method",
    "offset": 94149,
    "length": 41,
    "sourcetext": " func prepaidAppleWalletDisabled() -> Boo"
  },
  {
    "name": "init()",
    "kind": "Instance Method",
    "offset": 94436,
    "length": 10,
    "sourcetext": " init() { "
  },
  {
    "name": "fetchRestrictions()",
    "kind": "Instance Method",
    "offset": 94459,
    "length": 280,
    "sourcetext": " func fetchRestrictions() async throws {\n        let usecase = NewUserRestrictionUseCase()\n        let response = try await usecase.fetchFeaturePermissionsForNewUsers()\n        transferFeatures = response.disabledPayments\n        disabledCardfeatures = response.disabledCards\n    "
  },
  {
    "name": "refreshRestrictions()",
    "kind": "Instance Method",
    "offset": 94749,
    "length": 102,
    "sourcetext": " func refreshRestrictions() {\n        Task {\n            try? await fetchRestrictions()\n        }\n    "
  },
  {
    "name": "isLocalTransferDisabled()",
    "kind": "Instance Method",
    "offset": 94864,
    "length": 242,
    "sourcetext": " func isLocalTransferDisabled() -> Bool {\n        if let transferFeatures, transferFeatures.isLocalTransferDisabled == \"true\" {\n            refreshRestrictions()\n            return true\n        } else {\n            return false\n        }\n    "
  },
  {
    "name": "isRequestMoneyDisabled()",
    "kind": "Instance Method",
    "offset": 95119,
    "length": 240,
    "sourcetext": " func isRequestMoneyDisabled() -> Bool {\n        if let transferFeatures, transferFeatures.isRequestMoneyDisabled == \"true\" {\n            refreshRestrictions()\n            return true\n        } else {\n            return false\n        }\n    "
  },
  {
    "name": "isQuickPayDisabled()",
    "kind": "Instance Method",
    "offset": 95372,
    "length": 232,
    "sourcetext": " func isQuickPayDisabled() -> Bool {\n        if let transferFeatures, transferFeatures.isQuickPayDisabled == \"true\" {\n            refreshRestrictions()\n            return true\n        } else {\n            return false\n        }\n    "
  },
  {
    "name": "isInternationalTransferDisabled()",
    "kind": "Instance Method",
    "offset": 95617,
    "length": 258,
    "sourcetext": " func isInternationalTransferDisabled() -> Bool {\n        if let transferFeatures, transferFeatures.isInternationalTransferDisabled == \"true\" {\n            refreshRestrictions()\n            return true\n        } else {\n            return false\n        }\n    "
  },
  {
    "name": "isMCDCDisabled()",
    "kind": "Instance Method",
    "offset": 95888,
    "length": 232,
    "sourcetext": " func isMCDCDisabled() -> Bool {\n        if let disabledCardfeatures, disabledCardfeatures.isMCDCDisabled == \"true\" {\n            refreshRestrictions()\n            return true\n        } else {\n            return false\n        }\n    "
  },
  {
    "name": "showErrorScreen(with:isDismissible:completion:)",
    "kind": "Instance Method",
    "offset": 96133,
    "length": 689,
    "sourcetext": " func showErrorScreen(\n        with option: GenericErrorScreen.Configuration.Option,\n        isDismissible: Bool = false,\n        completion: @escaping () -> Void\n    ) -> UIViewController {\n        var configuration: GenericErrorScreen.Configuration = .make(for: option)\n        configuration.actionButtonDisplayMode = .primaryOnly\n        configuration.isDismissByDragginEnabled = isDismissible\n        configuration.router.didSelectPrimaryActionButton = { viewController in { [weak viewController] _ in\n                viewController?.dismiss(animated: true)\n                completion()\n            }\n        }\n        return GenericErrorScreen.build(configuration: configuration)\n    "
  },
  {
    "name": "fetchFeaturePermissionsForNewUsers()",
    "kind": "Instance Method",
    "offset": 97343,
    "length": 84,
    "sourcetext": " func fetchFeaturePermissionsForNewUsers() async throws -> RestrictionFeatureRespons"
  },
  {
    "name": "init(client:)",
    "kind": "Instance Method",
    "offset": 97582,
    "length": 130,
    "sourcetext": " init(client: NewUserRestrictionClientProtocol = NewUserRestrictionClientFactory.makeClient()) {\n        self.client = client\n    "
  },
  {
    "name": "fetchFeaturePermissionsForNewUsers()",
    "kind": "Instance Method",
    "offset": 97724,
    "length": 154,
    "sourcetext": " func fetchFeaturePermissionsForNewUsers() async throws -> RestrictionFeatureResponse {\n        try await client.fetchFeaturePermissionsForNewUsers()\n    "
  },
  {
    "name": "fetchFeaturePermissionsForNewUsers()",
    "kind": "Instance Method",
    "offset": 99988,
    "length": 84,
    "sourcetext": " func fetchFeaturePermissionsForNewUsers() async throws -> RestrictionFeatureRespons"
  },
  {
    "name": "fetchFeaturePermissionsForNewUsers()",
    "kind": "Instance Method",
    "offset": 100168,
    "length": 165,
    "sourcetext": " func fetchFeaturePermissionsForNewUsers() async throws -> RestrictionFeatureResponse {\n        return try await performRequest(endpoint: Endpoint.featureFlags)\n    "
  },
  {
    "name": "makeClient()",
    "kind": "Static Method",
    "offset": 101294,
    "length": 415,
    "sourcetext": " static func makeClient() -> NewUserRestrictionClientProtocol {\n        guard let serverURL = URL(string: Backbase.configuration().backbase.serverURL) else {\n            fatalError(\"Invalid or no serverURL found in the SDK configuration.\")\n        }\n        let requestURL = serverURL.appendingPathComponent(\"api/user-profile-manager/client-api/v2\")\n        return NewUserRestrictionClient(baseURL: requestURL)\n    "
  },
  {
    "name": "init(onColor:offColor:thumbColor:)",
    "kind": "Instance Method",
    "offset": 102264,
    "length": 165,
    "sourcetext": " init(onColor: Color, offColor: Color, thumbColor: Color) {\n        self.onColor = onColor\n        self.offColor = offColor\n        self.thumbColor = thumbColor\n    "
  },
  {
    "name": "makeBody(configuration:)",
    "kind": "Instance Method",
    "offset": 102442,
    "length": 756,
    "sourcetext": " func makeBody(configuration: Self.Configuration) -> some View {\n        HStack {\n            configuration.label\n                .font(.body)\n            Spacer()\n            RoundedRectangle(cornerRadius: 16, style: .circular)\n                .fill(configuration.isOn ? onColor : offColor)\n                .frame(width: 50, height: 30)\n                .overlay(\n                    Circle()\n                        .fill(thumbColor)\n                        .padding(2)\n                        .offset(x: configuration.isOn ? 10 : -10)\n                )\n                .onTapGesture {\n                    withAnimation(.easeInOut(duration: 0.2)) {\n                        configuration.isOn.toggle()\n                    }\n                }\n        }\n    "
  },
  {
    "name": "withPatternBackground()",
    "kind": "Instance Method",
    "offset": 103652,
    "length": 99,
    "sourcetext": " func withPatternBackground() -> some View {\n        modifier(CardPatternBackgroundModifier())\n    "
  },
  {
    "name": "withPlainBackground()",
    "kind": "Instance Method",
    "offset": 103757,
    "length": 95,
    "sourcetext": " func withPlainBackground() -> some View {\n        modifier(CardPlainBackgroundModifier())\n    "
  },
  {
    "name": "withContainerCardView(topOffset:)",
    "kind": "Instance Method",
    "offset": 103858,
    "length": 207,
    "sourcetext": " func withContainerCardView(topOffset: CGFloat = DesignSystem.shared.spacer.sm) -> some View {\n        withContainerCardView {\n            Color.clear\n                .frame(height: topOffset)\n        }\n    "
  },
  {
    "name": "withContainerCardView(topView:additionalTopOffset:)",
    "kind": "Instance Method",
    "offset": 104071,
    "length": 429,
    "sourcetext": " func withContainerCardView<ContentView: View>(topView: () -> ContentView, additionalTopOffset: CGFloat = 0) -> some View {\n        let containerCardView = ContainerBackgroundView()\n            .safeAreaInset(edge: .top, content: topView)\n            .padding(.top, additionalTopOffset)\n            .ignoresSafeArea(edges: .bottom)\n        return modifier(CardPatternBackgroundModifier(backgroundOverlay: containerCardView))\n    "
  },
  {
    "name": "init()",
    "kind": "Instance Method",
    "offset": 104561,
    "length": 9,
    "sourcetext": " init() {"
  },
  {
    "name": "body(content:)",
    "kind": "Instance Method",
    "offset": 104923,
    "length": 300,
    "sourcetext": " func body(content: Content) -> some View {\n        content\n            .modifier(\n                BackgroundImageViewModifier(\n                    image: commonConfiguration.images.patternBackground.image,\n                    backgroundOverlay: backgroundOverlay\n                )\n            )\n    "
  },
  {
    "name": "init()",
    "kind": "Instance Method",
    "offset": 105304,
    "length": 59,
    "sourcetext": " init() {\n        self.backgroundOverlay = EmptyView()\n    "
  },
  {
    "name": "body(content:)",
    "kind": "Instance Method",
    "offset": 105494,
    "length": 175,
    "sourcetext": " func body(content: Content) -> some View {\n        content\n            .modifier(BackgroundImageViewModifier(image: commonConfiguration.images.gradientBackground.image))\n    "
  },
  {
    "name": "body(content:)",
    "kind": "Instance Method",
    "offset": 105816,
    "length": 292,
    "sourcetext": " func body(content: Content) -> some View {\n        content\n            .background {\n                ZStack {\n                    image\n                        .resizable()\n                        .ignoresSafeArea()\n\n                    backgroundOverlay\n                }\n            }\n    "
  },
  {
    "name": "init(image:)",
    "kind": "Instance Method",
    "offset": 106187,
    "length": 98,
    "sourcetext": " init(image: Image) {\n        self.image = image\n        self.backgroundOverlay = EmptyView()\n    "
  },
  {
    "name": "withScrollableCardBackground(topPinnedContent:topOffset:topPinnedViewPadding:)",
    "kind": "Instance Method",
    "offset": 107399,
    "length": 459,
    "sourcetext": " func withScrollableCardBackground<TopPinnedContent: View>(\n        @ViewBuilder topPinnedContent: @escaping () -> TopPinnedContent,\n        topOffset: CGFloat = DesignSystem.shared.spacer.sm,\n        topPinnedViewPadding: CGFloat = 0\n    ) -> some View {\n        modifier(ScrollableCardBackgroundModifier(\n            topPinnedContent: topPinnedContent,\n            topOffset: topOffset,\n            topPinnedViewPadding: topPinnedViewPadding\n        ))\n    "
  },
  {
    "name": "withScrollableCardBackground(topView:)",
    "kind": "Instance Method",
    "offset": 107864,
    "length": 185,
    "sourcetext": " func withScrollableCardBackground<TopView: View>(@ViewBuilder topView: @escaping () -> TopView) -> some View {\n        modifier(ScrollableCardBackgroundModifier(topView: topView))\n    "
  },
  {
    "name": "withScrollableCardBackground(topView:topPinnedContent:)",
    "kind": "Instance Method",
    "offset": 108055,
    "length": 332,
    "sourcetext": " func withScrollableCardBackground<TopView: View, TopPinnedContent: View>(\n        @ViewBuilder topView: @escaping () -> TopView,\n        @ViewBuilder topPinnedContent: @escaping () -> TopPinnedContent\n    ) -> some View {\n        modifier(ScrollableCardBackgroundModifier(topView: topView, topPinnedContent: topPinnedContent))\n    "
  },
  {
    "name": "withScrollableCardBackground(topOffset:)",
    "kind": "Instance Method",
    "offset": 108393,
    "length": 179,
    "sourcetext": " func withScrollableCardBackground(topOffset: CGFloat = DesignSystem.shared.spacer.sm) -> some View {\n        modifier(ScrollableCardBackgroundModifier(topOffset: topOffset))\n    "
  },
  {
    "name": "init(topView:topPinnedContent:)",
    "kind": "Instance Method",
    "offset": 109269,
    "length": 178,
    "sourcetext": " init(topView: @escaping () -> TopView, topPinnedContent: @escaping () -> TopPinnedContent) {\n        self.topView = topView\n        self.topPinnedContent = topPinnedContent\n    "
  },
  {
    "name": "body(content:)",
    "kind": "Instance Method",
    "offset": 109460,
    "length": 1886,
    "sourcetext": " func body(content: Content) -> some View {\n        GeometryReader { proxy in\n            OffsetObservingScrollView(offset: $scrollViewOffset) {\n                content\n                    .frame(minHeight: scrollViewContentMinHeight(container: proxy))\n                    .safeAreaInset(edge: .bottom) {\n                        Color.clear.frame(height: proxy.safeAreaInsets.bottom)\n                    }\n                    .animation(.easeOut, value: topViewOffset)\n                    .animation(.easeOut, value: pinnedContentHeight)\n            }\n            .clipped()\n            .safeAreaInset(edge: .top) {\n                Color.clear.frame(height: topViewOffset + pinnedContentHeight)\n            }\n            .withContainerCardView(topView: {\n                topView()\n                    .frame(maxWidth: .infinity)\n                    .background(GeometryReader { proxy in\n                        Color.clear\n                            .onAppear { topViewOffset = proxy.size.height }\n                            .onChange(of: proxy.size.height) { topViewOffset = $0 }\n                    })\n            }, additionalTopOffset: scrollViewContainerOffset)\n            .ignoresSafeArea(edges: .bottom)\n            .overlay {\n                VStack {\n                    topPinnedContent()\n                        .padding(.top, topPinnedViewPadding)\n                        .frame(maxWidth: .infinity)\n                        .background(GeometryReader { proxy in\n                            ContainerBackgroundView()\n                                .onAppear { pinnedContentHeight = proxy.size.height }\n                                .onChange(of: proxy.size.height) { pinnedContentHeight = $0 }\n                        })\n                    Spacer()\n                }\n                .padding(.top, scrollViewContainerOffset + topViewOffset)\n            }\n        }\n    "
  },
  {
    "name": "scrollViewContentMinHeight(container:)",
    "kind": "Instance Method",
    "offset": 111360,
    "length": 176,
    "sourcetext": " func scrollViewContentMinHeight(container: GeometryProxy) -> CGFloat {\n        container.size.height - topViewOffset - pinnedContentHeight - DesignSystem.shared.spacer.md\n    "
  },
  {
    "name": "init(topOffset:)",
    "kind": "Instance Method",
    "offset": 111652,
    "length": 153,
    "sourcetext": " init(topOffset: CGFloat) {\n        self.topPinnedContent = { EmptyView() }\n        self.topView = { AnyView(Color.clear.frame(height: topOffset)) }\n    "
  },
  {
    "name": "init(topPinnedContent:topOffset:topPinnedViewPadding:)",
    "kind": "Instance Method",
    "offset": 111890,
    "length": 324,
    "sourcetext": " init(\n        topPinnedContent: @escaping () -> TopPinnedContent,\n        topOffset: CGFloat,\n        topPinnedViewPadding: CGFloat\n    ) {\n        self.topPinnedContent = topPinnedContent\n        self.topView = { AnyView(Color.clear.frame(height: topOffset)) }\n        self.topPinnedViewPadding = topPinnedViewPadding\n    "
  },
  {
    "name": "init(topView:)",
    "kind": "Instance Method",
    "offset": 112310,
    "length": 125,
    "sourcetext": " init(topView: @escaping () -> TopView) {\n        self.topPinnedContent = { EmptyView() }\n        self.topView = topView\n    "
  },
  {
    "name": "init(viewModel:)",
    "kind": "Instance Method",
    "offset": 113009,
    "length": 84,
    "sourcetext": " init(viewModel: FullScreenErrorViewModel) {\n        self.viewModel = viewModel\n    "
  },
  {
    "name": "init(iconImage:title:description:primaryButtonTitle:primaryAction:)",
    "kind": "Instance Method",
    "offset": 115081,
    "length": 373,
    "sourcetext": " init(\n        iconImage: UIImage?,\n        title: String?,\n        description: String?,\n        primaryButtonTitle: String?,\n        primaryAction: (() -> Void)?\n    ) {\n        self.iconImage = iconImage\n        self.title = title\n        self.description = description\n        self.primaryButtonTitle = primaryButtonTitle\n        self.primaryAction = primaryAction\n    "
  },
  {
    "name": "init(with:error:)",
    "kind": "Instance Method",
    "offset": 115467,
    "length": 835,
    "sourcetext": " init(with primaryAction: (() -> Void)?, error: Error? = nil) {\n        let configuration = Resolver.resolve(SNBCommon.Configuration.self)\n        if let error, case ClientCommon.ErrorResponse.error(_, _, let callError) = error,\n           let callError = callError as? CallError, callError.isInternetConnectionError {\n            iconImage = configuration.images.noInternet\n            title = configuration.strings.noInternetTitle\n            description = configuration.strings.noInternetSubtitle\n        } else {\n            iconImage = configuration.images.somethingWentWrong\n            title = configuration.strings.loadingFailedTitle\n            description = configuration.strings.loadingFailedSubtitle\n        }\n        primaryButtonTitle = configuration.strings.tryAgainButton\n        self.primaryAction = primaryAction\n    "
  },
  {
    "name": "init(topView:contentView:bottomView:)",
    "kind": "Instance Method",
    "offset": 116775,
    "length": 255,
    "sourcetext": " init(topView: any View, contentView: any View, bottomView: (any View)?) {\n        self.topView = AnyView(topView)\n        self.contentView = AnyView(contentView)\n        if let bottomView {\n            self.bottomView = AnyView(bottomView)\n        }\n    "
  },
  {
    "name": "init(selection:content:)",
    "kind": "Instance Method",
    "offset": 119252,
    "length": 161,
    "sourcetext": " init(selection: Binding<SelectionValue>, @ViewBuilder content: @escaping () -> Content) {\n        self.selection = selection\n        self.content = content\n    "
  },
  {
    "name": "roundedBorder(cornerRadius:backgroundColor:borderColor:)",
    "kind": "Instance Method",
    "offset": 120066,
    "length": 473,
    "sourcetext": " func roundedBorder(\n        cornerRadius: CGFloat = DesignSystem.shared.cornerRadius.large,\n        backgroundColor: Color = Color.clear,\n        borderColor: Color = DesignSystem.shared.colors.inputBorder.color\n    ) -> some View {\n        background(backgroundColor)\n            .cornerRadius(cornerRadius)\n            .overlay {\n                RoundedRectangle(cornerRadius: cornerRadius)\n                    .strokeBorder(borderColor, lineWidth: 1)\n            }\n    "
  },
  {
    "name": "init(viewModel:)",
    "kind": "Instance Method",
    "offset": 121137,
    "length": 101,
    "sourcetext": " init(viewModel: AmountInputAreaViewModel) {\n        _viewModel = .init(wrappedValue: viewModel)\n    "
  },
  {
    "name": "init(title:initialValue:prefilledValue:currency:totalDueAmount:state:additionalValidations:)",
    "kind": "Instance Method",
    "offset": 121251,
    "length": 620,
    "sourcetext": " init(\n        title: String,\n        initialValue: Double,\n        prefilledValue: Double? = nil,\n        currency: String,\n        totalDueAmount: Double? = nil,\n        state: CurrentValueSubject<AmountInputState, Never>,\n        additionalValidations: [AmountValidation] = []\n    ) {\n        _viewModel = .init(wrappedValue: .init(\n            title: title,\n            initialValue: initialValue,\n            prefilledValue: prefilledValue,\n            currency: currency,\n            totalDueAmount: totalDueAmount,\n            state: state,\n            additionalValidations: additionalValidations\n        ))\n    "
  },
  {
    "name": "formatter(usesGroupingSeparator:)",
    "kind": "Instance Method",
    "offset": 125521,
    "length": 561,
    "sourcetext": " func formatter(usesGroupingSeparator: Bool = true) -> NumberFormatter {\n        let formatter = NumberFormatter()\n        formatter.usesGroupingSeparator = usesGroupingSeparator\n        formatter.locale = DesignSystem.Formatting.numberLocale\n        formatter.numberStyle = .decimal\n        formatter.alwaysShowsDecimalSeparator = true\n        formatter.maximumFractionDigits = 2\n        formatter.minimumFractionDigits = 2\n        formatter.roundingMode = .halfDown\n        formatter.locale = DesignSystem.Formatting.numberLocale\n        return formatter\n    "
  },
  {
    "name": "init(prefilledValue:initialValue:currency:)",
    "kind": "Instance Method",
    "offset": 126095,
    "length": 284,
    "sourcetext": " init(prefilledValue: Double? = nil, initialValue: Double, currency: String) {\n        self.value = prefilledValue\n        self.placeholder = DesignSystem.shared.formatting.formatAmount(value: initialValue) ?? \"-\"\n        self.currency = currency\n        applyFormattingToInput()\n    "
  },
  {
    "name": "resetFormattingToInput()",
    "kind": "Instance Method",
    "offset": 126385,
    "length": 187,
    "sourcetext": " func resetFormattingToInput() {\n        let amount = formatter.number(from: editedText)?.stringValue\n        editedText = String.sanitizeAmountForInput(amount: amount) ?? editedText\n    "
  },
  {
    "name": "applyFormattingToInput()",
    "kind": "Instance Method",
    "offset": 126578,
    "length": 298,
    "sourcetext": " func applyFormattingToInput() {\n        guard let value else { return }\n        let formattedText = formatter.string(from: .init(floatLiteral: value)) ?? \"\"\n        if placeholder != formattedText {\n            editedText = formattedText\n        } else {\n            editedText = \"\"\n        }\n    "
  },
  {
    "name": "textDidChange(text:previousValue:)",
    "kind": "Instance Method",
    "offset": 126882,
    "length": 860,
    "sourcetext": " func textDidChange(text: String, previousValue: String) {\n        let numericRepresentation = formatter.number(from: text)?.doubleValue\n        guard numericRepresentation != value else { return }\n        value = numericRepresentation\n\n        var validatedText: String\n        if let numericRepresentation {\n            let formatString = formatter.string(from: .init(floatLiteral: numericRepresentation)) ?? \"\"\n            validatedText = text.filter(formatString.contains)\n        } else {\n            validatedText = String(previousValue.filter(text.contains))\n        }\n        if validatedText.contains(\".\"),\n           let substringAfterDot = validatedText.split(separator: \".\").last,\n           substringAfterDot.count > 2,\n           validatedText.last != \".\" {\n            validatedText.removeLast()\n        }\n        editedText = validatedText\n    "
  },
  {
    "name": "init(initialValue:currency:value:isDisabled:)",
    "kind": "Instance Method",
    "offset": 128457,
    "length": 296,
    "sourcetext": " init(initialValue: Double, currency: String, value: Binding<Double>, isDisabled: Bool) {\n        self._viewModel = .init(wrappedValue: .init(prefilledValue: value.wrappedValue, initialValue: initialValue, currency: currency))\n        self._value = value\n        self.isDisabled = isDisabled\n    "
  },
  {
    "name": "validate(amount:)",
    "kind": "Instance Method",
    "offset": 132280,
    "length": 40,
    "sourcetext": " func validate(amount: Double) -> String"
  },
  {
    "name": "init(title:initialValue:prefilledValue:currency:totalDueAmount:state:additionalValidations:)",
    "kind": "Instance Method",
    "offset": 133071,
    "length": 932,
    "sourcetext": " init(\n        title: String,\n        initialValue: Double,\n        prefilledValue: Double? = nil,\n        currency: String,\n        totalDueAmount: Double? = nil,\n        state: CurrentValueSubject<AmountInputState, Never>,\n        additionalValidations: [AmountValidation] = []\n    ) {\n        self.title = title\n        self.totalDueAmount = totalDueAmount\n        self.state = state\n        self.additionalValidations = additionalValidations\n        super.init(\n            prefilledValue: prefilledValue,\n            initialValue: initialValue,\n            currency: currency\n        )\n\n        Publishers.CombineLatest(\n            $value.removeDuplicates(),\n            $editedText.removeDuplicates()\n        )\n        .debounce(for: .seconds(0.1), scheduler: DispatchQueue.main)\n        .sink { [weak self] value, text in\n            self?.validate(amount: value, text: text)\n        }\n        .store(in: &cancellables)\n    "
  },
  {
    "name": "update(amount:)",
    "kind": "Instance Method",
    "offset": 134016,
    "length": 91,
    "sourcetext": " func update(amount: Double) {\n        value = amount\n        applyFormattingToInput()\n    "
  },
  {
    "name": "update(additionalValidations:)",
    "kind": "Instance Method",
    "offset": 134120,
    "length": 171,
    "sourcetext": " func update(additionalValidations: [AmountValidation]) {\n        self.additionalValidations = additionalValidations\n        validate(amount: value, text: editedText)\n    "
  },
  {
    "name": "validate(amount:text:)",
    "kind": "Instance Method",
    "offset": 134305,
    "length": 689,
    "sourcetext": " func validate(amount: Double?, text: String) {\n        defer { updateState() }\n        guard !text.isEmpty else {\n            return errorMessage = nil\n        }\n        guard let amount else {\n            return errorMessage = configuration.strings.amountInvalidError\n        }\n        if amount < 0 {\n            errorMessage = configuration.strings.amountNegativeError\n        } else if amount == 0 {\n            errorMessage = configuration.strings.amountZeroError\n        } else {\n            errorMessage = nil\n        }\n        additionalValidations.forEach {\n            guard let error = $0.validate(amount: amount) else { return }\n            errorMessage = error\n        }\n    "
  },
  {
    "name": "updateState()",
    "kind": "Instance Method",
    "offset": 135008,
    "length": 168,
    "sourcetext": " func updateState() {\n        if let value, errorMessage == nil {\n            state.send(.valid(value))\n        } else {\n            state.send(.invalid)\n        }\n    "
  },
  {
    "name": "formatAmount(value:)",
    "kind": "Instance Method",
    "offset": 135703,
    "length": 340,
    "sourcetext": " func formatAmount(value: Double) -> String? {\n        let options = DesignSystem.Formatting.Options(\n            locale: Self.numberLocale,\n            formattingStyle: .decimal,\n            roundingMode: .halfUp\n        )\n        return amountFormatter.format(\n            amount: .init(value),\n            options: options\n        )\n    "
  },
  {
    "name": "build(referral:shareLink:navigationController:)",
    "kind": "Static Method",
    "offset": 136464,
    "length": 316,
    "sourcetext": " static func build(referral: ReferralModel, shareLink: URL, navigationController: UINavigationController) -> UIViewController {\n        let viewModel = ReferralViewModel(with: referral, shareLink: shareLink)\n        let viewController = ReferralViewController(viewModel: viewModel)\n        return viewController\n    "
  },
  {
    "name": "init(referralCode:mcdcPoints:title:message:)",
    "kind": "Instance Method",
    "offset": 141417,
    "length": 219,
    "sourcetext": " init(referralCode: String, mcdcPoints: Int, title: String, message: String) {\n        self.referralCode = referralCode\n        self.mcdcPoints = mcdcPoints\n        self.title = title\n        self.message = message\n    "
  },
  {
    "name": "init(icon:title:subtitle:subjectLine:activityData:)",
    "kind": "Instance Method",
    "offset": 141929,
    "length": 458,
    "sourcetext": " init(\n        icon: UIImage? = configuration.images.activityIcon,\n        title: String = configuration.strings.activityTitle,\n        subtitle: String = configuration.strings.activitySubtitle,\n        subjectLine: String? = nil,\n        activityData: String\n    ) {\n        self.icon = icon\n        self.title = title\n        self.subtitle = subtitle\n        self.subjectLine = subjectLine\n        self.activityData = activityData\n        super.init()\n    "
  },
  {
    "name": "activityViewControllerPlaceholderItem(_:)",
    "kind": "Instance Method",
    "offset": 142400,
    "length": 126,
    "sourcetext": " func activityViewControllerPlaceholderItem(_ activityViewController: UIActivityViewController) -> Any {\n        subtitle\n    "
  },
  {
    "name": "activityViewController(_:itemForActivityType:)",
    "kind": "Instance Method",
    "offset": 142539,
    "length": 208,
    "sourcetext": " func activityViewController(_ activityViewController: UIActivityViewController,\n                                itemForActivityType activityType: UIActivity.ActivityType?) -> Any? {\n        activityData\n    "
  },
  {
    "name": "activityViewController(_:subjectForActivityType:)",
    "kind": "Instance Method",
    "offset": 142760,
    "length": 306,
    "sourcetext": " func activityViewController(_ activityViewController: UIActivityViewController,\n                                subjectForActivityType activityType: UIActivity.ActivityType?) -> String {\n        if activityType == .mail, let subjectLine {\n            return subjectLine\n        }\n        return title\n    "
  },
  {
    "name": "activityViewControllerLinkMetadata(_:)",
    "kind": "Instance Method",
    "offset": 143079,
    "length": 381,
    "sourcetext": " func activityViewControllerLinkMetadata(_ activityViewController: UIActivityViewController) -> LPLinkMetadata? {\n        let metadata = LPLinkMetadata()\n        metadata.title = title\n        if let image = icon {\n            metadata.iconProvider = NSItemProvider(object: image)\n        }\n        metadata.originalURL = URL(fileURLWithPath: subtitle)\n        return metadata\n    "
  },
  {
    "name": "init()",
    "kind": "Instance Method",
    "offset": 144038,
    "length": 9,
    "sourcetext": " init() {"
  },
  {
    "name": "init(with:shareLink:)",
    "kind": "Instance Method",
    "offset": 144771,
    "length": 126,
    "sourcetext": " init(with referral: ReferralModel, shareLink: URL) {\n        self.referral = referral\n        self.shareLink = shareLink\n    "
  },
  {
    "name": "presentReferralShare(from:)",
    "kind": "Instance Method",
    "offset": 144903,
    "length": 904,
    "sourcetext": " func presentReferralShare(from viewController: UIViewController) {\n        Task {\n            let shareMessage = \"\"\"\n            \\(configuration.strings.shareMessage)\n\n            \\(shareLink.absoluteString)\n            \"\"\"\n\n            await MainActor.run {\n                let source = ReferralActivityItemSource(subjectLine: configuration.strings.subjectLine, activityData: shareMessage)\n                let shareActivity = UIActivityViewController(\n                    activityItems: [source] as [Any],\n                    applicationActivities: nil)\n                shareActivity.completionWithItemsHandler = { _, status, _, _ in\n                    guard status else {\n                        return\n                    }\n                    viewController.dismiss(animated: true)\n                }\n                viewController.present(shareActivity, animated: true)\n            }\n        }\n    "
  },
  {
    "name": "makeReferralInstructions(font:)",
    "kind": "Instance Method",
    "offset": 145813,
    "length": 1308,
    "sourcetext": " func makeReferralInstructions(font: UIFont) -> NSAttributedString {\n        let instructionSteps = configuration.strings.instructions.components(separatedBy: \"\\n\")\n        let baseAttributes = [NSAttributedString.Key.font: font]\n        let isRTL = LocaleSelector.shared.isArabic\n        let indentation: CGFloat = 20\n\n        let paragraphStyle = NSMutableParagraphStyle()\n        paragraphStyle.tabStops = [NSTextTab(textAlignment: isRTL ? .right : .left, location: indentation, options: [:])]\n        paragraphStyle.paragraphSpacing = 4\n        paragraphStyle.defaultTabInterval = indentation\n        paragraphStyle.lineSpacing = 1\n        paragraphStyle.headIndent = indentation\n\n        let resultString = NSMutableAttributedString()\n        for (index, instruction) in instructionSteps.enumerated() {\n            let indexedInstruction = \"\\(instruction)\\n\"\n            let attributedString = NSMutableAttributedString(string: indexedInstruction)\n            let fullRange = NSRange(location: 0, length: attributedString.length)\n\n            attributedString.addAttribute(.paragraphStyle, value: paragraphStyle, range: fullRange)\n            attributedString.addAttribute(.font, value: font, range: fullRange)\n            resultString.append(attributedString)\n        }\n        return resultString\n    "
  },
  {
    "name": "generateQRCode()",
    "kind": "Instance Method",
    "offset": 147127,
    "length": 412,
    "sourcetext": " func generateQRCode() -> UIImage? {\n        guard let scaledQRCode = createScaledQRCode(from: shareLink.absoluteString) else { return nil }\n        guard let coloredQRCode = applyColors(to: scaledQRCode) else { return nil }\n        guard let borderedQRCode = addBorderAndRoundedCorners(to: coloredQRCode, borderWidth: 20, cornerRadius: 32) else { return nil }\n        return overlayLogo(on: borderedQRCode)\n    "
  },
  {
    "name": "createScaledQRCode(from:)",
    "kind": "Instance Method",
    "offset": 147553,
    "length": 268,
    "sourcetext": " func createScaledQRCode(from string: String) -> CIImage? {\n        let filter = CIFilter.qrCodeGenerator()\n        filter.setValue(Data(string.utf8), forKey: \"inputMessage\")\n        return filter.outputImage?.transformed(by: CGAffineTransform(scaleX: 10, y: 10))\n    "
  },
  {
    "name": "applyColors(to:)",
    "kind": "Instance Method",
    "offset": 147835,
    "length": 345,
    "sourcetext": " func applyColors(to qrCode: CIImage) -> UIImage? {\n        let filter = CIFilter.falseColor()\n        filter.inputImage = qrCode\n        filter.color0 = CIColor(color: UIColor(hex: \"#12393B\"))\n        filter.color1 = CIColor(color: .white)\n        guard let img = filter.outputImage else { return nil }\n        return UIImage(ciImage: img)\n    "
  },
  {
    "name": "addBorderAndRoundedCorners(to:borderWidth:cornerRadius:)",
    "kind": "Instance Method",
    "offset": 148194,
    "length": 667,
    "sourcetext": " func addBorderAndRoundedCorners(to image: UIImage, borderWidth: CGFloat, cornerRadius: CGFloat) -> UIImage? {\n        let newSize = CGSize(width: image.size.width + 2 * borderWidth, height: image.size.height + 2 * borderWidth)\n        UIGraphicsBeginImageContextWithOptions(newSize, false, 0)\n        defer { UIGraphicsEndImageContext() }\n\n        let rect = CGRect(origin: .zero, size: newSize)\n        UIBezierPath(roundedRect: rect, cornerRadius: cornerRadius).addClip()\n        UIColor.white.setFill()\n        UIRectFill(rect)\n        image.draw(in: rect.insetBy(dx: borderWidth, dy: borderWidth))\n\n        return UIGraphicsGetImageFromCurrentImageContext()\n    "
  },
  {
    "name": "overlayLogo(on:)",
    "kind": "Instance Method",
    "offset": 148875,
    "length": 668,
    "sourcetext": " func overlayLogo(on qrCode: UIImage) -> UIImage? {\n        let logo = configuration.images.neoIcon\n        let logoSize = CGSize(width: qrCode.size.width * 0.3, height: qrCode.size.height * 0.3)\n        let logoOrigin = CGPoint(\n            x: (qrCode.size.width - logoSize.width) / 2,\n            y: (qrCode.size.height - logoSize.height) / 2\n        )\n\n        UIGraphicsBeginImageContextWithOptions(qrCode.size, false, 0)\n        defer { UIGraphicsEndImageContext() }\n        qrCode.draw(in: CGRect(origin: .zero, size: qrCode.size))\n        logo.draw(in: CGRect(origin: logoOrigin, size: logoSize))\n\n        return UIGraphicsGetImageFromCurrentImageContext()\n    "
  },
  {
    "name": "fetchReferralDetails()",
    "kind": "Instance Method",
    "offset": 150014,
    "length": 57,
    "sourcetext": " func fetchReferralDetails() async throws -> ReferralMode"
  },
  {
    "name": "init()",
    "kind": "Instance Method",
    "offset": 150254,
    "length": 59,
    "sourcetext": " init() {\n        fatalError(\"init() not implemented\")\n    "
  },
  {
    "name": "init(baseURL:dataProvider:)",
    "kind": "Instance Method",
    "offset": 150319,
    "length": 172,
    "sourcetext": " init(baseURL: URL, dataProvider: DBSDataProvider? = Resolver.optional(DBSDataProvider.self)) {\n        self.dataProvider = dataProvider\n        self.baseURL = baseURL\n    "
  },
  {
    "name": "fetchReferralDetails()",
    "kind": "Instance Method",
    "offset": 150497,
    "length": 584,
    "sourcetext": " func fetchReferralDetails() async throws -> ReferralModel {\n        guard let dataProvider = dataProvider else { throw CallError.missingDataProvider }\n\n        let configuration = ReferralClient.Endpoint.fetchDetails\n        let request = try RequestBuilder.makeRequest(baseURL: baseURL, configuration: configuration)\n        let call = Call<ReferralModel>(dataProvider: dataProvider, request: request)\n        let callResponse = try await call.execute()\n\n        guard let responseBody = callResponse.body else { throw CallError.emptyDataResponse }\n\n        return responseBody\n    "
  },
  {
    "name": "makeClient()",
    "kind": "Static Method",
    "offset": 151524,
    "length": 403,
    "sourcetext": " static func makeClient() -> ReferralClientProtocol {\n        guard let serverURL = URL(string: Backbase.configuration().backbase.serverURL) else {\n            fatalError(\"Invalid or no serverURL found in the SDK configuration.\")\n        }\n        let requestURL = serverURL.appendingPathComponent(\"api/loyalty-integration-service/client-api/v1/\")\n        return ReferralClient(baseURL: requestURL)\n    "
  },
  {
    "name": "fetchReferralDetails()",
    "kind": "Instance Method",
    "offset": 152413,
    "length": 57,
    "sourcetext": " func fetchReferralDetails() async throws -> ReferralMode"
  },
  {
    "name": "generateReferralLink(with:)",
    "kind": "Instance Method",
    "offset": 152475,
    "length": 75,
    "sourcetext": " func generateReferralLink(with referral: ReferralModel) async throws -> UR"
  },
  {
    "name": "generateReferralLink(with:)",
    "kind": "Instance Method",
    "offset": 152598,
    "length": 75,
    "sourcetext": " func generateReferralLink(with referral: ReferralModel) async throws -> UR"
  },
  {
    "name": "init(client:linkBuilder:)",
    "kind": "Instance Method",
    "offset": 152849,
    "length": 254,
    "sourcetext": " init(\n        client: ReferralClientProtocol = ReferralClientFactory.makeClient(),\n        linkBuilder: ReferralLinkBuildable = Resolver.resolve(ReferralLinkBuildable.self)\n    ) {\n        self.client = client\n        self.linkBuilder = linkBuilder\n    "
  },
  {
    "name": "fetchReferralDetails()",
    "kind": "Instance Method",
    "offset": 153116,
    "length": 120,
    "sourcetext": " func fetchReferralDetails() async throws -> ReferralModel {\n        return try await client.fetchReferralDetails()\n    "
  },
  {
    "name": "generateReferralLink(with:)",
    "kind": "Instance Method",
    "offset": 153249,
    "length": 157,
    "sourcetext": " func generateReferralLink(with referral: ReferralModel) async throws -> URL {\n        return try await linkBuilder.generateReferralLink(with: referral)\n    "
  },
  {
    "name": "init(code:share:)",
    "kind": "Instance Method",
    "offset": 154267,
    "length": 183,
    "sourcetext": " init(code: String, share: ((String) -> Void)? = nil) {\n        self.code = code\n        self.sharingCallback = share\n\n        super.init(frame: .zero)\n        self.addSubviews()\n    "
  },
  {
    "name": "init(coder:)",
    "kind": "Instance Method",
    "offset": 154465,
    "length": 89,
    "sourcetext": " init?(coder: NSCoder) {\n        fatalError(\"init(coder:) has not been implemented\")\n    "
  },
  {
    "name": "addSubviews()",
    "kind": "Instance Method",
    "offset": 156047,
    "length": 1439,
    "sourcetext": " func addSubviews() {\n        addSubview(viewTitle)\n        addSubview(container)\n        container.addSubview(codeLabel)\n        container.addSubview(copyImage)\n\n        viewTitle.snp.makeConstraints {\n            $0.top.equalToSuperview()\n            $0.height.equalTo(30)\n            $0.leading.equalToSuperview().inset(DesignSystem.shared.spacer.md)\n        }\n\n        addSubview(shareButton)\n\n        shareButton.snp.makeConstraints {\n            $0.width.equalTo(56)\n            $0.top.equalTo(viewTitle.snp.bottom).offset(8)\n            $0.bottom.equalToSuperview()\n            $0.trailing.equalToSuperview()\n        }\n        \n        container.snp.makeConstraints {\n            $0.top.equalTo(viewTitle.snp.bottom).offset(8)\n            $0.leading.equalToSuperview().inset(DesignSystem.shared.spacer.md)\n            $0.bottom.equalToSuperview()\n            $0.height.equalTo(48)\n            $0.trailing.equalTo(shareButton.snp.leading)\n        }\n\n        codeLabel.snp.makeConstraints {\n            $0.leading.equalToSuperview().inset(DesignSystem.shared.spacer.md)\n            $0.top.bottom.equalToSuperview()\n            $0.trailing.equalTo(copyImage.snp.leading).inset(DesignSystem.shared.spacer.md)\n        }\n\n        copyImage.snp.makeConstraints {\n            $0.trailing.equalToSuperview().inset(DesignSystem.shared.spacer.md)\n            $0.centerY.equalToSuperview()\n            $0.width.height.equalTo(24)\n        }\n    "
  },
  {
    "name": "onCopyTap()",
    "kind": "Instance Method",
    "offset": 157506,
    "length": 138,
    "sourcetext": " func onCopyTap() {\n        UIPasteboard.general.string = code\n        self.displayToast(configuration.strings.copytoCliped, with: 1)\n    "
  },
  {
    "name": "onShareTap()",
    "kind": "Instance Method",
    "offset": 157664,
    "length": 56,
    "sourcetext": " func onShareTap() {\n        sharingCallback?(code)\n    "
  },
  {
    "name": "init(viewModel:)",
    "kind": "Instance Method",
    "offset": 160277,
    "length": 123,
    "sourcetext": " init(viewModel: ReferralViewModel) {\n        self.viewModel = viewModel\n        super.init(nibName: nil, bundle: nil)\n    "
  },
  {
    "name": "init(coder:)",
    "kind": "Instance Method",
    "offset": 160446,
    "length": 89,
    "sourcetext": " init?(coder: NSCoder) {\n        fatalError(\"init(coder:) has not been implemented\")\n    "
  },
  {
    "name": "loadView()",
    "kind": "Instance Method",
    "offset": 160557,
    "length": 110,
    "sourcetext": " func loadView() {\n        super.loadView()\n        title = nil\n        setupView()\n        setupNavBar()\n    "
  },
  {
    "name": "viewDidLoad()",
    "kind": "Instance Method",
    "offset": 160689,
    "length": 82,
    "sourcetext": " func viewDidLoad() {\n        super.viewDidLoad()\n        bindSubscriptions()\n    "
  },
  {
    "name": "bindSubscriptions()",
    "kind": "Instance Method",
    "offset": 160785,
    "length": 371,
    "sourcetext": " func bindSubscriptions() {\n        viewModel.$isLoading.receive(on: DispatchQueue.main)\n            .sink { [weak self] isLoading in\n                if isLoading {\n                    self?.inviteButton.startLoading()\n                } else {\n                    self?.inviteButton.stopLoading()\n                }\n            }\n            .store(in: &cancellables)\n    "
  },
  {
    "name": "inviteButtonPressed(_:)",
    "kind": "Instance Method",
    "offset": 161180,
    "length": 103,
    "sourcetext": " func inviteButtonPressed(_ sender: UIButton) {\n        viewModel.presentReferralShare(from: self)\n    "
  },
  {
    "name": "setupNavBar()",
    "kind": "Instance Method",
    "offset": 161297,
    "length": 227,
    "sourcetext": " func setupNavBar() {\n        navigationItem.leftBarButtonItem = closeBarButtonItem(image: configuration.images.closeIcon)\n        navigationItem.leftBarButtonItem?.tintColor = DesignSystem.shared.colors.neutrals.neutral00\n    "
  },
  {
    "name": "setupView()",
    "kind": "Instance Method",
    "offset": 161538,
    "length": 3292,
    "sourcetext": " func setupView() {\n        view.addSubview(backgroungImageView)\n        backgroungImageView.snp.makeConstraints {\n            $0.edges.equalToSuperview()\n        }\n        view.addSubview(inviteButton)\n        inviteButton.snp.makeConstraints {\n            $0.leading.trailing.equalToSuperview().inset(16)\n            $0.bottom.equalTo(view.safeAreaLayoutGuide).inset(9)\n            $0.height.equalTo(56)\n        }\n\n        view.addSubview(scrollView)\n        scrollView.snp.makeConstraints {\n            $0.leading.trailing.equalToSuperview()\n            $0.top.equalToSuperview().inset(68)\n            $0.bottom.equalTo(inviteButton.snp.top).offset(-36)\n        }\n\n        scrollView.addSubview(detailStack)\n        detailStack.snp.makeConstraints {\n            $0.leading.trailing.equalTo(view)\n            $0.top.equalTo(scrollView.snp.top)\n            $0.bottom.equalTo(scrollView.snp.bottom)\n        }\n\n        container.addSubview(titleLabel)\n        titleLabel.snp.makeConstraints {\n            $0.leading.trailing.equalToSuperview().inset(30)\n            $0.top.equalToSuperview()\n        }\n\n        container.addSubview(subtitleLabel)\n        subtitleLabel.snp.makeConstraints {\n            $0.leading.trailing.equalToSuperview().inset(30)\n            $0.top.equalTo(titleLabel.snp.bottom).offset(8)\n        }\n\n        container.addSubview(messageIcon)\n        messageIcon.snp.makeConstraints {\n            $0.top.equalTo(subtitleLabel.snp.bottom).offset(10)\n            $0.centerX.equalToSuperview()\n            $0.width.height.equalTo(200)\n        }\n\n        container.addSubview(instructionsTitleLabel)\n        instructionsTitleLabel.snp.makeConstraints {\n            $0.top.equalTo(messageIcon.snp.bottom).offset(24)\n            $0.leading.trailing.equalToSuperview().inset(16)\n        }\n\n        container.addSubview(instructionsLabel)\n        instructionsLabel.snp.makeConstraints {\n            $0.top.equalTo(instructionsTitleLabel.snp.bottom).offset(10)\n            $0.leading.trailing.equalToSuperview().inset(22)\n            $0.bottom.equalToSuperview()\n        }\n        detailStack.addArrangedSubview(container)\n        let sharingView = SharingView(code: viewModel.referral.referralCode) { [weak self] code in\n            let source = ReferralActivityItemSource(activityData: code)\n            let activity = UIActivityViewController(activityItems: [source], applicationActivities: nil)\n            activity.popoverPresentationController?.sourceView = self?.view\n            activity.completionWithItemsHandler = { [weak self] _, status, _, _ in\n                guard status else {\n                    return\n                }\n                self?.dismiss(animated: true)\n            }\n            self?.present(activity, animated: true)\n        }\n        detailStack.addArrangedSubview(sharingView)\n\n        backgroungImageView.image = configuration.images.backgroundImage\n        messageIcon.image = viewModel.generateQRCode() ?? configuration.images.messageIcon\n        titleLabel.text = configuration.strings.title\n        subtitleLabel.text = configuration.strings.message\n        instructionsTitleLabel.text = configuration.strings.instructionTitle\n        instructionsLabel.attributedText = viewModel.makeReferralInstructions(font: instructionsLabel.font)\n    "
  },
  {
    "name": "init(title:message:actions:style:)",
    "kind": "Instance Method",
    "offset": 165321,
    "length": 212,
    "sourcetext": " init(title: String, message: String? = nil, actions: [Alert.Action], style: Alert.Style) {\n        self.title = title\n        self.message = message\n        self.actions = actions\n        self.style = style\n    "
  },
  {
    "name": "init(title:style:action:)",
    "kind": "Instance Method",
    "offset": 165890,
    "length": 170,
    "sourcetext": " init(title: String, style: Style, action: @escaping () -> Void) {\n            self.title = title\n            self.style = style\n            self.action = action\n        "
  },
  {
    "name": "==(_:_:)",
    "kind": "Static Method",
    "offset": 166077,
    "length": 134,
    "sourcetext": " static func == (lhs: Alert.Action, rhs: Alert.Action) -> Bool {\n            lhs.title == rhs.title && lhs.style == rhs.style\n        "
  },
  {
    "name": "showAlert(_:animated:)",
    "kind": "Instance Method",
    "offset": 166261,
    "length": 926,
    "sourcetext": " func showAlert(_ alert: Alert, animated: Bool = true) {\n        let style: UIAlertController.Style\n        switch alert.style {\n        case .alert:\n            style = .alert\n        case .actionSheet:\n            style = .actionSheet\n        }\n        let alertController = UIAlertController(title: alert.title, message: alert.message, preferredStyle: style)\n        for action in alert.actions {\n            let style: UIAlertAction.Style\n            switch action.style {\n            case .defaultStyle:\n                style = .default\n            case .cancel:\n                style = .cancel\n            case .destructive:\n                style = .destructive\n            }\n            let uiAction = UIAlertAction(title: action.title, style: style) { _ in\n                action.action()\n            }\n            alertController.addAction(uiAction)\n        }\n        present(alertController, animated: animated)\n    "
  },
  {
    "name": "init(with:configuration:)",
    "kind": "Instance Method",
    "offset": 168669,
    "length": 209,
    "sourcetext": " init(\n        with model: PendingApplicationModel,\n        configuration: PendingApplicationScreen.Configuration\n    ) {\n        pendingApplicationModel = model\n        self.configuration = configuration\n    "
  },
  {
    "name": "prepareSubtitle()",
    "kind": "Instance Method",
    "offset": 168891,
    "length": 363,
    "sourcetext": " func prepareSubtitle() -> String {\n        let maskedPhoneNumber = mask(\n            phone: String(pendingApplicationModel.phoneNumber.trimmingCharacters(\n                in: .whitespacesAndNewlines\n            ).replacingOccurrences(of: \" \", with: \"\").dropFirst())\n        )\n\n        return String(format: configuration.strings.subtitle, maskedPhoneNumber)\n    "
  },
  {
    "name": "mask(phone:startLimit:endLimit:maskCharacter:)",
    "kind": "Instance Method",
    "offset": 169268,
    "length": 534,
    "sourcetext": " func mask(phone: String, startLimit: Int = 3, endLimit: Int = 3, maskCharacter: Character = \"*\") -> String {\n        let maskedString = String(\n            repeating: maskCharacter,\n            count: max(0, phone.count - (startLimit + endLimit))\n        )\n\n        if LocaleSelector.shared.isArabic {\n            return String(phone.suffix(endLimit)) + maskedString + String(phone.prefix(startLimit))\n        } else {\n            return String(phone.prefix(startLimit)) + maskedString + String(phone.suffix(endLimit))\n        }\n    "
  },
  {
    "name": "build(pendingApplication:)",
    "kind": "Static Method",
    "offset": 171309,
    "length": 1250,
    "sourcetext": " static func build(pendingApplication: PendingApplicationModel) -> UIViewController {\n        let configuration = PendingApplicationScreen.Configuration()\n        let viewModel = PendingApplicationScreenViewModel(\n            with: pendingApplication,\n            configuration: configuration\n        )\n        let viewController = PendingApplicationViewController(\n            viewModel: viewModel,\n            configuration: configuration\n        )\n\n        viewController.title = pendingApplication.title\n        let sheetPresentationController = viewController.sheetPresentationController\n        if #available(iOS 16.0, *) {\n            sheetPresentationController?.detents = [.custom(resolver: { $0.maximumDetentValue * 0.8 })]\n        } else {\n            sheetPresentationController?.detents = [.medium()]\n        }\n        sheetPresentationController?.prefersScrollingExpandsWhenScrolledToEdge = false\n        sheetPresentationController?.prefersEdgeAttachedInCompactHeight = true\n        sheetPresentationController?.widthFollowsPreferredContentSizeWhenEdgeAttached = true\n        sheetPresentationController?.prefersGrabberVisible = true\n        sheetPresentationController?.preferredCornerRadius = 24.0\n\n        return viewController\n    "
  },
  {
    "name": "init(phoneNumber:referenceCode:title:)",
    "kind": "Instance Method",
    "offset": 178156,
    "length": 226,
    "sourcetext": " init(phoneNumber: String, \n                referenceCode: String?,\n                title: String? = nil\n    ) {\n        self.phoneNumber = phoneNumber\n        self.referenceCode = referenceCode\n        self.title = title\n    "
  },
  {
    "name": "init(viewModel:configuration:)",
    "kind": "Instance Method",
    "offset": 180694,
    "length": 259,
    "sourcetext": " init(\n        viewModel: PendingApplicationScreenViewModel,\n        configuration: PendingApplicationScreen.Configuration\n    ) {\n        self.viewModel = viewModel\n        self.configuration = configuration\n        super.init(nibName: nil, bundle: nil)\n    "
  },
  {
    "name": "init(coder:)",
    "kind": "Instance Method",
    "offset": 180968,
    "length": 89,
    "sourcetext": " init?(coder: NSCoder) {\n        fatalError(\"init(coder:) has not been implemented\")\n    "
  },
  {
    "name": "loadView()",
    "kind": "Instance Method",
    "offset": 181079,
    "length": 88,
    "sourcetext": " func loadView() {\n        super.loadView()\n        addSubviews()\n        setupUI()\n    "
  },
  {
    "name": "addSubviews()",
    "kind": "Instance Method",
    "offset": 181181,
    "length": 452,
    "sourcetext": " func addSubviews() {\n        view.addSubview(iconImageView)\n        view.addSubview(titleLabel)\n        view.addSubview(subtitleLabel)\n        view.addSubview(applicationDetailsLabel)\n\n        view.addSubview(referenceNumberContainerView)\n        referenceNumberContainerView.addSubview(referenceNumberTitleLabel)\n        referenceNumberContainerView.addSubview(referenceNumberLabel)\n        referenceNumberContainerView.addSubview(copyImageView)\n    "
  },
  {
    "name": "setupUI()",
    "kind": "Instance Method",
    "offset": 181647,
    "length": 2147,
    "sourcetext": " func setupUI() {\n        let spacers = DesignSystem.shared.spacer\n        view.backgroundColor = DesignSystem.shared.colors.foundation.default\n\n        iconImageView.snp.makeConstraints {\n            $0.top.equalTo(configuration.constants.pendingIconTopPadding)\n            $0.centerX.equalToSuperview()\n            $0.width.equalTo(configuration.constants.pendingIconWidth)\n            $0.height.equalTo(configuration.constants.pendingIconHeight)\n        }\n\n        titleLabel.snp.makeConstraints {\n            $0.top.equalTo(iconImageView.snp.bottom).offset(spacers.lg)\n            $0.leading.trailing.equalToSuperview().inset(spacers.md)\n        }\n\n        subtitleLabel.snp.makeConstraints {\n            $0.top.equalTo(titleLabel.snp.bottom).offset(spacers.md)\n            $0.leading.trailing.equalToSuperview().inset(spacers.md)\n        }\n\n        if viewModel.isReferenceNumberAvailable {\n            applicationDetailsLabel.snp.makeConstraints {\n                $0.top.equalTo(subtitleLabel.snp.bottom).offset(spacers.lg - spacers.sm)\n                $0.leading.equalToSuperview().inset(spacers.md)\n            }\n\n            referenceNumberContainerView.snp.makeConstraints {\n                $0.top.equalTo(applicationDetailsLabel.snp.bottom).offset(spacers.sm)\n                $0.leading.trailing.equalToSuperview().inset(spacers.md)\n                $0.height.equalTo(configuration.constants.referenceNumberContainerHeight)\n            }\n\n            referenceNumberTitleLabel.snp.makeConstraints {\n                $0.top.leading.equalToSuperview().inset(spacers.md)\n            }\n\n            referenceNumberLabel.snp.makeConstraints {\n                $0.top.equalTo(referenceNumberTitleLabel.snp.bottom).offset(spacers.sm)\n                $0.leading.equalToSuperview().inset(spacers.md)\n            }\n\n            copyImageView.snp.makeConstraints {\n                $0.centerY.equalToSuperview()\n                $0.trailing.equalToSuperview().inset(spacers.md)\n                $0.width.equalTo(configuration.constants.copyIconWidth)\n                $0.height.equalTo(configuration.constants.copyIconHeight)\n            }\n        }\n    "
  },
  {
    "name": "copyButtonTapped(_:)",
    "kind": "Instance Method",
    "offset": 183818,
    "length": 204,
    "sourcetext": " func copyButtonTapped(_ sender: Button) {\n        UIPasteboard.general.string = viewModel.pendingApplicationModel.referenceCode\n        view.displayToast(configuration.strings.copytoCliped, with: 1)\n    "
  },
  {
    "name": "init(style:)",
    "kind": "Instance Method",
    "offset": 185870,
    "length": 116,
    "sourcetext": " init(style: Style = .large) {\n        super.init(frame: .zero)\n        self.style = style\n        setUpViews()\n    "
  },
  {
    "name": "init(frame:)",
    "kind": "Instance Method",
    "offset": 186001,
    "length": 81,
    "sourcetext": " init(frame: CGRect) {\n        super.init(frame: frame)\n        setUpViews()\n    "
  },
  {
    "name": "init(coder:)",
    "kind": "Instance Method",
    "offset": 186106,
    "length": 83,
    "sourcetext": " init?(coder: NSCoder) {\n        super.init(coder: coder)\n        setUpViews()\n    "
  },
  {
    "name": "setUpViews()",
    "kind": "Instance Method",
    "offset": 186227,
    "length": 827,
    "sourcetext": " func setUpViews() {\n        label.removeFromSuperview()\n\n        // Check if Height & Width constaints needs to be added or disabled\n        if heightConstraint == nil {\n            heightConstraint = heightAnchor.constraint(equalToConstant: badgeSize)\n        } else { heightConstraint?.isActive = false }\n\n        if widthConstraint == nil {\n            widthConstraint = widthAnchor.constraint(equalToConstant: badgeSize)\n        } else { widthConstraint?.isActive = false }\n\n        switch style {\n        case .large: setUpLargeBadgeViews()\n        case .small: setUpSmallBadgeViews()\n        case .custom: setUpLargeBadgeViews()\n        }\n\n        isUserInteractionEnabled = false\n        backgroundColor = DesignSystem.shared.colors.danger.default\n        layer.cornerRadius = badgeSize / 2\n\n        refreshViews()\n    "
  },
  {
    "name": "setUpLargeBadgeViews()",
    "kind": "Instance Method",
    "offset": 187068,
    "length": 563,
    "sourcetext": " func setUpLargeBadgeViews() {\n        addSubview(label)\n        label.translatesAutoresizingMaskIntoConstraints = false\n        label.isUserInteractionEnabled = false\n\n        heightConstraint?.constant = badgeSize\n        heightConstraint?.isActive = true\n        widthConstraint?.constant = badgeSize\n        widthConstraint?.isActive = true\n\n        label.snp.makeConstraints { make in\n            make.center.equalToSuperview()\n        }\n\n        label.textColor = .white\n        label.font = DesignSystem.shared.fonts.preferredFont(.caption2, .regular)\n    "
  },
  {
    "name": "setUpSmallBadgeViews()",
    "kind": "Instance Method",
    "offset": 187645,
    "length": 168,
    "sourcetext": " func setUpSmallBadgeViews() {\n        [widthConstraint, heightConstraint].forEach {\n            $0?.constant = badgeSize\n            $0?.isActive = true\n        }\n    "
  },
  {
    "name": "pinToSuperviewTopRight()",
    "kind": "Instance Method",
    "offset": 187826,
    "length": 477,
    "sourcetext": " func pinToSuperviewTopRight() {\n        guard let superview = superview, leadingConstraint == nil else { return }\n\n        let leadingConstraint = leadingAnchor.constraint(equalTo: superview.trailingAnchor, constant: leadingConstraintConstant)\n        self.leadingConstraint = leadingConstraint\n\n        NSLayoutConstraint.activate([\n            topAnchor.constraint(equalTo: superview.topAnchor, constant: topConstraintConstant),\n            leadingConstraint\n        ])\n    "
  },
  {
    "name": "refreshViews()",
    "kind": "Instance Method",
    "offset": 188317,
    "length": 222,
    "sourcetext": " func refreshViews() {\n        let isHidden = count <= 0\n        label.text = hasMaxBeenReached ? \"\\(max)+\" : \"\\(count)\"\n        leadingConstraint?.constant = leadingConstraintConstant\n        self.isHidden = isHidden\n    "
  },
  {
    "name": "init(value:)",
    "kind": "Instance Method",
    "offset": 188776,
    "length": 61,
    "sourcetext": " init(value: Binding<Int>) {\n        self._value = value\n    "
  },
  {
    "name": "finalValue()",
    "kind": "Instance Method",
    "offset": 189378,
    "length": 83,
    "sourcetext": " func finalValue() -> String {\n        return value < 100 ? \"\\(value)\" : \"99+\"\n    "
  },
  {
    "name": "reduce(value:nextValue:)",
    "kind": "Static Method",
    "offset": 191480,
    "length": 69,
    "sourcetext": " static func reduce(value: inout CGPoint, nextValue: () -> CGPoint) {"
  },
  {
    "name": "fixFlickering()",
    "kind": "Instance Method",
    "offset": 191594,
    "length": 718,
    "sourcetext": " func fixFlickering() -> some View {\n        GeometryReader { geometryWithSafeArea in\n            GeometryReader { _ in\n                ScrollView<AnyView>(axes, showsIndicators: showsIndicators) {\n                    AnyView(\n                        content\n                            .padding(.top, geometryWithSafeArea.safeAreaInsets.top)\n                            .padding(.bottom, geometryWithSafeArea.safeAreaInsets.bottom)\n                            .padding(.leading, geometryWithSafeArea.safeAreaInsets.leading)\n                            .padding(.trailing, geometryWithSafeArea.safeAreaInsets.trailing)\n                    )\n                }\n            }\n            .ignoresSafeArea()\n        }\n    "
  },
  {
    "name": "init(title:optionalText:placeholderText:bindableText:backgroundColor:disabled:)",
    "kind": "Instance Method",
    "offset": 192986,
    "length": 465,
    "sourcetext": " init(\n        title: String,\n        optionalText: String? = nil,\n        placeholderText: String,\n        bindableText: Binding<String>,\n        backgroundColor: Color = Color.clear,\n        disabled: Bool = false\n    ) {\n        self.title = title\n        self.optionalText = optionalText\n        self.placeholderText = placeholderText\n        self._bindableText = bindableText\n        self.backgroundColor = backgroundColor\n        self.disabled = disabled\n    "
  },
  {
    "name": "init(currentRating:highestRating:didSelectRating:)",
    "kind": "Instance Method",
    "offset": 195927,
    "length": 230,
    "sourcetext": " init(currentRating: Binding<Int>, highestRating: Int, didSelectRating: ((Int) -> Void)?) {\n        self._currentRating = currentRating\n        self.highestRating = highestRating\n        self.didSelectRating = didSelectRating\n    "
  },
  {
    "name": "image(for:)",
    "kind": "Instance Method",
    "offset": 196603,
    "length": 187,
    "sourcetext": " func image(for index: Int) -> some View {\n        let name = index > currentRating ? \"rating-star-unselected\" : \"rating-star-selected\"\n        return Image(name, bundle: .snbCommon)\n    "
  },
  {
    "name": "init(perform:)",
    "kind": "Instance Method",
    "offset": 197465,
    "length": 78,
    "sourcetext": " init(perform action: (() -> Void)? = nil) {\n        self.action = action\n    "
  },
  {
    "name": "body(content:)",
    "kind": "Instance Method",
    "offset": 197549,
    "length": 190,
    "sourcetext": " func body(content: Content) -> some View {\n        content.onAppear {\n            if didLoad == false {\n                didLoad = true\n                action?()\n            }\n        }\n    "
  },
  {
    "name": "onLoad(perform:)",
    "kind": "Instance Method",
    "offset": 197771,
    "length": 124,
    "sourcetext": " func onLoad(perform action: (() -> Void)? = nil) -> some View {\n        modifier(ViewDidLoadModifier(perform: action))\n    "
  },
  {
    "name": "init(image:title:value:accessibilityPrefix:)",
    "kind": "Instance Method",
    "offset": 198454,
    "length": 221,
    "sourcetext": " init(image: Image, title: String, value: String, accessibilityPrefix: String) {\n        self.image = image\n        self.title = title\n        self.value = value\n        self.accessibilityPrefix = accessibilityPrefix\n    "
  },
  {
    "name": "init(number:range:step:tint:disabledTint:textFont:buttonFont:)",
    "kind": "Instance Method",
    "offset": 201065,
    "length": 666,
    "sourcetext": " init(\n        number: Binding<Int>,\n        range: ClosedRange<Int> = 0...10,\n        step: Int = 1,\n        tint: Color = DesignSystem.shared.colors.secondary.default.color,\n        disabledTint: Color = DesignSystem.shared.colors.secondary.lightest.color,\n        textFont: Font = DesignSystem.shared.fonts.preferredFont(.body, .medium).font,\n        buttonFont: Font = DesignSystem.shared.fonts.preferredFont(.largeTitle, .regular).font\n    ) {\n        _number = number\n        self.range = range\n        self.step = step\n        self.textFont = textFont\n        self.buttonFont = buttonFont\n        self.tint = tint\n        self.disabledTint = disabledTint\n    "
  },
  {
    "name": "increase(by:)",
    "kind": "Instance Method",
    "offset": 202840,
    "length": 97,
    "sourcetext": " func increase(by amount: Int = 1) {\n        number = min(number + amount, range.upperBound)\n    "
  },
  {
    "name": "decrease(by:)",
    "kind": "Instance Method",
    "offset": 202943,
    "length": 97,
    "sourcetext": " func decrease(by amount: Int = 1) {\n        number = max(number - amount, range.lowerBound)\n    "
  },
  {
    "name": "build(configuration:status:resultAction:doneAction:nameText:)",
    "kind": "Static Method",
    "offset": 203604,
    "length": 880,
    "sourcetext": " static func build(\n        configuration: ResultPayment.Configuration = Resolver.resolve(),\n        status: Status,\n        resultAction: (() -> Void)?,\n        doneAction: (() -> Void)? = nil,\n        nameText: String? = nil\n    ) -> UIViewController {\n\n        let viewModel = viewModel(\n            for: status,\n            nameText: nameText,\n            configuration: configuration,\n            resultAction: resultAction,\n            doneAction: doneAction\n        )\n        let viewController = ResultPaymentViewController(configuration: configuration)\n        let wrappingNavigationController = NavigationController(rootViewController: viewController,\n                                                                style: DesignSystem.shared.styles.navigationController)\n        viewController.bind(viewModel: viewModel)\n        return wrappingNavigationController\n    "
  },
  {
    "name": "viewModel(for:nameText:configuration:resultAction:doneAction:)",
    "kind": "Static Method",
    "offset": 204498,
    "length": 1668,
    "sourcetext": " static func viewModel(\n        for status: Status,\n        nameText: String?,\n        configuration: ResultPayment.Configuration,\n        resultAction: (() -> Void)?,\n        doneAction: (() -> Void)?\n    ) -> ResultPaymentViewModel {\n\n        let viewModel: ResultPaymentViewModel\n        switch status {\n        case .success(let linkAction):\n            viewModel = .init(\n                isSuccess: true,\n                linkAction: linkAction,\n                resultAction: resultAction,\n                doneAction: doneAction,\n                image: configuration.images.success.successImage,\n                titleText: configuration.strings.success.title,\n                subtitleText: configuration.strings.success.subtitle,\n                nameText: nameText,\n                linkButtonText: configuration.strings.success.linkButton,\n                linkButtonImage: configuration.images.success.receiptImage,\n                submitButtonText: configuration.strings.success.button\n            )\n        case .failure(let linkAction):\n            viewModel = .init(\n                isSuccess: false,\n                linkAction: linkAction,\n                resultAction: resultAction,\n                doneAction: doneAction,\n                image: configuration.images.failure.failureImage,\n                titleText: configuration.strings.failure.title,\n                subtitleText: configuration.strings.failure.subtitle,\n                nameText: nameText,\n                linkButtonText: configuration.strings.failure.linkButton,\n                submitButtonText: configuration.strings.failure.button\n            )\n        }\n\n        return viewModel\n    "
  },
  {
    "name": "bind(input:)",
    "kind": "Instance Method",
    "offset": 206521,
    "length": 77,
    "sourcetext": " func bind(input: ResultPaymentViewModelInput) -> ResultPaymentViewModelOutpu"
  },
  {
    "name": "init(isSuccess:linkAction:resultAction:doneAction:image:titleText:subtitleText:nameText:linkButtonText:linkButtonImage:submitButtonText:)",
    "kind": "Instance Method",
    "offset": 207326,
    "length": 925,
    "sourcetext": " init(\n        isSuccess: Bool,\n        linkAction: ((@escaping () -> Void) -> Void)? = nil,\n        resultAction: (() -> Void)? = nil,\n        doneAction: (() -> Void)? = nil,\n        image: UIImage,\n        titleText: String,\n        subtitleText: String,\n        nameText: String? = nil,\n        linkButtonText: String? = nil,\n        linkButtonImage: UIImage? = nil,\n        submitButtonText: String\n    ) {\n        self.isSuccess = isSuccess\n        self.linkAction = linkAction\n        self.resultAction = resultAction\n        self.doneAction = doneAction\n        self.image = image\n        self.titleText = titleText\n        self.subtitleText = subtitleText\n        self.nameText = nameText\n        self.linkButtonText = linkButtonText\n        self.linkButtonImage = linkButtonImage\n        self.submitButtonText = submitButtonText\n        self.viewStateSubject = .init(.loaded(linkButtonImage: linkButtonImage))\n\n    "
  },
  {
    "name": "handleInput(_:)",
    "kind": "Instance Method",
    "offset": 208265,
    "length": 278,
    "sourcetext": " func handleInput(_ input: ResultPaymentViewModelInput) {\n        input.didTapLink\n            .sink(receiveValue: didTapLink)\n            .store(in: &subscriptions)\n        input.didTapDone\n            .sink(receiveValue: didTapDone)\n            .store(in: &subscriptions)\n    "
  },
  {
    "name": "didTapLink()",
    "kind": "Instance Method",
    "offset": 208557,
    "length": 328,
    "sourcetext": " func didTapLink() {\n        /// Success Screen -> Receipt Action\n        /// or\n        /// Failure Screen -> Done Action\n        resultAction?()\n        viewStateSubject.send(.loading)\n        linkAction? { [weak self] in\n            self?.viewStateSubject.send(.loaded(linkButtonImage: self?.linkButtonImage))\n        }\n\n    "
  },
  {
    "name": "didTapDone()",
    "kind": "Instance Method",
    "offset": 208899,
    "length": 150,
    "sourcetext": " func didTapDone() {\n        /// Success Screen -> Done Action\n        /// or\n        /// Failure Screen -> TryAgain Action\n        doneAction?()\n    "
  },
  {
    "name": "bind(input:)",
    "kind": "Instance Method",
    "offset": 209088,
    "length": 621,
    "sourcetext": " func bind(input: ResultPaymentViewModelInput) -> ResultPaymentViewModelOutput {\n        handleInput(input)\n        return ResultPaymentViewModelOutput(\n            viewState: viewStateSubject.eraseToAnyPublisher(),\n            image: Just(image).eraseToAnyPublisher(),\n            titleText: Just(titleText).eraseToAnyPublisher(),\n            subtitleText: Just(subtitleText).eraseToAnyPublisher(),\n            nameText: Just(nameText).eraseToAnyPublisher(),\n            submitButtonText: Just(submitButtonText).eraseToAnyPublisher(),\n            linkButtonText: Just(linkButtonText).eraseToAnyPublisher()\n        )\n    "
  },
  {
    "name": "init()",
    "kind": "Instance Method",
    "offset": 211723,
    "length": 9,
    "sourcetext": " init() {"
  },
  {
    "name": "init()",
    "kind": "Instance Method",
    "offset": 212143,
    "length": 9,
    "sourcetext": " init() {"
  },
  {
    "name": "init(configuration:)",
    "kind": "Instance Method",
    "offset": 217392,
    "length": 145,
    "sourcetext": " init(configuration: ResultPayment.Configuration) {\n        self.configuration = configuration\n        super.init(nibName: nil, bundle: nil)\n    "
  },
  {
    "name": "init(coder:)",
    "kind": "Instance Method",
    "offset": 217583,
    "length": 89,
    "sourcetext": " init?(coder: NSCoder) {\n        fatalError(\"init(coder:) has not been implemented\")\n    "
  },
  {
    "name": "loadView()",
    "kind": "Instance Method",
    "offset": 217724,
    "length": 127,
    "sourcetext": " func loadView() {\n        super.loadView()\n        configureLayout()\n        configureDesign()\n        addSupportButton()\n    "
  },
  {
    "name": "viewWillAppear(_:)",
    "kind": "Instance Method",
    "offset": 217873,
    "length": 121,
    "sourcetext": " func viewWillAppear(_ animated: Bool) {\n        super.viewWillAppear(animated)\n        removeLargeTitlesForNavBar()\n    "
  },
  {
    "name": "configureLayout()",
    "kind": "Instance Method",
    "offset": 218040,
    "length": 2375,
    "sourcetext": " func configureLayout() {\n        view.configureBackgroundView(type: .plain)\n\n        [imageView, titleLabel, subtitleLabel, submitButton].forEach {\n            view.addSubview($0)\n        }\n\n        imageView.snp.makeConstraints { make in\n            make.centerX.equalToSuperview()\n            make.centerY.equalToSuperview()\n                .offset(\n                    configuration.shouldShowNameLabel\n                    ? configuration.design.imageCenterOffsetWhenName\n                    : configuration.design.imageCenterOffset\n                )\n        }\n        titleLabel.snp.makeConstraints { make in\n            make.top.equalTo(imageView.snp.bottom).offset(DesignSystem.shared.spacer.lg)\n            make.leading.trailing.equalToSuperview().inset(DesignSystem.shared.spacer.md)\n            make.centerX.equalToSuperview()\n        }\n        subtitleLabel.snp.makeConstraints { make in\n            make.top.equalTo(titleLabel.snp.bottom).offset(DesignSystem.shared.spacer.md)\n            make.leading.trailing.equalToSuperview().inset(DesignSystem.shared.spacer.md)\n            make.centerX.equalToSuperview()\n        }\n\n        if configuration.shouldShowNameLabel {\n            view.addSubview(nameLabel)\n            nameLabel.snp.makeConstraints { make in\n                make.top.equalTo(subtitleLabel.snp.bottom).offset(DesignSystem.shared.spacer.md)\n                make.leading.trailing.equalToSuperview().inset(DesignSystem.shared.spacer.md)\n                make.centerX.equalToSuperview()\n                make.height.equalTo(configuration.design.labelHeight)\n            }\n        }\n        if configuration.shouldDisplayLinkButton {\n            view.addSubview(linkButton)\n            linkButton.snp.makeConstraints { make in\n                make.leading.trailing.equalToSuperview().inset(DesignSystem.shared.spacer.md)\n                make.height.equalTo(configuration.design.buttonHeight)\n                make.bottom.equalTo(submitButton.snp.top).offset(-DesignSystem.shared.spacer.md)\n            }\n        }\n\n        submitButton.snp.makeConstraints { make in\n            make.leading.trailing.equalToSuperview().inset(DesignSystem.shared.spacer.md)\n            make.height.equalTo(configuration.design.buttonHeight)\n            make.bottom.equalTo(view.safeAreaInsets)\n                .inset(configuration.design.buttonBottomOffset)\n        }\n    "
  },
  {
    "name": "addSupportButton()",
    "kind": "Instance Method",
    "offset": 220429,
    "length": 141,
    "sourcetext": " func addSupportButton() {\n        guard let isSuccess = viewModel?.isSuccess, !isSuccess else { return }\n        addSupportButtonView()\n    "
  },
  {
    "name": "linkTapped()",
    "kind": "Instance Method",
    "offset": 220590,
    "length": 64,
    "sourcetext": " func linkTapped() {\n        didTapLinkButtonSubject.send()\n    "
  },
  {
    "name": "submitTapped()",
    "kind": "Instance Method",
    "offset": 220674,
    "length": 68,
    "sourcetext": " func submitTapped() {\n        didTapSubmitButtonSubject.send()\n    "
  },
  {
    "name": "configureDesign()",
    "kind": "Instance Method",
    "offset": 220756,
    "length": 195,
    "sourcetext": " func configureDesign() {\n        configuration.design.titleLabel(titleLabel)\n        configuration.design.subtitleLabel(subtitleLabel)\n        configuration.design.nameLabelStyle(nameLabel)\n    "
  },
  {
    "name": "configure(viewModel:)",
    "kind": "Instance Method",
    "offset": 220965,
    "length": 360,
    "sourcetext": " func configure(viewModel: ResultPaymentViewModel) {\n        handleOutput(\n            viewModel.bind(\n                input: ResultPaymentViewModelInput(\n                    didTapLink: didTapLinkButtonSubject.eraseToAnyPublisher(),\n                    didTapDone: didTapSubmitButtonSubject.eraseToAnyPublisher()\n                )\n            )\n        )\n    "
  },
  {
    "name": "handleOutput(_:)",
    "kind": "Instance Method",
    "offset": 221339,
    "length": 1433,
    "sourcetext": " func handleOutput(_ output: ResultPaymentViewModelOutput) {\n        output.image\n            .sink { [weak self] in\n                self?.imageView.image = $0\n            }\n            .store(in: &subscriptions)\n\n        output.titleText\n            .sink { [weak self] in\n                self?.titleLabel.text = $0\n            }\n            .store(in: &subscriptions)\n\n        output.viewState\n            .sink { [weak self] in\n                self?.set(state: $0)\n            }\n            .store(in: &subscriptions)\n\n        output.subtitleText\n            .map(formatSubtitleText)\n            .sink { [weak self] in\n                self?.subtitleLabel.attributedText = $0\n            }\n            .store(in: &subscriptions)\n\n        output.linkButtonText\n            .map {\n                $0 == nil\n            }\n            .sink { [weak self] in\n                self?.linkButton.isHidden = $0\n            }\n            .store(in: &subscriptions)\n\n        output.linkButtonText\n            .sink { [weak self] in\n                self?.linkButton.setTitle($0, for: .init())\n            }\n            .store(in: &subscriptions)\n\n        output.submitButtonText\n            .sink { [weak self] in\n                self?.submitButton.setTitle($0, for: .init())\n            }\n            .store(in: &subscriptions)\n\n        output.nameText\n            .assign(to: \\.text, on: nameLabel)\n            .store(in: &subscriptions)\n    "
  },
  {
    "name": "formatSubtitleText(_:)",
    "kind": "Instance Method",
    "offset": 222786,
    "length": 362,
    "sourcetext": " func formatSubtitleText(_ subtitleText: String) -> NSAttributedString {\n        let paragraphStyle = NSMutableParagraphStyle()\n        paragraphStyle.lineHeightMultiple = 1.19\n        paragraphStyle.alignment = .center\n\n        return NSAttributedString(\n            string: subtitleText,\n            attributes: [.paragraphStyle: paragraphStyle]\n        )\n    "
  },
  {
    "name": "bind(viewModel:)",
    "kind": "Instance Method",
    "offset": 223187,
    "length": 127,
    "sourcetext": " func bind(viewModel: ResultPaymentViewModel) {\n        self.viewModel = viewModel\n        configure(viewModel: viewModel)\n    "
  },
  {
    "name": "set(state:)",
    "kind": "Instance Method",
    "offset": 223370,
    "length": 202,
    "sourcetext": " func set(state: ResultPaymentViewState) {\n        switch state {\n        case .loading: setLoadingState()\n        case .loaded(let linkButtonImage): setLoadedState(with: linkButtonImage)\n        }\n    "
  },
  {
    "name": "setLoadingState()",
    "kind": "Instance Method",
    "offset": 223578,
    "length": 111,
    "sourcetext": " func setLoadingState() {\n        linkButton.startLoading()\n        linkButton.setImage(nil, for: .normal)\n    "
  },
  {
    "name": "setLoadedState(with:)",
    "kind": "Instance Method",
    "offset": 223695,
    "length": 151,
    "sourcetext": " func setLoadedState(with linkButtonImage: UIImage?) {\n        linkButton.stopLoading()\n        linkButton.setImage(linkButtonImage, for: .normal)\n    "
  },
  {
    "name": "init()",
    "kind": "Instance Method",
    "offset": 225754,
    "length": 9,
    "sourcetext": " init() {"
  },
  {
    "name": "init()",
    "kind": "Instance Method",
    "offset": 226308,
    "length": 9,
    "sourcetext": " init() {"
  },
  {
    "name": "init()",
    "kind": "Instance Method",
    "offset": 226831,
    "length": 10,
    "sourcetext": " init() { "
  },
  {
    "name": "init(configuration:)",
    "kind": "Instance Method",
    "offset": 227670,
    "length": 258,
    "sourcetext": " init(configuration: ReceiptError.Configuration) {\n        self.configuration = configuration\n        super.init(nibName: nil, bundle: nil)\n        imageView.image = configuration.images.failureImage\n        titleLabel.text = configuration.strings.title\n    "
  },
  {
    "name": "init(coder:)",
    "kind": "Instance Method",
    "offset": 227974,
    "length": 89,
    "sourcetext": " init?(coder: NSCoder) {\n        fatalError(\"init(coder:) has not been implemented\")\n    "
  },
  {
    "name": "loadView()",
    "kind": "Instance Method",
    "offset": 228108,
    "length": 122,
    "sourcetext": " func loadView() {\n        super.loadView()\n        setupNavBar()\n        configureLayout()\n        configureDesign()\n    "
  },
  {
    "name": "setupNavBar()",
    "kind": "Instance Method",
    "offset": 228276,
    "length": 85,
    "sourcetext": " func setupNavBar() {\n        navigationController?.isNavigationBarHidden = true\n    "
  },
  {
    "name": "configureLayout()",
    "kind": "Instance Method",
    "offset": 228375,
    "length": 783,
    "sourcetext": " func configureLayout() {\n        [imageView, titleLabel, subtitleLabel].forEach(view.addSubview)\n\n        imageView.snp.makeConstraints { make in\n            make.centerX.equalToSuperview()\n            make.top.equalToSuperview()\n                .offset(configuration.design.imageOffset)\n        }\n        titleLabel.snp.makeConstraints { make in\n            make.top.equalTo(imageView.snp.bottom).offset(DesignSystem.shared.spacer.lg)\n            make.leading.trailing.equalToSuperview().inset(DesignSystem.shared.spacer.md)\n        }\n        subtitleLabel.snp.makeConstraints { make in\n            make.top.equalTo(titleLabel.snp.bottom).offset(DesignSystem.shared.spacer.md)\n            make.leading.trailing.equalToSuperview().inset(DesignSystem.shared.spacer.md)\n        }\n    "
  },
  {
    "name": "configureDesign()",
    "kind": "Instance Method",
    "offset": 229172,
    "length": 606,
    "sourcetext": " func configureDesign() {\n        view.backgroundColor = DesignSystem.shared.colors.neutrals.neutral00\n        configuration.design.sheetPresentationController(self)\n        configuration.design.titleLabel(titleLabel)\n        configuration.design.subtitleLabel(subtitleLabel)\n        let paragraphStyle = NSMutableParagraphStyle()\n        paragraphStyle.lineHeightMultiple = 1.19\n        paragraphStyle.alignment = .center\n        subtitleLabel.attributedText = NSAttributedString(\n            string: configuration.strings.subtitle,\n            attributes: [.paragraphStyle: paragraphStyle]\n        )\n    "
  },
  {
    "name": "init()",
    "kind": "Instance Method",
    "offset": 230319,
    "length": 10,
    "sourcetext": " init() { "
  },
  {
    "name": "build(configuration:)",
    "kind": "Static Method",
    "offset": 230701,
    "length": 195,
    "sourcetext": " static func build(\n        configuration: ReceiptError.Configuration = Resolver.resolve()\n    ) -> UIViewController {\n        return ReceiptErrorViewController(configuration: configuration)\n    "
  },
  {
    "name": "build(navigationController:configuration:router:accountId:validationType:completion:)",
    "kind": "Static Method",
    "offset": 232991,
    "length": 749,
    "sourcetext": " static func build(\n        navigationController: UINavigationController,\n        configuration: SaveNickname.Configuration = Resolver.resolve(),\n        router: TransferRouterMarker,\n        accountId: String,\n        validationType: ValidationType,\n        completion: @escaping (String?) -> Void\n    ) -> UIViewController {\n        let viewModel = SaveNicknameViewModel(configuration: configuration,\n                                              router: router,\n                                              accountId: accountId,\n                                              validationType: validationType,\n                                              completion: completion)\n        return SaveNicknameViewController(viewModel: viewModel)\n    "
  },
  {
    "name": "init()",
    "kind": "Instance Method",
    "offset": 234234,
    "length": 9,
    "sourcetext": " init() {"
  },
  {
    "name": "showError(_:)",
    "kind": "Instance Method",
    "offset": 237173,
    "length": 63,
    "sourcetext": " func showError(_ type: GenericErrorScreen.Configuration.Option"
  },
  {
    "name": "init()",
    "kind": "Instance Method",
    "offset": 238075,
    "length": 9,
    "sourcetext": " init() {"
  },
  {
    "name": "init(configuration:router:accountId:validationType:completion:)",
    "kind": "Instance Method",
    "offset": 239174,
    "length": 412,
    "sourcetext": " init(\n        configuration: SaveNickname.Configuration,\n        router: TransferRouterMarker,\n        accountId: String,\n        validationType: ValidationType,\n        completion: @escaping (String?) -> Void\n    ) {\n        self.configuration = configuration\n        self.router = router\n        self.accountId = accountId\n        self.validationType = validationType\n        self.completion = completion\n    "
  },
  {
    "name": "bind()",
    "kind": "Instance Method",
    "offset": 239592,
    "length": 59,
    "sourcetext": " func bind() {\n        viewState.eraseToAnyPublisher()\n    "
  },
  {
    "name": "handle(error:)",
    "kind": "Instance Method",
    "offset": 239665,
    "length": 431,
    "sourcetext": " func handle(error: AccountIDValidationResponse.Error) {\n        switch error {\n        case .ambiguousAccountsFound, .invalidPhone, .invalid, .notNEO, .ownAccount:\n            break\n        case .registered:\n            viewState.send(\n                .error(error: .alreadyRegisteredAlert(nil))\n            )\n        case .unknown:\n            viewState.send(\n                .error(error: .edgeCase)\n            )\n        }\n    "
  },
  {
    "name": "validateNickname(nickName:)",
    "kind": "Instance Method",
    "offset": 240138,
    "length": 1176,
    "sourcetext": " func validateNickname(nickName: String) {\n        let accountID  = AccountID.iban(value: self.accountId)\n        let request = AccountIDValidationRequest(\n            accountID: accountID,\n            alias: nickName,\n            validationType: self.validationType\n        )\n        Task {\n            await MainActor.run { [weak self] in\n                self?.viewState.send(.loading)\n            }\n            do {\n                let response = try await useCase.validateAccountID(\n                    request: request\n                )\n                await MainActor.run { [weak self] in\n                    guard let self else { return }\n                    self.viewState.send(.success)\n                    completion(nickName)\n                }\n            } catch let error as AccountIDValidationResponse.Error {\n                await MainActor.run { [weak self] in\n                    self?.handle(error: error)\n                }\n            } catch {\n                await MainActor.run { [weak self] in\n                    self?.viewState.send(\n                        .error(error: .edgeCase)\n                    )\n                }\n            }\n        }\n    "
  },
  {
    "name": "showErrorScreen()",
    "kind": "Instance Method",
    "offset": 241320,
    "length": 81,
    "sourcetext": " func showErrorScreen() {\n        self.router.showError(.somethingWentWrong)\n    "
  },
  {
    "name": "didDismissViewController()",
    "kind": "Instance Method",
    "offset": 241407,
    "length": 63,
    "sourcetext": " func didDismissViewController() {\n        completion(nil)\n    "
  },
  {
    "name": "isLengthAllowed(_:)",
    "kind": "Instance Method",
    "offset": 241513,
    "length": 101,
    "sourcetext": " func isLengthAllowed(_ text: String) -> Bool {\n        return text.count <= constants.maxLength\n    "
  },
  {
    "name": "isNicknameValid(enteredString:completeString:)",
    "kind": "Instance Method",
    "offset": 241756,
    "length": 139,
    "sourcetext": " func isNicknameValid(enteredString: String, completeString: String) -> Bool {\n        return !containsSpecialCharacter(enteredString)\n    "
  },
  {
    "name": "containsSpecialCharacter(_:)",
    "kind": "Instance Method",
    "offset": 241909,
    "length": 236,
    "sourcetext": " func containsSpecialCharacter(_ string: String) -> Bool {\n        let regex = \".*[^A-Za-z0-9,. \\\\p{Arabic}].*\"\n        let testString = NSPredicate(format: \"SELF MATCHES %@\", regex)\n        return testString.evaluate(with: string)\n    "
  },
  {
    "name": "init(viewModel:)",
    "kind": "Instance Method",
    "offset": 244052,
    "length": 127,
    "sourcetext": " init(viewModel: SaveNicknameViewModel) {\n        self.viewModel = viewModel\n        super.init(nibName: nil, bundle: nil)\n    "
  },
  {
    "name": "init(coder:)",
    "kind": "Instance Method",
    "offset": 244194,
    "length": 89,
    "sourcetext": " init?(coder: NSCoder) {\n        fatalError(\"init(coder:) has not been implemented\")\n    "
  },
  {
    "name": "loadView()",
    "kind": "Instance Method",
    "offset": 244298,
    "length": 133,
    "sourcetext": " func loadView() {\n        super.loadView()\n        title = nil\n        self.view.backgroundColor = .white\n        prepareView()\n    "
  },
  {
    "name": "viewDidLoad()",
    "kind": "Instance Method",
    "offset": 244446,
    "length": 207,
    "sourcetext": " func viewDidLoad() {\n        super.viewDidLoad()\n        bind()\n        presentationController?.delegate = self\n        nickNameTextInput.textField.delegate = self\n        updateIsTextEntered(text: \"\")\n    "
  },
  {
    "name": "prepareView()",
    "kind": "Instance Method",
    "offset": 244667,
    "length": 295,
    "sourcetext": " func prepareView() {\n        self.view.addSubview(titleLabel)\n        self.view.addSubview(nickNameTextInput)\n        self.view.addSubview(saveButton)\n        configuration.design.textInput(nickNameTextInput)\n        configuration.design.titleLabelStyle(titleLabel)\n        addContraints()\n    "
  },
  {
    "name": "addContraints()",
    "kind": "Instance Method",
    "offset": 244976,
    "length": 895,
    "sourcetext": " func addContraints() {\n        titleLabel.snp.makeConstraints { make in\n            make.leading.trailing.equalToSuperview().inset(constants.padding)\n            make.top.equalToSuperview().inset(constants.titleLableTopOffset)\n            make.height.equalTo(constants.titleLabelHeight)\n        }\n        nickNameTextInput.snp.makeConstraints { make in\n            make.leading.trailing.equalToSuperview().inset(constants.padding)\n            make.top.equalTo(titleLabel.snp.bottom).offset(constants.nickNameInputTopOffset)\n            make.height.equalTo(constants.nickNameInputHeight)\n        }\n        saveButton.snp.makeConstraints { make in\n            make.leading.trailing.equalToSuperview().inset(constants.padding)\n            make.height.equalTo(constants.saveButtonHeight)\n            make.bottom.equalTo(view.safeAreaLayoutGuide.snp.bottom).offset(-constants.padding)\n        }\n    "
  },
  {
    "name": "bind()",
    "kind": "Instance Method",
    "offset": 245885,
    "length": 865,
    "sourcetext": " func bind() {\n        viewModel.bind()\n        saveButton.publisher(for: .touchUpInside)\n            .sink { [weak self] _ in\n                guard let self else { return }\n                self.validateNickname()\n            }\n            .store(in: &cancellables)\n\n        viewModel.viewState.sink { [weak self] in\n            switch $0 {\n            case .success:\n                self?.saveButton.isUserInteractionEnabled = true\n                self?.saveButton.stopLoading()\n            case .error(let error):\n                self?.saveButton.isUserInteractionEnabled = true\n                self?.saveButton.stopLoading()\n                self?.handle(error: error)\n            case .loading:\n                self?.saveButton.isUserInteractionEnabled = false\n                self?.saveButton.startLoading()\n            }\n        }.store(in: &cancellables)\n    "
  },
  {
    "name": "updateIsTextEntered(text:)",
    "kind": "Instance Method",
    "offset": 246764,
    "length": 159,
    "sourcetext": " func updateIsTextEntered(text: String) {\n        let trimmedText = text.trimmingCharacters(in: .whitespaces)\n        isTextEntered = !trimmedText.isEmpty\n    "
  },
  {
    "name": "validateNickname()",
    "kind": "Instance Method",
    "offset": 246937,
    "length": 249,
    "sourcetext": " func validateNickname() {\n        let nickName = self.nickNameTextInput.textField.text ?? \"\"\n        let trimmedNickNameText = nickName.trimmingCharacters(in: .whitespaces)\n        self.viewModel.validateNickname(nickName: trimmedNickNameText)\n    "
  },
  {
    "name": "handle(error:)",
    "kind": "Instance Method",
    "offset": 247200,
    "length": 434,
    "sourcetext": " func handle(error: SaveNickname.TransferCaptureError) {\n        switch error {\n        case .edgeCase:\n            self.dismiss(animated: true)\n            self.viewModel.showErrorScreen()\n        case .invalidInput:\n            break\n        case .alreadyRegisteredAlert:\n            saveButton.isEnabled = false\n            nickNameTextInput.setError(errorMessage: configuration.strings.saveNickname.userExistsError)\n        }\n    "
  },
  {
    "name": "textField(_:shouldChangeCharactersIn:replacementString:)",
    "kind": "Instance Method",
    "offset": 247703,
    "length": 658,
    "sourcetext": " func textField(_ textField: UITextField, shouldChangeCharactersIn range: NSRange, replacementString string: String) -> Bool {\n        nickNameTextInput.setError(errorMessage: \"\")\n        let currentString = textField.text ?? \"\"\n        guard let stringRange = Range(range, in: currentString) else { return false }\n        let newString = currentString.replacingCharacters(in: stringRange, with: string)\n        guard viewModel.isLengthAllowed(newString) else { return false }\n        guard viewModel.isNicknameValid(enteredString: string, completeString: newString) else { return false }\n        updateIsTextEntered(text: newString)\n        return true\n    "
  },
  {
    "name": "textFieldShouldReturn(_:)",
    "kind": "Instance Method",
    "offset": 248367,
    "length": 129,
    "sourcetext": " func textFieldShouldReturn(_ textField: UITextField) -> Bool {\n        textField.resignFirstResponder()\n        return true\n    "
  },
  {
    "name": "presentationControllerDidDismiss(_:)",
    "kind": "Instance Method",
    "offset": 248582,
    "length": 142,
    "sourcetext": " func presentationControllerDidDismiss(_ presentationController: UIPresentationController) {\n        viewModel.didDismissViewController()\n    "
  },
  {
    "name": "init()",
    "kind": "Instance Method",
    "offset": 249378,
    "length": 9,
    "sourcetext": " init() {"
  },
  {
    "name": "validateAccountID(request:)",
    "kind": "Instance Method",
    "offset": 249863,
    "length": 103,
    "sourcetext": " func validateAccountID(request: AccountIDValidationRequest) async throws -> AccountIDValidationRespons"
  },
  {
    "name": "init()",
    "kind": "Instance Method",
    "offset": 250126,
    "length": 107,
    "sourcetext": " init() {\n        self.accountValidateClient = SNBCommon.AccountIDValidationClientFactory.makeClient()\n    "
  },
  {
    "name": "validateAccountID(request:)",
    "kind": "Instance Method",
    "offset": 250246,
    "length": 195,
    "sourcetext": " func validateAccountID(request: AccountIDValidationRequest) async throws -> AccountIDValidationResponse {\n        try await accountValidateClient.validateAccountID(request.toDTO).toResponse\n    "
  },
  {
    "name": "init(type:didTap:)",
    "kind": "Instance Method",
    "offset": 251157,
    "length": 660,
    "sourcetext": " init(type: BarButtonType = .back, didTap: @escaping () -> Void) {\n        self.didTap = didTap\n        super.init()\n        switch type {\n        case .back:\n            image = configuration.images.arrowBack\n        case .close:\n            image = configuration.images.crossIcon\n        case .settings:\n            image = configuration.images.settingsIcon\n        case .logout:\n            image = configuration.images.logout\n        case .preferable(let _image):\n            image = _image\n        }\n        tintColor = DesignSystem.shared.colors.primary.onDefault\n        style = .plain\n        target = self\n        action = #selector(buttonTapped)\n    "
  },
  {
    "name": "buttonTapped()",
    "kind": "Instance Method",
    "offset": 251837,
    "length": 44,
    "sourcetext": " func buttonTapped() {\n        didTap()\n    "
  },
  {
    "name": "init(coder:)",
    "kind": "Instance Method",
    "offset": 252320,
    "length": 89,
    "sourcetext": " init?(coder: NSCoder) {\n        fatalError(\"init(coder:) has not been implemented\")\n    "
  },
  {
    "name": "init(configuration:)",
    "kind": "Instance Method",
    "offset": 252938,
    "length": 108,
    "sourcetext": " init(configuration: GenericFullScreenError.Configuration) {\n        self.configuration = configuration\n    "
  },
  {
    "name": "controllerDismissed()",
    "kind": "Instance Method",
    "offset": 253052,
    "length": 76,
    "sourcetext": " func controllerDismissed() {\n        configuration.router.didDismiss()\n    "
  },
  {
    "name": "primaryActionSubmit()",
    "kind": "Instance Method",
    "offset": 253134,
    "length": 94,
    "sourcetext": " func primaryActionSubmit() {\n        configuration.router.didSelectPrimaryActionButton()\n    "
  },
  {
    "name": "secondaryActionSubmit()",
    "kind": "Instance Method",
    "offset": 253234,
    "length": 98,
    "sourcetext": " func secondaryActionSubmit() {\n        configuration.router.didSelectSecondaryActionButton()\n    "
  },
  {
    "name": "init(viewModel:)",
    "kind": "Instance Method",
    "offset": 253916,
    "length": 91,
    "sourcetext": " init(viewModel: GenericFullScreenErrorViewModel) {\n        self.viewModel = viewModel\n    "
  },
  {
    "name": "build(with:)",
    "kind": "Static Method",
    "offset": 258954,
    "length": 284,
    "sourcetext": " static func build(with configuration: GenericFullScreenError.Configuration) -> UIViewController {\n        let viewModel = GenericFullScreenErrorViewModel(configuration: configuration)\n        return UIHostingController(rootView: GenericFullScreenErrorView(viewModel: viewModel))\n    "
  },
  {
    "name": "init()",
    "kind": "Instance Method",
    "offset": 260125,
    "length": 9,
    "sourcetext": " init() {"
  },
  {
    "name": "make(for:)",
    "kind": "Static Method",
    "offset": 260151,
    "length": 614,
    "sourcetext": " static func make(for type: ErrorType) -> Configuration {\n            var config = Configuration()\n            config.actionButtonDisplayMode = type.actionButtonDisplayMode\n            config.strings.title = type.title\n            config.strings.body = type.body\n            config.strings.primaryActionButtonTitle = type.primaryButtonTitle\n            config.strings.secondaryActionButtonTitle = type.secondryButtonTitle\n            config.images.errorIcon = type.errorIcon\n            config.images.headerImage = type.headerImage\n            config.shouldShowCloseButton = true\n            return config\n        "
  },
  {
    "name": "init()",
    "kind": "Instance Method",
    "offset": 263856,
    "length": 9,
    "sourcetext": " init() {"
  },
  {
    "name": "init(isSelected:style:)",
    "kind": "Instance Method",
    "offset": 264766,
    "length": 129,
    "sourcetext": " init(isSelected: Binding<Bool>, style: Style = .rounded) {\n        self._isSelected = isSelected\n        self.style = style\n    "
  },
  {
    "name": "init()",
    "kind": "Instance Method",
    "offset": 267245,
    "length": 9,
    "sourcetext": " init() {"
  },
  {
    "name": "init()",
    "kind": "Instance Method",
    "offset": 269740,
    "length": 10,
    "sourcetext": " init() { "
  },
  {
    "name": "build(configuration:)",
    "kind": "Static Method",
    "offset": 270230,
    "length": 986,
    "sourcetext": " static func build(configuration: Configuration) -> UIViewController {\n        let viewModel = GenericErrorScreenViewModel(configuration: configuration)\n        let viewController = GenericErrorScreenViewController(viewModel: viewModel, configuration: configuration)\n        viewModel.viewController = viewController\n        viewController.isModalInPresentation = !configuration.isDismissByDragginEnabled\n\n        let sheetPresentationController = viewController.sheetPresentationController\n        sheetPresentationController?.detents = configuration.detents\n        sheetPresentationController?.prefersScrollingExpandsWhenScrolledToEdge = false\n        sheetPresentationController?.prefersEdgeAttachedInCompactHeight = true\n        sheetPresentationController?.widthFollowsPreferredContentSizeWhenEdgeAttached = true\n        sheetPresentationController?.prefersGrabberVisible = true\n        sheetPresentationController?.preferredCornerRadius = 24.0\n\n        return viewController\n    "
  },
  {
    "name": "init()",
    "kind": "Instance Method",
    "offset": 271980,
    "length": 10,
    "sourcetext": " init() { "
  },
  {
    "name": "init(configuration:)",
    "kind": "Instance Method",
    "offset": 272681,
    "length": 104,
    "sourcetext": " init(configuration: GenericErrorScreen.Configuration) {\n        self.configuration = configuration\n    "
  },
  {
    "name": "controllerDismissed()",
    "kind": "Instance Method",
    "offset": 272791,
    "length": 125,
    "sourcetext": " func controllerDismissed() {\n        guard let viewController else { return }\n        configuration.router.didDismiss()\n    "
  },
  {
    "name": "primaryActionSubmit(_:)",
    "kind": "Instance Method",
    "offset": 272922,
    "length": 212,
    "sourcetext": " func primaryActionSubmit(_ button: Button) {\n        isButtonClicked = true\n        guard let viewController else { return }\n        configuration.router.didSelectPrimaryActionButton(viewController)(button)\n    "
  },
  {
    "name": "secondaryActionSubmit(_:)",
    "kind": "Instance Method",
    "offset": 273140,
    "length": 185,
    "sourcetext": " func secondaryActionSubmit(_ button: Button) {\n        guard let viewController else { return }\n        configuration.router.didSelectSecondaryActionButton(viewController)(button)\n    "
  },
  {
    "name": "init()",
    "kind": "Instance Method",
    "offset": 273959,
    "length": 9,
    "sourcetext": " init() {"
  },
  {
    "name": "presentableContext(_:)",
    "kind": "Instance Method",
    "offset": 274000,
    "length": 212,
    "sourcetext": " func presentableContext<Context: PresentableContext>(_ context: Context) -> some View {\n        onAppear { context.isContextAvailable = true }\n            .onDisappear { context.isContextAvailable = false }\n    "
  },
  {
    "name": "init()",
    "kind": "Instance Method",
    "offset": 275364,
    "length": 10,
    "sourcetext": " init() { "
  },
  {
    "name": "make(for:)",
    "kind": "Static Method",
    "offset": 275391,
    "length": 618,
    "sourcetext": " static func make(for option: Option) -> Configuration {\n            var configuration = Resolver.resolve(Configuration.self)\n            configuration.strings.title = option.title.value\n            configuration.strings.body = option.body.value\n            configuration.designs.icon = option.icon\n            configuration.actionButtonDisplayMode = option.actionButtonDisplayMode\n            configuration.strings.primaryActionButtonTitle = option.actionButtonTitle.value\n            configuration.strings.secondaryActionButtonTitle = option.secondaryActionButtonTitle.value\n            return configuration\n        "
  },
  {
    "name": "init()",
    "kind": "Instance Method",
    "offset": 286271,
    "length": 10,
    "sourcetext": " init() { "
  },
  {
    "name": "init(viewModel:configuration:)",
    "kind": "Instance Method",
    "offset": 288632,
    "length": 225,
    "sourcetext": " init(viewModel: GenericErrorScreenViewModel, configuration: GenericErrorScreen.Configuration) {\n        self.viewModel = viewModel\n        self.configuration = configuration\n        super.init(nibName: nil, bundle: nil)\n    "
  },
  {
    "name": "init(coder:)",
    "kind": "Instance Method",
    "offset": 288903,
    "length": 89,
    "sourcetext": " init?(coder: NSCoder) {\n        fatalError(\"init(coder:) has not been implemented\")\n    "
  },
  {
    "name": "loadView()",
    "kind": "Instance Method",
    "offset": 289014,
    "length": 66,
    "sourcetext": " func loadView() {\n        super.loadView()\n        setupUI()\n    "
  },
  {
    "name": "viewDidDisappear(_:)",
    "kind": "Instance Method",
    "offset": 289102,
    "length": 182,
    "sourcetext": " func viewDidDisappear(_ animated: Bool) {\n        super.viewDidDisappear(animated)\n        if !viewModel.isButtonClicked {\n            viewModel.controllerDismissed()\n        }\n    "
  },
  {
    "name": "setupUI()",
    "kind": "Instance Method",
    "offset": 289298,
    "length": 2517,
    "sourcetext": " func setupUI() {\n        view.backgroundColor = DesignSystem.shared.colors.foundation.default\n\n        let iconView = UIView()\n        iconView.addSubview(iconImageView)\n        iconImageView.snp.makeConstraints {\n            $0.top.bottom.equalToSuperview()\n            $0.centerX.equalToSuperview()\n        }\n\n        let mainStack = UIStackView(axis: .vertical)\n        mainStack.addArrangedSubview(SpacerView(heightMode: .flexibleBetween(16...46)))\n\n        if configuration.designs.icon != nil {\n            mainStack.addArrangedSubview(iconView)\n            mainStack.addArrangedSubview(SpacerView(heightMode: .fixed(10)))\n        }\n\n        if configuration.strings.title != nil {\n            mainStack.addArrangedSubview(titleLabel)\n            mainStack.addArrangedSubview(SpacerView(heightMode: .fixed(12)))\n        }\n\n        if configuration.strings.body != nil {\n            mainStack.addArrangedSubview(bodyLabel)\n            mainStack.addArrangedSubview(SpacerView(heightMode: .flexibleMinimum(28)))\n        }\n\n        switch configuration.actionButtonDisplayMode {\n        case .none:\n            break\n\n        case .primaryOnly:\n            mainStack.addArrangedSubview(primaryActionButton)\n\n        case .secondaryOnly:\n            mainStack.addArrangedSubview(secondaryActionButton)\n\n        case .primaryAndSecondary:\n            mainStack.addArrangedSubview(secondaryActionButton)\n            mainStack.addArrangedSubview(primaryActionButton, spaceBefore: 16)\n\n        case .secondaryAndPrimary:\n            mainStack.addArrangedSubview(primaryActionButton)\n            mainStack.addArrangedSubview(secondaryActionButton, spaceBefore: 16)\n        }\n\n        view.addSubview(mainStack)\n\n        if configuration.isExitLabelVisible {\n            view.addSubview(exitLabel)\n            exitLabel.snp.makeConstraints {\n                $0.leading.equalToSuperview().offset(16)\n                $0.trailing.equalToSuperview().inset(16)\n                $0.bottom.equalTo(view.safeAreaLayoutGuide).inset(0)\n            }\n            mainStack.snp.makeConstraints {\n                $0.top.equalTo(view.safeAreaLayoutGuide).inset(16)\n                $0.bottom.equalTo(exitLabel.snp.top).offset(16)\n                $0.leading.trailing.equalToSuperview().inset(16)\n            }\n        } else {\n            mainStack.snp.makeConstraints {\n                $0.top.bottom.equalTo(view.safeAreaLayoutGuide).inset(16)\n                $0.leading.trailing.equalToSuperview().inset(16)\n            }\n        }\n    "
  },
  {
    "name": "primaryActionSubmit(_:)",
    "kind": "Instance Method",
    "offset": 291839,
    "length": 96,
    "sourcetext": " func primaryActionSubmit(_ sender: Button) {\n        viewModel.primaryActionSubmit(sender)\n    "
  },
  {
    "name": "secondaryActionSubmit(_:)",
    "kind": "Instance Method",
    "offset": 291959,
    "length": 100,
    "sourcetext": " func secondaryActionSubmit(_ sender: Button) {\n        viewModel.secondaryActionSubmit(sender)\n    "
  },
  {
    "name": "presentErrorSheet(on:context:error:callback:)",
    "kind": "Instance Method",
    "offset": 292558,
    "length": 178,
    "sourcetext": " func presentErrorSheet(\n        on viewController: UIViewController,\n        context: PresentableContext,\n        error: Error,\n        callback: @escaping () async -> Void\n    "
  },
  {
    "name": "presentErrorSheet(on:context:error:)",
    "kind": "Instance Method",
    "offset": 292741,
    "length": 132,
    "sourcetext": " func presentErrorSheet(\n        on viewController: UIViewController,\n        context: PresentableContext,\n        error: Error\n    "
  },
  {
    "name": "presentErrorSheet(on:context:type:outsiteDismissCallback:callback:)",
    "kind": "Instance Method",
    "offset": 292878,
    "length": 257,
    "sourcetext": " func presentErrorSheet(\n        on viewController: UIViewController,\n        context: PresentableContext,\n        type: GenericErrorScreen.Configuration.Option,\n        outsiteDismissCallback: (() async -> Void)?,\n        callback: (() async -> Void)?\n    "
  },
  {
    "name": "presentErrorSheet(on:error:callback:)",
    "kind": "Instance Method",
    "offset": 293140,
    "length": 141,
    "sourcetext": " func presentErrorSheet(\n        on viewController: UIViewController,\n        error: Error,\n        callback: @escaping () async -> Void\n    "
  },
  {
    "name": "presentErrorSheetWithDismissCallback(on:error:callback:)",
    "kind": "Instance Method",
    "offset": 293287,
    "length": 160,
    "sourcetext": " func presentErrorSheetWithDismissCallback(\n        on viewController: UIViewController,\n        error: Error,\n        callback: @escaping () async -> Void\n    "
  },
  {
    "name": "presentErrorSheet(on:error:)",
    "kind": "Instance Method",
    "offset": 293453,
    "length": 95,
    "sourcetext": " func presentErrorSheet(\n        on viewController: UIViewController,\n        error: Error\n    "
  },
  {
    "name": "presentErrorSheet(on:type:callback:)",
    "kind": "Instance Method",
    "offset": 293553,
    "length": 167,
    "sourcetext": " func presentErrorSheet(\n        on viewController: UIViewController,\n        type: GenericErrorScreen.Configuration.Option,\n        callback: (() async -> Void)?\n    "
  },
  {
    "name": "presentErrorSheetWithDismissCallback(on:type:dismiss:callback:)",
    "kind": "Instance Method",
    "offset": 293725,
    "length": 233,
    "sourcetext": " func presentErrorSheetWithDismissCallback(\n        on viewController: UIViewController,\n        type: GenericErrorScreen.Configuration.Option,\n        dismiss: @escaping (() async -> Void),\n        callback: (() async -> Void)?\n    "
  },
  {
    "name": "init()",
    "kind": "Instance Method",
    "offset": 294040,
    "length": 9,
    "sourcetext": " init() {"
  },
  {
    "name": "presentErrorSheet(on:error:callback:)",
    "kind": "Instance Method",
    "offset": 294062,
    "length": 375,
    "sourcetext": " func presentErrorSheet(\n        on viewController: UIViewController,\n        error: Error,\n        callback: @escaping () async -> Void\n    ) {\n        presentErrorSheet(\n            on: viewController,\n            context: AlwaysPresentable(),\n            type: errorOption(for: error),\n            outsiteDismissCallback: nil,\n            callback: callback\n        )\n    "
  },
  {
    "name": "presentErrorSheetWithDismissCallback(on:error:callback:)",
    "kind": "Instance Method",
    "offset": 294450,
    "length": 394,
    "sourcetext": " func presentErrorSheetWithDismissCallback(\n        on viewController: UIViewController,\n        error: Error,\n        callback: @escaping () async -> Void\n    ) {\n        presentErrorSheet(\n            on: viewController,\n            context: AlwaysPresentable(),\n            type: errorOption(for: error),\n            outsiteDismissCallback: callback,\n            callback: nil\n        )\n    "
  },
  {
    "name": "presentErrorSheet(on:error:)",
    "kind": "Instance Method",
    "offset": 294857,
    "length": 324,
    "sourcetext": " func presentErrorSheet(\n        on viewController: UIViewController,\n        error: Error\n    ) {\n        presentErrorSheet(\n            on: viewController,\n            context: AlwaysPresentable(),\n            type: errorOption(for: error),\n            outsiteDismissCallback: nil,\n            callback: nil\n        )\n    "
  },
  {
    "name": "presentErrorSheetWithDismissCallback(on:type:dismiss:callback:)",
    "kind": "Instance Method",
    "offset": 295194,
    "length": 452,
    "sourcetext": " func presentErrorSheetWithDismissCallback(\n        on viewController: UIViewController,\n        type: GenericErrorScreen.Configuration.Option,\n        dismiss: @escaping (() async -> Void),\n        callback: (() async -> Void)?\n    ) {\n        presentErrorSheet(\n            on: viewController,\n            context: AlwaysPresentable(),\n            type: type,\n            outsiteDismissCallback: dismiss,\n            callback: callback\n        )\n    "
  },
  {
    "name": "presentErrorSheet(on:type:callback:)",
    "kind": "Instance Method",
    "offset": 295659,
    "length": 382,
    "sourcetext": " func presentErrorSheet(\n        on viewController: UIViewController,\n        type: GenericErrorScreen.Configuration.Option,\n        callback: (() async -> Void)?\n    ) {\n        presentErrorSheet(\n            on: viewController,\n            context: AlwaysPresentable(),\n            type: type,\n            outsiteDismissCallback: nil,\n            callback: callback\n        )\n    "
  },
  {
    "name": "presentErrorSheet(on:context:error:callback:)",
    "kind": "Instance Method",
    "offset": 296054,
    "length": 400,
    "sourcetext": " func presentErrorSheet(\n        on viewController: UIViewController,\n        context: PresentableContext,\n        error: Error,\n        callback: @escaping () async -> Void\n    ) {\n        presentErrorSheet(\n            on: viewController,\n            context: context,\n            type: errorOption(for: error),\n            outsiteDismissCallback: nil,\n            callback: callback\n        )\n    "
  },
  {
    "name": "presentErrorSheet(on:context:error:)",
    "kind": "Instance Method",
    "offset": 296467,
    "length": 349,
    "sourcetext": " func presentErrorSheet(\n        on viewController: UIViewController,\n        context: PresentableContext,\n        error: Error\n    ) {\n        presentErrorSheet(\n            on: viewController,\n            context: context,\n            type: errorOption(for: error),\n            outsiteDismissCallback: nil,\n            callback: nil\n        )\n    "
  },
  {
    "name": "presentErrorSheet(on:context:type:outsiteDismissCallback:callback:)",
    "kind": "Instance Method",
    "offset": 296829,
    "length": 1044,
    "sourcetext": " func presentErrorSheet(\n        on viewController: UIViewController,\n        context: PresentableContext,\n        type: GenericErrorScreen.Configuration.Option,\n        outsiteDismissCallback: (() async -> Void)?,\n        callback: (() async -> Void)?\n    ) {\n        guard context.isContextAvailable else { return }\n        var configuration = GenericErrorScreen.Configuration.make(for: type)\n        configuration.actionButtonDisplayMode = callback != nil ? .primaryOnly : .none\n        configuration.router.didDismiss = {\n            Task { await outsiteDismissCallback?() }\n        }\n        configuration.router.didSelectPrimaryActionButton = { viewController in { [weak viewController] _ in\n                viewController?.dismiss(animated: true) {\n                    Task { await callback?() }\n                }\n            }\n        }\n        DispatchQueue.main.async {\n            let destination = GenericErrorScreen.build(configuration: configuration)\n            viewController.present(destination, animated: true)\n        }\n\n    "
  },
  {
    "name": "errorOption(for:)",
    "kind": "Instance Method",
    "offset": 297887,
    "length": 340,
    "sourcetext": " func errorOption(for error: Error) -> GenericErrorScreen.Configuration.Option {\n        if case ClientCommon.ErrorResponse.error(_, _, let callError) = error,\n           let callError = callError as? CallError, callError.isInternetConnectionError {\n            return .noInternetConnection\n        }\n        return .somethingWentWrong\n    "
  },
  {
    "name": "init(date:minimumDate:maximumDate:placeholder:calendar:dateFormatter:locale:)",
    "kind": "Instance Method",
    "offset": 299519,
    "length": 483,
    "sourcetext": " init(\n        date: Binding<Date?>,\n        minimumDate: Date? = nil,\n        maximumDate: Date? = nil,\n        placeholder: String,\n        calendar: Calendar,\n        dateFormatter: DateFormatter,\n        locale: Locale\n    ) {\n        self._date = date\n        self.minimumDate = minimumDate\n        self.maximumDate = maximumDate\n        self.placeholder = placeholder\n        self.calendar = calendar\n        self.dateFormatter = dateFormatter\n        self.locale = locale\n    "
  },
  {
    "name": "makeUIView(context:)",
    "kind": "Instance Method",
    "offset": 300015,
    "length": 645,
    "sourcetext": " func makeUIView(context: Context) -> DatePickerTextField {\n        let textField = DatePickerTextField(\n            date: $date,\n            minimumDate: minimumDate,\n            maximumDate: maximumDate,\n            calendar: calendar,\n            locale: locale,\n            frame: .zero\n        )\n        textField.setNaturalTextAlignment()\n        textField.placeholder = placeholder\n        if let date = date {\n            textField.text = dateFormatter.string(from: date)\n        }\n        textField.rightView = UIImageView(image: configuration.images.calendarIcon)\n        textField.rightViewMode = .always\n        return textField\n    "
  },
  {
    "name": "updateUIView(_:context:)",
    "kind": "Instance Method",
    "offset": 300673,
    "length": 401,
    "sourcetext": " func updateUIView(_ uiView: DatePickerTextField, context: Context) {\n        if let date = date {\n            uiView.text = dateFormatter.string(from: date)\n        }\n        uiView.setContentHuggingPriority(.defaultHigh, for: .vertical)\n        uiView.setContentHuggingPriority(.defaultLow, for: .horizontal)\n        uiView.setContentCompressionResistancePriority(.defaultLow, for: .horizontal)\n    "
  },
  {
    "name": "init(date:minimumDate:maximumDate:calendar:locale:frame:)",
    "kind": "Instance Method",
    "offset": 302392,
    "length": 645,
    "sourcetext": " init(\n        date: Binding<Date?>,\n        minimumDate: Date? = nil,\n        maximumDate: Date? = nil,\n        calendar: Calendar,\n        locale: Locale,\n        frame: CGRect\n    ) {\n        self._date = date\n        self.minimumDate = minimumDate\n        self.maximumDate = maximumDate\n        self.calendar = calendar\n        self.locale = locale\n        super.init(frame: frame)\n\n        inputView = datePicker\n        inputAccessoryView = toolbar\n        datePicker.addTarget(self, action: #selector(datePickerDidSelect(_:)), for: .valueChanged)\n        if let date = date.wrappedValue {\n            datePicker.date = date\n        }\n    "
  },
  {
    "name": "init(coder:)",
    "kind": "Instance Method",
    "offset": 303052,
    "length": 89,
    "sourcetext": " init?(coder: NSCoder) {\n        fatalError(\"init(coder:) has not been implemented\")\n    "
  },
  {
    "name": "datePickerDidSelect(_:)",
    "kind": "Instance Method",
    "offset": 303161,
    "length": 83,
    "sourcetext": " func datePickerDidSelect(_ sender: UIDatePicker) {\n        date = sender.date\n    "
  },
  {
    "name": "dismissTextField()",
    "kind": "Instance Method",
    "offset": 303264,
    "length": 93,
    "sourcetext": " func dismissTextField() {\n        date = datePicker.date\n        resignFirstResponder()\n    "
  },
  {
    "name": "makeBody(configuration:)",
    "kind": "Instance Method",
    "offset": 304033,
    "length": 645,
    "sourcetext": " func makeBody(configuration: Configuration) -> some View {\n        configuration.label\n            .modifier(PrimaryButtonStyleModifier(size: size))\n            .foregroundColor(foregroundColor(isPressed: configuration.isPressed))\n            .background(backgroundColor(isPressed: configuration.isPressed))\n            .overlay {\n                if isLoading {\n                    ZStack {\n                        backgroundColor(isPressed: true)\n                        ProgressView()\n                    }\n                }\n            }\n            .clipShape(Capsule())\n            .animation(.default, value: configuration.isPressed)\n    "
  },
  {
    "name": "foregroundColor(isPressed:)",
    "kind": "Instance Method",
    "offset": 304692,
    "length": 234,
    "sourcetext": " func foregroundColor(isPressed: Bool) -> Color {\n        guard isEnabled else {\n            return DesignSystem.shared.colors.neutrals.neutral20.color\n        }\n        return DesignSystem.shared.colors.neutrals.neutral100.color\n    "
  },
  {
    "name": "backgroundColor(isPressed:)",
    "kind": "Instance Method",
    "offset": 304940,
    "length": 332,
    "sourcetext": " func backgroundColor(isPressed: Bool) -> Color {\n        guard isEnabled else {\n            return DesignSystem.shared.colors.neutrals.neutral10.color\n        }\n        if isPressed {\n            return DesignSystem.shared.colors.selected.default.color\n        }\n        return DesignSystem.shared.colors.primary.default.color\n    "
  },
  {
    "name": "body(content:)",
    "kind": "Instance Method",
    "offset": 305369,
    "length": 697,
    "sourcetext": " func body(content: Content) -> some View {\n        switch size {\n        case .small:\n            content\n                .padding(.vertical, DesignSystem.shared.spacer.sm)\n                .padding(.horizontal, DesignSystem.shared.spacer.md)\n                .font(.preferredFont(.subheadline, .medium))\n        case .custom(let height, let padding):\n            content\n                .frame(height: height)\n                .padding(.horizontal, padding)\n                .font(.preferredFont(.body, .medium))\n        case .big:\n            content\n                .frame(height: 56)\n                .frame(maxWidth: .infinity)\n                .font(.preferredFont(.body, .medium))\n        }\n    "
  },
  {
    "name": "primary(isEnabled:isLoading:size:)",
    "kind": "Static Method",
    "offset": 306138,
    "length": 192,
    "sourcetext": " static func primary(isEnabled: Bool = true, isLoading: Bool = false, size: PrimaryButtonStyle.Size = .big) -> Self {\n        .init(isEnabled: isEnabled, isLoading: isLoading, size: size)\n    "
  },
  {
    "name": "makeBody(configuration:)",
    "kind": "Instance Method",
    "offset": 307009,
    "length": 621,
    "sourcetext": " func makeBody(configuration: Configuration) -> some View {\n        configuration.label\n            .modifier(SecondaryButtonStyleModifier(size: size))\n            .foregroundColor(foregroundColor(isPressed: configuration.isPressed))\n            .overlay {\n                if isLoading {\n                    ProgressView()\n                }\n            }\n            .overlay {\n                Capsule()\n                    .strokeBorder(borderColor(isPressed: configuration.isPressed), lineWidth: 1)\n            }\n            .contentShape(Capsule())\n            .animation(.default, value: configuration.isPressed)\n    "
  },
  {
    "name": "foregroundColor(isPressed:)",
    "kind": "Instance Method",
    "offset": 307644,
    "length": 276,
    "sourcetext": " func foregroundColor(isPressed: Bool) -> Color {\n        guard !isLoading else {\n            return Color.clear\n        }\n        if isPressed || !isEnabled {\n            return foregroundColor.withAlphaComponent(0.3).color\n        }\n        return foregroundColor.color\n    "
  },
  {
    "name": "borderColor(isPressed:)",
    "kind": "Instance Method",
    "offset": 307934,
    "length": 191,
    "sourcetext": " func borderColor(isPressed: Bool) -> Color {\n        if isPressed || !isEnabled {\n            return borderColor.withAlphaComponent(0.3).color\n        }\n        return borderColor.color\n    "
  },
  {
    "name": "body(content:)",
    "kind": "Instance Method",
    "offset": 308226,
    "length": 458,
    "sourcetext": " func body(content: Content) -> some View {\n        switch size {\n        case .small:\n            content\n                .font(.preferredFont(.subheadline, .medium))\n                .frame(height: 28)\n                .padding(.horizontal, DesignSystem.shared.spacer.md)\n        case .big:\n            content\n                .font(.preferredFont(.body, .medium))\n                .frame(height: 56)\n                .frame(maxWidth: .infinity)\n        }\n    "
  },
  {
    "name": "secondary(isEnabled:isLoading:foregroundColor:borderColor:size:)",
    "kind": "Static Method",
    "offset": 308758,
    "length": 495,
    "sourcetext": " static func secondary(\n        isEnabled: Bool = true,\n        isLoading: Bool = false,\n        foregroundColor: UIColor = DesignSystem.shared.colors.text.support,\n        borderColor: UIColor = DesignSystem.shared.colors.text.support,\n        size: SecondaryButtonStyle.Size = .big\n    ) -> Self {\n        .init(\n            isEnabled: isEnabled,\n            isLoading: isLoading,\n            foregroundColor: foregroundColor,\n            borderColor: borderColor,\n            size: size)\n    "
  },
  {
    "name": "init(placeholder:searchText:)",
    "kind": "Instance Method",
    "offset": 309911,
    "length": 139,
    "sourcetext": " init(placeholder: String, searchText: Binding<String>) {\n        self.placeholder = placeholder\n        self._searchText = searchText\n    "
  },
  {
    "name": "cornerRadius(_:corners:)",
    "kind": "Instance Method",
    "offset": 311651,
    "length": 147,
    "sourcetext": " func cornerRadius(_ radius: CGFloat, corners: UIRectCorner) -> some View {\n        clipShape(RoundedCorner(radius: radius, corners: corners))\n    "
  },
  {
    "name": "path(in:)",
    "kind": "Instance Method",
    "offset": 311925,
    "length": 252,
    "sourcetext": " func path(in rect: CGRect) -> Path {\n        let path = UIBezierPath(\n            roundedRect: rect,\n            byRoundingCorners: corners,\n            cornerRadii: CGSize(width: radius, height: radius)\n        )\n        return Path(path.cgPath)\n    "
  },
  {
    "name": "init(widthMode:heightMode:)",
    "kind": "Instance Method",
    "offset": 312834,
    "length": 207,
    "sourcetext": " init(widthMode: SpacingMode = .flexible, heightMode: SpacingMode = .flexible) {\n        super.init(frame: .zero)\n\n        setupWidthSpacing(with: widthMode)\n        setupHeightSpacing(with: heightMode)\n    "
  },
  {
    "name": "init(coder:)",
    "kind": "Instance Method",
    "offset": 313087,
    "length": 89,
    "sourcetext": " init?(coder: NSCoder) {\n        fatalError(\"init(coder:) has not been implemented\")\n    "
  },
  {
    "name": "setupWidthSpacing(with:)",
    "kind": "Instance Method",
    "offset": 313190,
    "length": 554,
    "sourcetext": " func setupWidthSpacing(with mode: SpacingMode) {\n        switch mode {\n        case .flexible:\n            return\n\n        case let .flexibleMinimum(width):\n            snp.makeConstraints { $0.width.greaterThanOrEqualTo(width) }\n\n        case let .flexibleBetween(range):\n            snp.makeConstraints {\n                $0.width.greaterThanOrEqualTo(range.lowerBound)\n                $0.width.lessThanOrEqualTo(range.upperBound)\n            }\n\n        case let .fixed(width):\n            snp.makeConstraints { $0.width.equalTo(width) }\n        }\n    "
  },
  {
    "name": "setupHeightSpacing(with:)",
    "kind": "Instance Method",
    "offset": 313758,
    "length": 563,
    "sourcetext": " func setupHeightSpacing(with mode: SpacingMode) {\n        switch mode {\n        case .flexible:\n            return\n\n        case let .flexibleMinimum(height):\n            snp.makeConstraints { $0.height.greaterThanOrEqualTo(height) }\n\n        case let .flexibleBetween(range):\n            snp.makeConstraints {\n                $0.height.greaterThanOrEqualTo(range.lowerBound)\n                $0.height.lessThanOrEqualTo(range.upperBound)\n            }\n\n        case let .fixed(height):\n            snp.makeConstraints { $0.height.equalTo(height) }\n        }\n    "
  },
  {
    "name": "init(frame:)",
    "kind": "Instance Method",
    "offset": 314776,
    "length": 165,
    "sourcetext": " init(frame: CGRect) {\n        super.init(frame: frame)\n        backgroundColor = DesignSystem.shared.colors.surfacePrimary.default\n        clipsToBounds = true\n    "
  },
  {
    "name": "init(coder:)",
    "kind": "Instance Method",
    "offset": 314956,
    "length": 89,
    "sourcetext": " init?(coder: NSCoder) {\n        fatalError(\"init(coder:) has not been implemented\")\n    "
  },
  {
    "name": "layoutSubviews()",
    "kind": "Instance Method",
    "offset": 315067,
    "length": 168,
    "sourcetext": " func layoutSubviews() {\n        super.layoutSubviews()\n\n        layer.cornerRadius = 24\n        layer.maskedCorners = [.layerMaxXMinYCorner, .layerMinXMinYCorner]\n    "
  },
  {
    "name": "makeDefaultConstraints(topInset:)",
    "kind": "Instance Method",
    "offset": 315248,
    "length": 394,
    "sourcetext": " func makeDefaultConstraints(topInset: CGFloat = DesignSystem.shared.spacer.sm) {\n        guard let superview else {\n            return assertionFailure(\"CardContentView was not added to the view hierarchy\")\n        }\n        snp.makeConstraints {\n            $0.top.equalTo(superview.safeAreaLayoutGuide).inset(topInset)\n            $0.leading.trailing.bottom.equalToSuperview()\n        }\n    "
  },
  {
    "name": "init(size:)",
    "kind": "Instance Method",
    "offset": 316205,
    "length": 76,
    "sourcetext": " init(size: UIKitAvatarView.Size = .default) {\n        self.size = size\n    "
  },
  {
    "name": "layoutSubviews()",
    "kind": "Instance Method",
    "offset": 317702,
    "length": 190,
    "sourcetext": " func layoutSubviews() {\n        super.layoutSubviews()\n        imageView.layer.cornerRadius = DesignSystem.CornerRadiusTypes.max(roundedCorners: .allCorners).calculateFor(layer).radius\n    "
  },
  {
    "name": "traitCollectionDidChange(_:)",
    "kind": "Instance Method",
    "offset": 317914,
    "length": 209,
    "sourcetext": " func traitCollectionDidChange(_ previousTraitCollection: UITraitCollection?) {\n        super.traitCollectionDidChange(previousTraitCollection)\n        onTraitCollectionDidChange?(previousTraitCollection)\n    "
  },
  {
    "name": "init(size:)",
    "kind": "Instance Method",
    "offset": 318345,
    "length": 113,
    "sourcetext": " init(size: Size = .default) {\n        super.init(frame: .zero)\n        self.size = size\n        setupView()\n    "
  },
  {
    "name": "init(coder:)",
    "kind": "Instance Method",
    "offset": 318504,
    "length": 89,
    "sourcetext": " init?(coder: NSCoder) {\n        fatalError(\"init(coder:) has not been implemented\")\n    "
  },
  {
    "name": "setupView(with:)",
    "kind": "Instance Method",
    "offset": 319030,
    "length": 547,
    "sourcetext": " func setupView(with defaultImage: UIImage? = UIImage.named(\"avatar\", in: .snbCommon)) {\n        // TODO: Remove this when the Avatar Image is connected to the BE\n        image = AvatarLocalImageManager.shared.getSavedImage() ?? defaultImage\n        clipsToBounds = true\n        translatesAutoresizingMaskIntoConstraints = false\n        NSLayoutConstraint.activate([\n            widthAnchor.constraint(equalToConstant: size.rawValue),\n            heightAnchor.constraint(equalToConstant: size.rawValue)\n        ])\n        configureImageView()\n    "
  },
  {
    "name": "configureImageView()",
    "kind": "Instance Method",
    "offset": 319583,
    "length": 445,
    "sourcetext": " func configureImageView() {\n        subviews.forEach { $0.removeFromSuperview() }\n        addSubview(imageView)\n        NSLayoutConstraint.activate([\n            imageView.leadingAnchor.constraint(equalTo: leadingAnchor),\n            imageView.topAnchor.constraint(equalTo: topAnchor),\n            imageView.trailingAnchor.constraint(equalTo: trailingAnchor),\n            imageView.bottomAnchor.constraint(equalTo: bottomAnchor)\n        ])\n    "
  },
  {
    "name": "init(rootView:)",
    "kind": "Instance Method",
    "offset": 320604,
    "length": 74,
    "sourcetext": " init(rootView: ContentView) {\n        super.init(rootView: rootView)\n    "
  },
  {
    "name": "init(coder:)",
    "kind": "Instance Method",
    "offset": 320743,
    "length": 98,
    "sourcetext": " init?(coder aDecoder: NSCoder) {\n        fatalError(\"init(coder:) has not been implemented\")\n    "
  },
  {
    "name": "viewWillAppear(_:)",
    "kind": "Instance Method",
    "offset": 320863,
    "length": 236,
    "sourcetext": " func viewWillAppear(_ animated: Bool) {\n        super.viewWillAppear(animated)\n        isNavigationBarHidden = navigationController?.isNavigationBarHidden\n        navigationController?.setNavigationBarHidden(true, animated: false)\n    "
  },
  {
    "name": "viewWillDisappear(_:)",
    "kind": "Instance Method",
    "offset": 321121,
    "length": 283,
    "sourcetext": " func viewWillDisappear(_ animated: Bool) {\n        super.viewWillDisappear(animated)\n        guard let isNavigationBarHidden, !isNavigationBarHidden else {\n            return\n        }\n        navigationController?.setNavigationBarHidden(isNavigationBarHidden, animated: false)\n    "
  },
  {
    "name": "init(backgroundColor:)",
    "kind": "Instance Method",
    "offset": 321927,
    "length": 137,
    "sourcetext": " init(backgroundColor: Color = DesignSystem.shared.colors.foundation.default.color) {\n        self.backgroundColor = backgroundColor\n    "
  },
  {
    "name": "init()",
    "kind": "Instance Method",
    "offset": 323490,
    "length": 9,
    "sourcetext": " init() {"
  },
  {
    "name": "init(frame:)",
    "kind": "Instance Method",
    "offset": 324211,
    "length": 80,
    "sourcetext": " init(frame: CGRect) {\n        super.init(frame: frame)\n        setupView()\n    "
  },
  {
    "name": "init(coder:)",
    "kind": "Instance Method",
    "offset": 324337,
    "length": 89,
    "sourcetext": " init?(coder: NSCoder) {\n        fatalError(\"init(coder:) has not been implemented\")\n    "
  },
  {
    "name": "layoutSubviews()",
    "kind": "Instance Method",
    "offset": 324448,
    "length": 106,
    "sourcetext": " func layoutSubviews() {\n        super.layoutSubviews()\n        layer.cornerRadius = frame.height / 2\n    "
  },
  {
    "name": "setupView()",
    "kind": "Instance Method",
    "offset": 324596,
    "length": 198,
    "sourcetext": " func setupView() {\n        titleLable.text = strings.supportButton\n        iconImageView.image = images.supportIcon\n        configureSubviews()\n        applyStyles()\n        applyConstraints()\n    "
  },
  {
    "name": "configureSubviews()",
    "kind": "Instance Method",
    "offset": 324800,
    "length": 147,
    "sourcetext": " func configureSubviews() {\n        container.addSubview(titleLable)\n        container.addSubview(iconImageView)\n        addSubview(container)\n    "
  },
  {
    "name": "applyStyles()",
    "kind": "Instance Method",
    "offset": 324953,
    "length": 415,
    "sourcetext": " func applyStyles() {\n        isUserInteractionEnabled = true\n        container.isUserInteractionEnabled = false\n        backgroundColor = constants.backgroundColor\n        layer.borderWidth = constants.borderWidth\n        layer.borderColor = constants.borderColor.cgColor\n        titleLable.textColor = constants.textColor\n        titleLable.font = constants.font\n        contentHorizontalAlignment = .leading\n    "
  },
  {
    "name": "applyConstraints()",
    "kind": "Instance Method",
    "offset": 325374,
    "length": 932,
    "sourcetext": " func applyConstraints() {\n        let containerWidth: CGFloat = isRTL ? constants.containerRTLWidth : constants.containerWidth\n        container.snp.makeConstraints { make in\n            make.top.leading.bottom.trailing.equalToSuperview()\n            make.height.equalTo(constants.containerHeight)\n            make.width.equalTo(containerWidth)\n        }\n\n        titleLable.snp.makeConstraints { make in\n            make.leading.equalToSuperview().inset(constants.titleLableLeading)\n            make.height.equalToSuperview()\n            make.centerY.equalToSuperview()\n        }\n\n        iconImageView.snp.makeConstraints { make in\n            make.leading.equalTo(iconImageView.snp.trailing).offset(constants.offset)\n            make.trailing.equalToSuperview().inset(constants.iconImageViewTrailing)\n            make.height.width.equalTo(constants.iconImageViewHeight)\n            make.centerY.equalToSuperview()\n        }\n    "
  },
  {
    "name": "init(backgroundType:title:)",
    "kind": "Instance Method",
    "offset": 327001,
    "length": 147,
    "sourcetext": " init(backgroundType: BackgroundType = .solid, title: String? = nil) {\n        self.backgroundType = backgroundType\n        self.title = title\n    "
  },
  {
    "name": "getTitle(_:)",
    "kind": "Instance Method",
    "offset": 327827,
    "length": 247,
    "sourcetext": " func getTitle(_ text: String) -> some View {\n        Text(text)\n            .multilineTextAlignment(.center)\n            .font(.preferredFont(.body, .regular))\n            .foregroundColor(DesignSystem.shared.colors.neutrals.neutral00.color)\n    "
  },
  {
    "name": "init(frame:)",
    "kind": "Instance Method",
    "offset": 329612,
    "length": 80,
    "sourcetext": " init(frame: CGRect) {\n        super.init(frame: frame)\n        setupView()\n    "
  },
  {
    "name": "init(coder:)",
    "kind": "Instance Method",
    "offset": 329738,
    "length": 89,
    "sourcetext": " init?(coder: NSCoder) {\n        fatalError(\"init(coder:) has not been implemented\")\n    "
  },
  {
    "name": "setupView()",
    "kind": "Instance Method",
    "offset": 329841,
    "length": 738,
    "sourcetext": " func setupView() {\n        backgroundColor = DesignSystem.shared.colors.foundation.default\n        addSubview(stackView)\n        stackView.snp.makeConstraints {\n            $0.top.leading.trailing.equalToSuperview().inset(DesignSystem.shared.spacer.xl)\n            $0.bottom.equalToSuperview().inset(DesignSystem.shared.spacer.xl).priority(.medium)\n        }\n        stackView.addArrangedSubview(UIView())\n        stackView.addArrangedSubview(iconView)\n        stackView.addArrangedSubview(titleLabel, spaceBefore: 22)\n        stackView.addArrangedSubview(descriptionLabel)\n        stackView.addArrangedSubview(UIView())\n\n        titleLabel.snp.makeConstraints {\n            $0.centerY.equalToSuperview().priority(.medium)\n        }\n    "
  },
  {
    "name": "init(textTitle:textDescription:)",
    "kind": "Instance Method",
    "offset": 331158,
    "length": 152,
    "sourcetext": " init(textTitle: String? = nil, textDescription: String? = nil) {\n        self.textTitle = textTitle\n        self.textDescription = textDescription\n    "
  },
  {
    "name": "makeUIView(context:)",
    "kind": "Instance Method",
    "offset": 331323,
    "length": 104,
    "sourcetext": " func makeUIView(context: Context) -> UIKitNoSearchResultsView {\n        UIKitNoSearchResultsView()\n    "
  },
  {
    "name": "updateUIView(_:context:)",
    "kind": "Instance Method",
    "offset": 331440,
    "length": 253,
    "sourcetext": " func updateUIView(_ uiView: UIKitNoSearchResultsView, context: Context) {\n        if let textTitle {\n            uiView.textTitle = textTitle\n        }\n        if let textDescription {\n            uiView.textDescription = textDescription\n        }\n    "
  },
  {
    "name": "init(title:optionalText:placeholderText:bindableText:characterLimit:showRemainingChars:backgroundColor:lineLimit:disabled:)",
    "kind": "Instance Method",
    "offset": 332620,
    "length": 697,
    "sourcetext": " init(\n        title: String,\n        optionalText: String? = nil,\n        placeholderText: String,\n        bindableText: Binding<String>,\n        characterLimit: Int,\n        showRemainingChars: Bool = false,\n        backgroundColor: Color = Color.clear,\n        lineLimit: Int = 4,\n        disabled: Bool = false\n    ) {\n        self.title = title\n        self.optionalText = optionalText\n        self.placeholderText = placeholderText\n        self._bindableText = bindableText\n        self.characterLimit = characterLimit\n        self.showRemainingChars = showRemainingChars\n        self.backgroundColor = backgroundColor\n        self.lineLimit = lineLimit\n        self.disabled = disabled\n    "
  },
  {
    "name": "transparentScrollingBackground(publisher:)",
    "kind": "Instance Method",
    "offset": 337714,
    "length": 247,
    "sourcetext": " func transparentScrollingBackground(publisher: String) -> some View {\n        if #available(iOS 16.0, *) {\n            return scrollContentBackground(.hidden)\n        } else {\n            return opacity(publisher.isEmpty ? 0.1 : 1)\n        }\n    "
  },
  {
    "name": "init(action:)",
    "kind": "Instance Method",
    "offset": 338473,
    "length": 71,
    "sourcetext": " init(action: @escaping () -> Void) {\n        self.action = action\n    "
  },
  {
    "name": "makeUIView(context:)",
    "kind": "Instance Method",
    "offset": 338557,
    "length": 322,
    "sourcetext": " func makeUIView(context: Context) -> PKAddPassButton {\n        let button = PKAddPassButton(addPassButtonStyle: .black)\n        let didTapAppleWalletButtonAction = UIAction { uiAction in\n            action()\n        }\n        button.addAction(didTapAppleWalletButtonAction, for: .touchUpInside)\n        return button\n    "
  },
  {
    "name": "updateUIView(_:context:)",
    "kind": "Instance Method",
    "offset": 338892,
    "length": 66,
    "sourcetext": " func updateUIView(_ uiView: PKAddPassButton, context: Context) { "
  },
  {
    "name": "customShadow(style:)",
    "kind": "Instance Method",
    "offset": 339371,
    "length": 869,
    "sourcetext": " func customShadow(style: DesignSystem.ShadowStyle) -> some View {\n        var shadowStyle: DesignSystem.Shadow\n        switch style {\n        case .none:\n            shadowStyle = DesignSystem.shared.shadows.none\n        case .small:\n            shadowStyle = DesignSystem.shared.shadows.small\n        case .medium:\n            shadowStyle = DesignSystem.shared.shadows.medium\n        case .large:\n            shadowStyle = DesignSystem.shared.shadows.large\n        case .xLarge:\n            shadowStyle = DesignSystem.shared.shadows.xLarge\n        @unknown default:\n            fatalError(\"Unsupported Shadow style\")\n        }\n        return shadow(\n            color: shadowStyle.color.color.opacity(Double(shadowStyle.opacity)),\n            radius: shadowStyle.radius,\n            x: shadowStyle.offset.width,\n            y: shadowStyle.offset.height\n        )\n    "
  },
  {
    "name": "init(rootView:barStyle:)",
    "kind": "Instance Method",
    "offset": 340925,
    "length": 151,
    "sourcetext": " init(rootView: ContentView, barStyle: UIStatusBarStyle) {\n        self.barStyle = barStyle\n        super.init(rootView: HostView(view: rootView))\n    "
  },
  {
    "name": "init(coder:)",
    "kind": "Instance Method",
    "offset": 341148,
    "length": 98,
    "sourcetext": " init?(coder aDecoder: NSCoder) {\n        fatalError(\"init(coder:) has not been implemented\")\n    "
  },
  {
    "name": "makeNavigationBarTransparent()",
    "kind": "Instance Method",
    "offset": 341470,
    "length": 1057,
    "sourcetext": " func makeNavigationBarTransparent() {\n        let standardAppearance = UINavigationBarAppearance()\n        standardAppearance.configureWithTransparentBackground()\n\n        let largeTitleTextAttributes: [NSAttributedString.Key: Any] = [\n            .foregroundColor: DesignSystem.shared.colors.surfacePrimary.default,\n            .font: DesignSystem.shared.fonts.preferredFont(.largeTitle, .medium)\n        ]\n        let titleTextAttributes: [NSAttributedString.Key: Any] = [\n            .foregroundColor: DesignSystem.shared.colors.surfacePrimary.default,\n            .font: DesignSystem.shared.fonts.preferredFont(.body, .medium)\n        ]\n        standardAppearance.largeTitleTextAttributes = largeTitleTextAttributes\n        standardAppearance.titleTextAttributes = titleTextAttributes\n\n        navigationItem.standardAppearance = standardAppearance\n        navigationItem.compactAppearance = standardAppearance\n        navigationItem.scrollEdgeAppearance = standardAppearance\n        navigationItem.compactScrollEdgeAppearance = standardAppearance\n    "
  },
  {
    "name": "layoutSubviews()",
    "kind": "Instance Method",
    "offset": 343533,
    "length": 89,
    "sourcetext": " func layoutSubviews() {\n        super.layoutSubviews()\n        updateContentsRect()\n    "
  },
  {
    "name": "updateContentsRect()",
    "kind": "Instance Method",
    "offset": 343636,
    "length": 1484,
    "sourcetext": " func updateContentsRect() {\n        var contentsRect = CGRect(origin: .zero, size: CGSize(width: 1, height: 1))\n\n        guard let imageSize = image?.size else {\n            layer.contentsRect = contentsRect\n            return\n        }\n\n        let viewBounds = bounds\n        let imageViewFactor = viewBounds.size.width / viewBounds.size.height\n        let imageFactor = imageSize.width / imageSize.height\n\n        if imageFactor > imageViewFactor {\n            // Image is wider than the view, so height will match\n            let scaledImageWidth = viewBounds.size.height * imageFactor\n            var xOffset: CGFloat = 0.0\n\n            if case .left = horizontalAlignment {\n                xOffset = -(scaledImageWidth - viewBounds.size.width) / 2\n            } else if case .right = horizontalAlignment {\n                xOffset = (scaledImageWidth - viewBounds.size.width) / 2\n            }\n\n            contentsRect.origin.x = xOffset / scaledImageWidth\n        } else {\n            let scaledImageHeight = viewBounds.size.width / imageFactor\n            var yOffset: CGFloat = 0.0\n\n            if case .top = verticalAlignment {\n                yOffset = -(scaledImageHeight - viewBounds.size.height) / 2\n            } else if case .bottom = verticalAlignment {\n                yOffset = (scaledImageHeight - viewBounds.size.height) / 2\n            }\n\n            contentsRect.origin.y = yOffset / scaledImageHeight\n        }\n\n        layer.contentsRect = contentsRect\n    "
  },
  {
    "name": "build(configuration:)",
    "kind": "Static Method",
    "offset": 345552,
    "length": 1092,
    "sourcetext": " static func build(configuration: Configuration) -> UIViewController {\n        let viewModel = LogoutScreenViewModel(configuration: configuration)\n        let viewController = LogoutScreenViewController(viewModel: viewModel, configuration: configuration)\n        viewModel.viewController = viewController\n        let sheetPresentationController = viewController.sheetPresentationController\n        if #available(iOS 16.0, *) {\n            sheetPresentationController?.detents = [.custom(resolver: { context in\n                return 300 // your custom height\n            })]\n        } else {\n            sheetPresentationController?.detents = [.medium()]\n        }\n\n        sheetPresentationController?.prefersScrollingExpandsWhenScrolledToEdge = false\n        sheetPresentationController?.prefersEdgeAttachedInCompactHeight = true\n        sheetPresentationController?.widthFollowsPreferredContentSizeWhenEdgeAttached = true\n        sheetPresentationController?.prefersGrabberVisible = true\n        sheetPresentationController?.preferredCornerRadius = 24.0\n\n        return viewController\n    "
  },
  {
    "name": "init(configuration:)",
    "kind": "Instance Method",
    "offset": 347215,
    "length": 98,
    "sourcetext": " init(configuration: LogoutScreen.Configuration) {\n        self.configuration = configuration\n    "
  },
  {
    "name": "primaryActionSubmit()",
    "kind": "Instance Method",
    "offset": 347319,
    "length": 159,
    "sourcetext": " func primaryActionSubmit() {\n        guard let viewController else { return }\n        configuration.router.didSelectPrimaryActionButton(viewController)()\n    "
  },
  {
    "name": "secondaryActionSubmit()",
    "kind": "Instance Method",
    "offset": 347484,
    "length": 163,
    "sourcetext": " func secondaryActionSubmit() {\n        guard let viewController else { return }\n        configuration.router.didSelectSecondaryActionButton(viewController)()\n    "
  },
  {
    "name": "init(viewModel:configuration:)",
    "kind": "Instance Method",
    "offset": 349445,
    "length": 213,
    "sourcetext": " init(viewModel: LogoutScreenViewModel, configuration: LogoutScreen.Configuration) {\n        self.viewModel = viewModel\n        self.configuration = configuration\n        super.init(nibName: nil, bundle: nil)\n    "
  },
  {
    "name": "init(coder:)",
    "kind": "Instance Method",
    "offset": 349704,
    "length": 89,
    "sourcetext": " init?(coder: NSCoder) {\n        fatalError(\"init(coder:) has not been implemented\")\n    "
  },
  {
    "name": "loadView()",
    "kind": "Instance Method",
    "offset": 349815,
    "length": 66,
    "sourcetext": " func loadView() {\n        super.loadView()\n        setupUI()\n    "
  },
  {
    "name": "setupUI()",
    "kind": "Instance Method",
    "offset": 349895,
    "length": 1007,
    "sourcetext": " func setupUI() {\n        view.backgroundColor = DesignSystem.shared.colors.foundation.default\n\n        let mainStack = UIStackView(axis: .vertical)\n\n        let stack = UIStackView(axis: .vertical)\n        stack.addArrangedSubview(titleLabel)\n        stack.addArrangedSubview(SpacerView(heightMode: .fixed(12)))\n\n        stack.addArrangedSubview(bodyLabel)\n        stack.addArrangedSubview(SpacerView(heightMode: .fixed(16)))\n\n        let upperView = UIView()\n        upperView.addSubview(stack)\n        stack.snp.makeConstraints { make in\n            make.centerX.centerY.equalToSuperview()\n        }\n        mainStack.addArrangedSubview(upperView)\n        mainStack.addArrangedSubview(secondaryActionButton)\n        mainStack.addArrangedSubview(primaryActionButton, spaceBefore: 22)\n\n        view.addSubview(mainStack)\n        mainStack.snp.makeConstraints {\n            $0.top.bottom.equalTo(view.safeAreaLayoutGuide).inset(16)\n            $0.leading.trailing.equalToSuperview().inset(16)\n        }\n    "
  },
  {
    "name": "primaryActionSubmit(_:)",
    "kind": "Instance Method",
    "offset": 350926,
    "length": 90,
    "sourcetext": " func primaryActionSubmit(_ sender: Button) {\n        viewModel.primaryActionSubmit()\n    "
  },
  {
    "name": "secondaryActionSubmit(_:)",
    "kind": "Instance Method",
    "offset": 351040,
    "length": 94,
    "sourcetext": " func secondaryActionSubmit(_ sender: Button) {\n        viewModel.secondaryActionSubmit()\n    "
  },
  {
    "name": "init()",
    "kind": "Instance Method",
    "offset": 351829,
    "length": 10,
    "sourcetext": " init() { "
  },
  {
    "name": "init()",
    "kind": "Instance Method",
    "offset": 352159,
    "length": 9,
    "sourcetext": " init() {"
  },
  {
    "name": "init()",
    "kind": "Instance Method",
    "offset": 353392,
    "length": 10,
    "sourcetext": " init() { "
  },
  {
    "name": "init()",
    "kind": "Instance Method",
    "offset": 353974,
    "length": 10,
    "sourcetext": " init() { "
  },
  {
    "name": "init(title:titleFont:value:errorMessage:isLoading:maxLength:isSecureTextEntry:copyPasteActionsDisabled:focusState:didTapReturnButton:shouldChangeCharsIn:didEndEditing:shouldBeginEditing:disabled:configuration:textPasteConfiguration:)",
    "kind": "Instance Method",
    "offset": 355322,
    "length": 1579,
    "sourcetext": " init(\n        title: String? = nil,\n        titleFont: Font = .preferredFont(.body, .medium),\n        value: Binding<String>,\n        errorMessage: String? = nil,\n        isLoading: Bool = false,\n        maxLength: Int? = nil,\n        isSecureTextEntry: Bool = false,\n        copyPasteActionsDisabled: Bool = false,\n        focusState: EquatableFocusState<FocusValue> = .init(binding: .constant(false), equals: true),\n        didTapReturnButton: @escaping () -> Void = {},\n        shouldChangeCharsIn: ((String, NSRange) -> Bool)? = nil,\n        didEndEditing: (() -> Void)? = nil,\n        shouldBeginEditing: (() -> Bool)? = nil,\n        disabled: Bool = false,\n        configuration: @escaping (UITextField) -> Void = { _ in },\n        textPasteConfiguration: ((UITextField) -> String?)? = nil\n    ) {\n        self.title = title\n        self.titleFont = titleFont\n        self._value = value\n        self.errorMessage = errorMessage\n        self.isLoading = isLoading\n        self.maxLength = maxLength\n        self.isSecureTextEntry = isSecureTextEntry\n        self.copyPasteActionsDisabled = copyPasteActionsDisabled\n        self.focusState = focusState\n        self.didTapReturnButton = didTapReturnButton\n        self.shouldChangeCharsIn = shouldChangeCharsIn\n        self.didEndEditing = didEndEditing\n        self.shouldBeginEditing = shouldBeginEditing\n        self.disabled = disabled\n        self.configuration = configuration\n        self.textPasteConfiguration = textPasteConfiguration\n        self._isSecureTextEnabled = .init(initialValue: isSecureTextEntry)\n    "
  },
  {
    "name": "init(binding:equals:)",
    "kind": "Instance Method",
    "offset": 360075,
    "length": 117,
    "sourcetext": " init(binding: Binding<Value?>, equals value: Value) {\n        self.binding = binding\n        self.value = value\n    "
  },
  {
    "name": "makeUIView(context:)",
    "kind": "Instance Method",
    "offset": 361401,
    "length": 584,
    "sourcetext": " func makeUIView(context: Context) -> UITextField {\n        let textField = copyPasteActionsDisabled ? ActionsProtectedTextField() : UITextField()\n        textField.delegate = context.coordinator\n        textField.pasteDelegate = textPasteConfiguration != nil ? context.coordinator : nil\n        textField.setNaturalTextAlignment()\n        textField.addTarget(context.coordinator, action: #selector(Coordinator.textFieldEditingChanged), for: .editingChanged)\n        textField.semanticContentAttribute = .forceLeftToRight\n        configuration(textField)\n        return textField\n    "
  },
  {
    "name": "updateUIView(_:context:)",
    "kind": "Instance Method",
    "offset": 361991,
    "length": 702,
    "sourcetext": " func updateUIView(_ uiView: UITextField, context: Context) {\n        uiView.text = text\n        uiView.isSecureTextEntry = isSecureTextEntry\n        uiView.setContentHuggingPriority(.defaultHigh, for: .vertical)\n        uiView.setContentHuggingPriority(.defaultLow, for: .horizontal)\n        uiView.setContentCompressionResistancePriority(.defaultLow, for: .horizontal)\n        if focusState.binding.wrappedValue == focusState.value, !uiView.isFirstResponder {\n            DispatchQueue.main.async { uiView.becomeFirstResponder() }\n        } else if focusState.binding.wrappedValue == nil, uiView.isFirstResponder {\n            DispatchQueue.main.async { uiView.resignFirstResponder() }\n        }\n    "
  },
  {
    "name": "makeCoordinator()",
    "kind": "Instance Method",
    "offset": 362699,
    "length": 196,
    "sourcetext": " func makeCoordinator() -> Coordinator<FocusValue> {\n        Coordinator($text, focusState, didTapReturnButton, shouldChangeCharsIn, didEndEditing, shouldBeginEditing, textPasteConfiguration)\n    "
  },
  {
    "name": "init(_:_:_:_:_:_:_:)",
    "kind": "Instance Method",
    "offset": 363431,
    "length": 782,
    "sourcetext": " init(\n            _ text: Binding<String>,\n            _ focusState: EquatableFocusState<FocusValue>,\n            _ didTapReturnButton: @escaping () -> Void,\n            _ shouldChangeCharsIn: ((String, NSRange) -> Bool)? = nil,\n            _ didEndEditing: (() -> Void)? = nil,\n            _ shouldBeginEditing: (() -> Bool)? = nil,\n            _ textPasteConfiguration: ((UITextField) -> String?)? = nil\n        ) {\n            self.text = text\n            self.focusState = focusState\n            self.didTapReturnButton = didTapReturnButton\n            self.shouldChangeCharsIn = shouldChangeCharsIn\n            self.didEndEditing = didEndEditing\n            self.shouldBeginEditing = shouldBeginEditing\n            self.textPasteConfiguration = textPasteConfiguration\n        "
  },
  {
    "name": "textFieldEditingChanged(_:)",
    "kind": "Instance Method",
    "offset": 364229,
    "length": 119,
    "sourcetext": " func textFieldEditingChanged(_ textField: UITextField) {\n            text.wrappedValue = textField.text ?? \"\"\n        "
  },
  {
    "name": "textFieldShouldReturn(_:)",
    "kind": "Instance Method",
    "offset": 364358,
    "length": 129,
    "sourcetext": " func textFieldShouldReturn(_ textField: UITextField) -> Bool {\n            didTapReturnButton()\n            return true\n        "
  },
  {
    "name": "textFieldDidBeginEditing(_:)",
    "kind": "Instance Method",
    "offset": 364497,
    "length": 169,
    "sourcetext": " func textFieldDidBeginEditing(_ textField: UITextField) {\n            DispatchQueue.main.async { self.focusState.binding.wrappedValue = self.focusState.value }\n        "
  },
  {
    "name": "textFieldShouldEndEditing(_:)",
    "kind": "Instance Method",
    "offset": 364676,
    "length": 184,
    "sourcetext": " func textFieldShouldEndEditing(_ textField: UITextField) -> Bool {\n            DispatchQueue.main.async { self.focusState.binding.wrappedValue = nil }\n            return true\n        "
  },
  {
    "name": "textField(_:shouldChangeCharactersIn:replacementString:)",
    "kind": "Instance Method",
    "offset": 364870,
    "length": 279,
    "sourcetext": " func textField(_ textField: UITextField, shouldChangeCharactersIn range: NSRange, replacementString string: String) -> Bool {\n            guard let shouldChangeCharsIn = self.shouldChangeCharsIn else { return true }\n            return shouldChangeCharsIn(string, range)\n        "
  },
  {
    "name": "textFieldShouldBeginEditing(_:)",
    "kind": "Instance Method",
    "offset": 365159,
    "length": 206,
    "sourcetext": " func textFieldShouldBeginEditing(_ textField: UITextField) -> Bool {\n            guard let shouldBeginEditing = self.shouldBeginEditing else { return true }\n            return shouldBeginEditing()\n        "
  },
  {
    "name": "textFieldDidEndEditing(_:)",
    "kind": "Instance Method",
    "offset": 365375,
    "length": 94,
    "sourcetext": " func textFieldDidEndEditing(_ textField: UITextField) {\n            didEndEditing?()\n        "
  },
  {
    "name": "textPasteConfigurationSupporting(_:transform:)",
    "kind": "Instance Method",
    "offset": 365487,
    "length": 423,
    "sourcetext": " func textPasteConfigurationSupporting(_ textPasteConfigurationSupporting: UITextPasteConfigurationSupporting, transform item: UITextPasteItem) {\n            guard let textField = textPasteConfigurationSupporting as? UITextField else { return }\n            \n            guard let result = textPasteConfiguration?(textField) else { return item.setNoResult() }\n            \n            item.setResult(string: result)\n        "
  },
  {
    "name": "canPerformAction(_:withSender:)",
    "kind": "Instance Method",
    "offset": 365992,
    "length": 332,
    "sourcetext": " func canPerformAction(_ action: Selector, withSender sender: Any?) -> Bool {\n        guard\n            action != #selector(paste(_:)),\n            action != #selector(copy(_:)),\n            action != #selector(cut(_:)) else {\n            return false\n        }\n        return super.canPerformAction(action, withSender: sender)\n    "
  },
  {
    "name": "setNaturalTextAlignment()",
    "kind": "Instance Method",
    "offset": 366491,
    "length": 85,
    "sourcetext": " func setNaturalTextAlignment() {\n        textAlignment = isRTL ? .right : .left\n    "
  },
  {
    "name": "setNaturalInvertedTextAlignment()",
    "kind": "Instance Method",
    "offset": 366589,
    "length": 93,
    "sourcetext": " func setNaturalInvertedTextAlignment() {\n        textAlignment = isRTL ? .left : .right\n    "
  },
  {
    "name": "init(type:)",
    "kind": "Instance Method",
    "offset": 368617,
    "length": 118,
    "sourcetext": " init(type: ViewControllerType = .usual) {\n        self.type = type\n        super.init(nibName: nil, bundle: nil)\n    "
  },
  {
    "name": "init(coder:)",
    "kind": "Instance Method",
    "offset": 368750,
    "length": 89,
    "sourcetext": " init?(coder: NSCoder) {\n        fatalError(\"init(coder:) has not been implemented\")\n    "
  },
  {
    "name": "viewDidLoad()",
    "kind": "Instance Method",
    "offset": 368861,
    "length": 589,
    "sourcetext": " func viewDidLoad() {\n        super.viewDidLoad()\n\n        view.addSubview(label)\n        view.addSubview(loadingView)\n\n        view.backgroundColor = .black.withAlphaComponent(Constants.opacity)\n\n        loadingView.snp.makeConstraints {\n            $0.centerX.equalToSuperview()\n        }\n\n        label.snp.makeConstraints {\n            $0.top.equalTo(loadingView.snp.bottom).offset(Constants.labelTop)\n            $0.centerX.equalToSuperview()\n            $0.centerY.equalToSuperview().offset(type.labelCenterYOffset)\n            $0.height.equalTo(Constants.labelHeight)\n        }\n    "
  },
  {
    "name": "init()",
    "kind": "Instance Method",
    "offset": 369936,
    "length": 71,
    "sourcetext": " init() {\n        lastReviewedDate = UserDefaults.lastReviewedDate\n    "
  },
  {
    "name": "navigate(to:)",
    "kind": "Instance Method",
    "offset": 371618,
    "length": 50,
    "sourcetext": " func navigate(to destination: DeeplinkDestination"
  },
  {
    "name": "currentLanguage()",
    "kind": "Static Method",
    "offset": 372629,
    "length": 119,
    "sourcetext": " static func currentLanguage() -> AppLanguage {\n        return LocaleSelector.shared.isArabic ? .arabic : .english\n    "
  },
  {
    "name": "clearLocalData()",
    "kind": "Instance Method",
    "offset": 373721,
    "length": 21,
    "sourcetext": " func clearLocalData("
  },
  {
    "name": "init(rawValue:)",
    "kind": "Instance Method",
    "offset": 373894,
    "length": 271,
    "sourcetext": " init?(rawValue: String) {\n            switch rawValue {\n            case Self.default.rawValue: self = .default\n            case Self.youth.rawValue: self = .youth\n            case Self.expat.rawValue: self = .expat\n            default: return nil\n            }\n        "
  },
  {
    "name": "init(rawValue:)",
    "kind": "Instance Method",
    "offset": 374342,
    "length": 351,
    "sourcetext": " init?(rawValue: String) {\n            switch rawValue {\n            case Self.exchange.rawValue: self = .exchange\n            case Self.transactions.rawValue: self = .transactions\n            case Self.addMoney.rawValue: self = .addMoney\n            case Self.discover.rawValue: self = .discover\n            default: return nil\n            }\n        "
  },
  {
    "name": "init(rawValue:)",
    "kind": "Instance Method",
    "offset": 374913,
    "length": 672,
    "sourcetext": " init?(rawValue: String) {\n            switch rawValue {\n            case Self.openBanking.rawValue: self = .openBanking\n            case Self.mcdcBanner.rawValue: self = .mcdcBanner\n            case Self.microfinanceBanner.rawValue: self = .microfinanceBanner\n            case Self.loyalty.rawValue: self = .loyalty\n            case Self.marketplace.rawValue: self = .marketplace\n            case let value where value.hasPrefix(\"de_dashboard_\"):\n                guard let slot = Self.getEngageBannerSlot(from: value) else {\n                    return nil\n                }\n                self = .engageBanner(slot)\n            default: return nil\n            }\n        "
  },
  {
    "name": "getEngageBannerSlot(from:)",
    "kind": "Static Method",
    "offset": 375982,
    "length": 268,
    "sourcetext": " static func getEngageBannerSlot(from spaceId: String) -> Int? {\n            guard let slotString = spaceId.components(separatedBy: \"_\").last,\n                  let slot = Int(slotString) else {\n                return nil\n            }\n            return slot\n        "
  },
  {
    "name": "init(rawValue:)",
    "kind": "Instance Method",
    "offset": 376463,
    "length": 391,
    "sourcetext": " init?(rawValue: String) {\n            switch rawValue {\n            case Self.cards.rawValue: self = .cards\n            case Self.transfersHub.rawValue: self = .transfersHub\n            case Self.dashboard.rawValue: self = .dashboard\n            case Self.bills.rawValue: self = .bills\n            case Self.more.rawValue: self = .more\n            default: return nil\n            }\n        "
  },
  {
    "name": "buildEntryPointForGames()",
    "kind": "Instance Method",
    "offset": 377430,
    "length": 51,
    "sourcetext": " func buildEntryPointForGames() -> UIViewController"
  },
  {
    "name": "buildEntryPointForHealth()",
    "kind": "Instance Method",
    "offset": 377486,
    "length": 52,
    "sourcetext": " func buildEntryPointForHealth() -> UIViewController"
  },
  {
    "name": "buildEntryPointForLightUserGame()",
    "kind": "Instance Method",
    "offset": 377543,
    "length": 59,
    "sourcetext": " func buildEntryPointForLightUserGame() -> UIViewController"
  },
  {
    "name": "navigateToLeaderboardJoin(withInvitationCode:)",
    "kind": "Instance Method",
    "offset": 377607,
    "length": 79,
    "sourcetext": " func navigateToLeaderboardJoin(withInvitationCode: String) -> UIViewController"
  },
  {
    "name": "validate(_:currencyCode:)",
    "kind": "Instance Method",
    "offset": 384263,
    "length": 91,
    "sourcetext": " func validate(_: String?, currencyCode: String) -> Result<Void, AmountFieldValidator.Error"
  },
  {
    "name": "init()",
    "kind": "Instance Method",
    "offset": 384436,
    "length": 9,
    "sourcetext": " init() {"
  },
  {
    "name": "validate(_:currencyCode:)",
    "kind": "Instance Method",
    "offset": 384623,
    "length": 440,
    "sourcetext": " func validate(_ valueText: String?, currencyCode: String) -> Result<Void, Error> {\n        let firstError = checks(forText: valueText, currencyCode: currencyCode).first(where: {\n            if case .failure = $0 {\n                return true\n            } else {\n                return false\n            }\n        })\n\n        if let firstError {\n            return firstError\n        } else {\n            return .success(())\n        }\n    "
  },
  {
    "name": "checks(forText:currencyCode:)",
    "kind": "Instance Method",
    "offset": 385112,
    "length": 271,
    "sourcetext": " func checks(forText text: String?, currencyCode: String) -> [Result<Void, Error>] {\n        return [\n            checkForMultipleDecimalSeparators,\n            checkForAmountOfDecimalDigits,\n            checkForDecimalNumber\n        ].map { $0(text, currencyCode) }\n    "
  },
  {
    "name": "init(tokenType:)",
    "kind": "Instance Method",
    "offset": 388485,
    "length": 69,
    "sourcetext": " init(tokenType: TokenType) {\n        self.tokenType = tokenType\n    "
  },
  {
    "name": "delete()",
    "kind": "Instance Method",
    "offset": 389225,
    "length": 189,
    "sourcetext": " func delete() throws {\n        let status = SecItemDelete(baseDictionary as CFDictionary)\n        guard status != errSecItemNotFound else { return }\n        try throwIfNotZero(status)\n    "
  },
  {
    "name": "read()",
    "kind": "Instance Method",
    "offset": 389428,
    "length": 508,
    "sourcetext": " func read() throws -> String? {\n        let query = self.query.adding(key: kSecReturnData as String, value: true as AnyObject)\n        var result: AnyObject?\n        let status = SecItemCopyMatching(query as CFDictionary, &result)\n        guard status != errSecItemNotFound else { return nil }\n        try throwIfNotZero(status)\n        guard let data = result as? Data, let string = String(data: data, encoding: .utf8) else {\n            throw KeychainError.invalidData\n        }\n        return string\n    "
  },
  {
    "name": "update(_:)",
    "kind": "Instance Method",
    "offset": 389950,
    "length": 296,
    "sourcetext": " func update(_ secret: String) throws {\n        let dictionary: [String: AnyObject] = [\n            kSecValueData as String: secret.data(using: String.Encoding.utf8)! as AnyObject\n        ]\n        try throwIfNotZero(SecItemUpdate(baseDictionary as CFDictionary, dictionary as CFDictionary))\n    "
  },
  {
    "name": "add(_:)",
    "kind": "Instance Method",
    "offset": 390260,
    "length": 238,
    "sourcetext": " func add(_ secret: String) throws {\n        let dictionary = baseDictionary.adding(key: kSecValueData as String, value: secret.data(using: .utf8)! as AnyObject)\n        try throwIfNotZero(SecItemAdd(dictionary as CFDictionary, nil))\n    "
  },
  {
    "name": "throwIfNotZero(_:)",
    "kind": "Free Function",
    "offset": 390717,
    "length": 142,
    "sourcetext": " func throwIfNotZero(_ status: OSStatus) throws {\n    guard status != 0 else { return }\n    throw KeychainError.keychainError(status: status)\n"
  },
  {
    "name": "init()",
    "kind": "Instance Method",
    "offset": 392279,
    "length": 44,
    "sourcetext": " init() {\n        self.attributes = [:]\n    "
  },
  {
    "name": "font(_:)",
    "kind": "Instance Method",
    "offset": 392336,
    "length": 94,
    "sourcetext": " func font(_ font: UIFont) -> Self {\n        attributes[.font] = font\n        return self\n    "
  },
  {
    "name": "foregroundColor(_:)",
    "kind": "Instance Method",
    "offset": 392443,
    "length": 119,
    "sourcetext": " func foregroundColor(_ color: UIColor) -> Self {\n        attributes[.foregroundColor] = color\n        return self\n    "
  },
  {
    "name": "paragraphStyle(font:lineHeight:textAlignment:minimumLineHeight:)",
    "kind": "Instance Method",
    "offset": 392575,
    "length": 639,
    "sourcetext": " func paragraphStyle(\n        font: UIFont,\n        lineHeight: Double? = nil,\n        textAlignment: NSTextAlignment? = nil,\n        minimumLineHeight: CGFloat? = nil\n    ) -> Self {\n        let paragraphStyle = NSMutableParagraphStyle()\n        if let textAlignment {\n            paragraphStyle.alignment = textAlignment\n        }\n        if let lineHeight {\n            paragraphStyle.lineSpacing = lineHeight - font.lineHeight\n        }\n        if let minimumLineHeight {\n            paragraphStyle.minimumLineHeight = minimumLineHeight\n        }\n        attributes[.paragraphStyle] = paragraphStyle\n        return self.font(font)\n    "
  },
  {
    "name": "build(text:)",
    "kind": "Instance Method",
    "offset": 393227,
    "length": 119,
    "sourcetext": " func build(text: String) -> NSAttributedString {\n        NSAttributedString(string: text, attributes: attributes)\n    "
  },
  {
    "name": "init()",
    "kind": "Instance Method",
    "offset": 393825,
    "length": 9,
    "sourcetext": " init() {"
  },
  {
    "name": "jwtValue(key:)",
    "kind": "Instance Method",
    "offset": 393847,
    "length": 136,
    "sourcetext": " func jwtValue(key: String) -> Any? {\n        guard let decodedJwt = jwtDecode() else { return nil }\n        return decodedJwt[key]\n    "
  },
  {
    "name": "jwtDecode()",
    "kind": "Instance Method",
    "offset": 393997,
    "length": 977,
    "sourcetext": " func jwtDecode() -> [String: Any]? {\n\n        let tokens = Backbase.authClient().tokens()\n        if tokens.count > 0 && tokens[authorizationKey] != nil, let token = tokens[authorizationKey] {\n            let tokenSplit: [String] = token.components(separatedBy: \".\")\n            guard tokenSplit.indices.contains(1) else {\n                return nil\n            }\n\n            var tokenBody = tokenSplit[1]\n            if tokenBody.count % 4 != 0 {\n                let padlen = 4 - tokenBody.count % 4\n                tokenBody.append(contentsOf: repeatElement(\"=\", count: padlen))\n            }\n            guard let data = Data(base64Encoded: tokenBody) else {\n                return nil\n            }\n\n            do {\n                let decodedJson = try JSONSerialization.jsonObject(with: data, options: .allowFragments) as? [String: Any]\n                return decodedJson\n            } catch {\n                return nil\n            }\n        }\n        return nil\n    "
  },
  {
    "name": "configure(_:with:)",
    "kind": "Free Function",
    "offset": 395796,
    "length": 135,
    "sourcetext": " func configure<T>(_ object: T, with closure: (inout T) -> Void) -> T {\n    var object = object\n    closure(&object)\n    return object\n"
  },
  {
    "name": "backgroundViewStyle()",
    "kind": "Instance Method",
    "offset": 398367,
    "length": 119,
    "sourcetext": " func backgroundViewStyle() -> some View {\n        background(DesignSystem.shared.colors.foundation.default.color)\n    "
  },
  {
    "name": "contentViewStyle()",
    "kind": "Instance Method",
    "offset": 398492,
    "length": 314,
    "sourcetext": " func contentViewStyle() -> some View {\n        cornerRadius(DesignSystem.shared.cornerRadius.large)\n            .background(DesignSystem.shared.colors.surfacePrimary.default.color\n                .cornerRadius(DesignSystem.shared.cornerRadius.large)\n                .customShadow(style: .small)\n            )\n    "
  },
  {
    "name": "updateVPNStatusCompletion(completion:)",
    "kind": "Instance Method",
    "offset": 399803,
    "length": 68,
    "sourcetext": " func updateVPNStatusCompletion(completion: @escaping (Bool) -> Void"
  },
  {
    "name": "updateNetworkStatusCompletion(completion:)",
    "kind": "Instance Method",
    "offset": 399876,
    "length": 72,
    "sourcetext": " func updateNetworkStatusCompletion(completion: @escaping (Bool) -> Void"
  },
  {
    "name": "init(wrappedValue:in:)",
    "kind": "Instance Method",
    "offset": 400568,
    "length": 133,
    "sourcetext": " init(wrappedValue: String, in bundles: Bundle?...) {\n            self.wrappedValue = wrappedValue.getLocalized(in: bundles)\n        "
  },
  {
    "name": "localized(in:attributes:)",
    "kind": "Instance Method",
    "offset": 400741,
    "length": 153,
    "sourcetext": " func localized(in bundles: Bundle?..., attributes: CVarArg...) -> String {\n        String(format: getLocalized(in: bundles), arguments: attributes)\n    "
  },
  {
    "name": "localized(in:)",
    "kind": "Instance Method",
    "offset": 400907,
    "length": 90,
    "sourcetext": " func localized(in bundles: Bundle?...) -> String {\n        getLocalized(in: bundles)\n    "
  },
  {
    "name": "getLocalized(in:)",
    "kind": "Instance Method",
    "offset": 401015,
    "length": 400,
    "sourcetext": " func getLocalized(in bundles: [Bundle?]) -> String {\n        let bundles = ([.main] + bundles).compactMap { $0 }\n        return bundles\n            .compactMap { bundle -> String? in\n                let localizedString = bundle.localizedString(forKey: self, value: self, table: nil)\n                return localizedString == self ? nil : localizedString\n            }\n            .first ?? self\n    "
  },
  {
    "name": "toUnwrapped(defaultValue:)",
    "kind": "Instance Method",
    "offset": 401775,
    "length": 206,
    "sourcetext": " func toUnwrapped<T>(defaultValue: T) -> Binding<T> where Value == T? {\n        Binding<T>(\n            get: { self.wrappedValue ?? defaultValue },\n            set: { self.wrappedValue = $0 }\n        )\n    "
  },
  {
    "name": "dismissKeyboard()",
    "kind": "Instance Method",
    "offset": 402390,
    "length": 145,
    "sourcetext": " func dismissKeyboard() {\n        UIApplication.shared.sendAction(#selector(UIResponder.resignFirstResponder), to: nil, from: nil, for: nil)\n    "
  },
  {
    "name": "setText(_:lineHeight:textColor:font:textAlignment:)",
    "kind": "Instance Method",
    "offset": 403580,
    "length": 510,
    "sourcetext": " func setText(\n        _ text: String, lineHeight: CGFloat = 20,\n        textColor: UIColor? = nil, font: UIFont? = nil,\n        textAlignment: NSTextAlignment? = nil\n    ) {\n        attributedText = AttributedStringBuilder()\n            .foregroundColor(textColor ?? self.textColor)\n            .paragraphStyle(\n                font: font ?? self.font,\n                lineHeight: lineHeight,\n                textAlignment: textAlignment ?? self.textAlignment\n            )\n            .build(text: text)\n    "
  },
  {
    "name": "setInvertedNaturalTextAlignment()",
    "kind": "Instance Method",
    "offset": 404245,
    "length": 93,
    "sourcetext": " func setInvertedNaturalTextAlignment() {\n        textAlignment = isRTL ? .left : .right\n    "
  },
  {
    "name": "setNaturalTextAlignment()",
    "kind": "Instance Method",
    "offset": 404344,
    "length": 85,
    "sourcetext": " func setNaturalTextAlignment() {\n        textAlignment = isRTL ? .right : .left\n    "
  },
  {
    "name": "setText(_:lineHeight:textColor:font:textAlignment:)",
    "kind": "Instance Method",
    "offset": 404467,
    "length": 923,
    "sourcetext": " func setText(\n        _ text: String, lineHeight: CGFloat = 20,\n        textColor: UIColor? = nil, font: UIFont? = nil,\n        textAlignment: NSTextAlignment? = nil\n    ) {\n        var stringAttributes: [NSAttributedString.Key: Any] = [:]\n        stringAttributes[.foregroundColor] = textColor ?? self.textColor\n        let currentFont: UIFont? = font ?? self.font\n        let alignment: NSTextAlignment? = textAlignment ?? self.textAlignment\n        if let currentFont {\n            let paragraphStyle = NSMutableParagraphStyle()\n            if let alignment {\n                paragraphStyle.alignment = alignment\n            }\n            paragraphStyle.lineSpacing = lineHeight - currentFont.lineHeight\n            stringAttributes[.paragraphStyle] = paragraphStyle\n            stringAttributes[.font] = currentFont\n        }\n        attributedText = NSAttributedString(string: text, attributes: stringAttributes)\n    "
  },
  {
    "name": "search(in:by:on:)",
    "kind": "Instance Method",
    "offset": 405816,
    "length": 785,
    "sourcetext": " func search<T>(\n        in array: [T],\n        by keyPaths: [KeyPath<T, String>],\n        on event: UIControl.Event = .editingChanged\n    ) -> AnyPublisher<[T], Never> {\n        publisher(for: event)\n            .compactMap { searchTextField in\n                guard let query = searchTextField.text, !query.isEmpty else {\n                    return array\n                }\n                for path in keyPaths {\n                    let filteredArray = array.filter {\n                        $0[keyPath: path].localizedCaseInsensitiveContains(query)\n                    }\n                    if !filteredArray.isEmpty {\n                        return filteredArray\n                    }\n                }\n                return []\n            }\n            .eraseToAnyPublisher()\n    "
  },
  {
    "name": "hasNoResults(_:)",
    "kind": "Instance Method",
    "offset": 406607,
    "length": 365,
    "sourcetext": " func hasNoResults<T>(_ filteredList: AnyPublisher<[T], Never>) -> AnyPublisher<Bool, Never> {\n        Publishers.CombineLatest(\n            filteredList,\n            publisher(for: .editingChanged).map { $0.text ?? \"\" }\n        )\n        .map { items, searchText in items.isEmpty && !searchText.isEmpty }\n        .prepend(false)\n        .eraseToAnyPublisher()\n    "
  },
  {
    "name": "viewDidLoad()",
    "kind": "Instance Method",
    "offset": 407489,
    "length": 111,
    "sourcetext": " func viewDidLoad() {\n        super.viewDidLoad()\n        interactivePopGestureRecognizer?.delegate = self\n    "
  },
  {
    "name": "gestureRecognizerShouldBegin(_:)",
    "kind": "Instance Method",
    "offset": 407613,
    "length": 353,
    "sourcetext": " func gestureRecognizerShouldBegin(_ gestureRecognizer: UIGestureRecognizer) -> Bool {\n        let isContainMultipleVC = viewControllers.count > 1\n        if let visibleVC = visibleViewController as? InteractivePopGestureProtocol {\n            return isContainMultipleVC && visibleVC.isPopGestureEnabled\n        }\n        return isContainMultipleVC\n    "
  },
  {
    "name": "displayToast(_:with:)",
    "kind": "Instance Method",
    "offset": 409051,
    "length": 2357,
    "sourcetext": " func displayToast(_ message: String, with delay: Int) {\n        guard let window: UIWindow = UIApplication.shared.delegate?.window ?? nil else {\n            return\n        }\n\n        let padding = 10.0\n        let cornerRadius = 4.0\n        let backgroundAlpha = 0.79\n        let topOffset = 200\n        let bottomOffset = -100\n        let toastViewTag = -2021\n\n        if let toast = window.subviews.first(where: { $0.tag == toastViewTag }) {\n            toast.removeFromSuperview()\n        }\n\n        let toastView = UIView()\n        window.addSubview(toastView)\n        toastView.backgroundColor = DesignSystem.shared.colors.highlight.foundation.withAlphaComponent(backgroundAlpha)\n        toastView.layer.cornerRadius = cornerRadius\n        toastView.alpha = 0\n        toastView.tag = toastViewTag\n\n        let messageLabel = UILabel()\n        messageLabel.textColor = DesignSystem.shared.colors.neutrals.neutral00\n        messageLabel.textAlignment = .center\n        messageLabel.font = DesignSystem.shared.fonts.preferredFont(.footnote, .regular)\n        messageLabel.text = message\n        messageLabel.numberOfLines = 0\n        toastView.addSubview(messageLabel)\n\n        toastView.snp.makeConstraints { make in\n            make.centerX.equalToSuperview()\n            make.leading.greaterThanOrEqualToSuperview().offset(padding)\n            make.trailing.lessThanOrEqualToSuperview().offset(padding)\n            make.top.greaterThanOrEqualToSuperview().offset(topOffset)\n            make.bottom.equalToSuperview().offset(bottomOffset)\n        }\n\n        messageLabel.snp.makeConstraints { make in\n            make.leading.equalToSuperview().offset(padding)\n            make.trailing.equalToSuperview().offset(-padding)\n            make.top.bottom.equalToSuperview().inset(padding)\n            make.width.lessThanOrEqualToSuperview().offset(-padding * 2)\n        }\n\n        UIView.animate(withDuration: 0.5, delay: 0, options: .curveEaseIn, animations: {\n            toastView.alpha = 1\n        }, completion: nil)\n\n        DispatchQueue.main.asyncAfter(deadline: .now() + .seconds(delay), execute: {\n            UIView.animate(withDuration: 0.5, delay: 0, options: .curveEaseIn, animations: {\n                toastView.alpha = 0\n            }, completion: { finished in\n                toastView.removeFromSuperview()\n            })\n        })\n    "
  },
  {
    "name": "halfSheetPresentation(cornerRadius:heightRatio:isGrabberVisible:)",
    "kind": "Instance Method",
    "offset": 411859,
    "length": 561,
    "sourcetext": " func halfSheetPresentation(cornerRadius: CGFloat = 24, heightRatio: CGFloat = 0.55, isGrabberVisible: Bool = false) {\n        guard let presentation = sheetPresentationController else { return }\n\n        presentation.preferredCornerRadius = cornerRadius\n        presentation.prefersGrabberVisible = isGrabberVisible\n        if #available(iOS 16.0, *) {\n            presentation.detents = [.custom { context in\n                context.maximumDetentValue * heightRatio\n            }]\n        } else {\n            presentation.detents = [.medium()]\n        }\n    "
  },
  {
    "name": "post(_:)",
    "kind": "Instance Method",
    "offset": 414758,
    "length": 107,
    "sourcetext": " func post(_ object: Any? = nil) {\n        NotificationCenter.default.post(name: self, object: object)\n    "
  },
  {
    "name": "observe(_:queue:callback:)",
    "kind": "Instance Method",
    "offset": 414911,
    "length": 201,
    "sourcetext": " func observe(_ name: Notification.Name, queue: OperationQueue = .main, callback: @escaping (Notification) -> Void) {\n        addObserver(forName: name, object: nil, queue: queue) { callback($0) }\n    "
  },
  {
    "name": "post(_:object:userInfo:)",
    "kind": "Instance Method",
    "offset": 415118,
    "length": 162,
    "sourcetext": " func post(_ name: Notification.Name, object: Any? = nil, userInfo: [AnyHashable: Any]? = nil) {\n        post(name: name, object: object, userInfo: userInfo)\n    "
  },
  {
    "name": "draggablePresentation()",
    "kind": "Instance Method",
    "offset": 415740,
    "length": 138,
    "sourcetext": " func draggablePresentation() -> some View {\n        modifier(DragHandleModifier())\n            .modifier(AdaptsToKeyboardModifier())\n    "
  },
  {
    "name": "body(content:)",
    "kind": "Instance Method",
    "offset": 415936,
    "length": 235,
    "sourcetext": " func body(content: Content) -> some View {\n        VStack(spacing: DesignSystem.shared.spacer.md) {\n            dragHandleView\n            content\n        }\n        .background(DesignSystem.shared.colors.foundation.default.color)\n    "
  },
  {
    "name": "body(content:)",
    "kind": "Instance Method",
    "offset": 416624,
    "length": 1254,
    "sourcetext": " func body(content: Content) -> some View {\n        GeometryReader { geometry in\n            content\n                .padding(.bottom, currentHeight)\n                .onAppear {\n                    NotificationCenter.Publisher(center: .default, name: UIResponder.keyboardWillShowNotification)\n                        .merge(with: NotificationCenter.Publisher(center: .default, name: UIResponder.keyboardWillChangeFrameNotification))\n                        .compactMap { notification in\n                            notification.userInfo?[UIResponder.keyboardFrameEndUserInfoKey] as? CGRect\n                        }\n                        .map { rect in\n                            rect.height - geometry.safeAreaInsets.bottom\n                        }\n                        .subscribe(Subscribers.Assign(object: self, keyPath: \\.currentHeight))\n\n                    NotificationCenter.Publisher(center: .default, name: UIResponder.keyboardWillHideNotification)\n                        .compactMap { _ in .zero }\n                        .subscribe(Subscribers.Assign(object: self, keyPath: \\.currentHeight))\n                }\n                .animation(.easeOut(duration: 0.15), value: currentHeight)\n        }\n        .ignoresSafeArea(.keyboard)\n    "
  },
  {
    "name": "topMostViewController()",
    "kind": "Instance Method",
    "offset": 418300,
    "length": 443,
    "sourcetext": " func topMostViewController() -> UIViewController? {\n        var topViewController: UIViewController?\n        for scene in connectedScenes {\n            if let windowScene = scene as? UIWindowScene {\n                for window in windowScene.windows where window.isKeyWindow {\n                    topViewController = window.rootViewController\n                }\n            }\n        }\n        return topViewController?.topViewController()\n    "
  },
  {
    "name": "dismissAllControllers()",
    "kind": "Instance Method",
    "offset": 418749,
    "length": 630,
    "sourcetext": " func dismissAllControllers() {\n        var topViewController: UIViewController?\n        for scene in connectedScenes {\n            if let windowScene = scene as? UIWindowScene {\n                for window in windowScene.windows where window.isKeyWindow {\n                    topViewController = window.rootViewController\n                }\n            }\n        }\n        if let navigation = topViewController as? UINavigationController {\n            navigation.dismissIfPresented()\n            navigation.popToRootViewController(animated: false)\n        } else {\n            topViewController?.dismissIfPresented()\n        }\n    "
  },
  {
    "name": "findViewController(to:)",
    "kind": "Instance Method",
    "offset": 419385,
    "length": 1410,
    "sourcetext": " func findViewController<T>(to viewControllerType: T.Type) -> UIViewController? {\n        var viewControllerToFind: UIViewController?\n        for scene in connectedScenes {\n            if let windowScene = scene as? UIWindowScene {\n                for window in windowScene.windows where window.isKeyWindow {\n\n                    // UITabBarController\n                    if let tabbar = window.rootViewController as? UITabBarController {\n                        if let viewController = (tabbar.selectedViewController as? UINavigationController)?.viewControllers.first(\n                            where: {type(of: $0) == viewControllerType\n                            }) {\n                            viewControllerToFind = viewController\n                        }\n                    }\n                    // UINavigationController\n                    else if let navigation = window.rootViewController as? UINavigationController {\n                        if let viewController = navigation.viewControllers.first(\n                            where: {type(of: $0) == viewControllerType}) {\n                            viewControllerToFind = viewController\n                        }\n                    } else {\n                        viewControllerToFind = window.rootViewController?.topViewController()\n                    }\n                }\n            }\n        }\n        return viewControllerToFind\n    "
  },
  {
    "name": "topViewController()",
    "kind": "Instance Method",
    "offset": 421234,
    "length": 629,
    "sourcetext": " func topViewController() -> UIViewController? {\n        if self.presentedViewController == nil {\n            return self\n        }\n        if let navigation = self.presentedViewController as? UINavigationController {\n            return navigation.visibleViewController?.topViewController()\n        }\n        if let tab = self.presentedViewController as? UITabBarController {\n            if let selectedTab = tab.selectedViewController {\n                return selectedTab.topViewController()\n            }\n            return tab.topViewController()\n        }\n        return self.presentedViewController?.topViewController()\n    "
  },
  {
    "name": "dismissIfPresented()",
    "kind": "Instance Method",
    "offset": 421912,
    "length": 65,
    "sourcetext": " func dismissIfPresented() {\n        dismiss(animated: true)\n    "
  },
  {
    "name": "popIfPushed()",
    "kind": "Instance Method",
    "offset": 421994,
    "length": 90,
    "sourcetext": " func popIfPushed() {\n        navigationController?.popViewController(animated: true)\n    "
  },
  {
    "name": "closeBarButtonItem(image:)",
    "kind": "Instance Method",
    "offset": 422126,
    "length": 201,
    "sourcetext": " func closeBarButtonItem(image: UIImage?) -> UIBarButtonItem {\n        return UIBarButtonItem(image: image, style: .plain,\n                     target: self, action: #selector(dismissIfPresented))\n    "
  },
  {
    "name": "backBarButtonItem(image:)",
    "kind": "Instance Method",
    "offset": 422368,
    "length": 202,
    "sourcetext": " func backBarButtonItem(image: UIImage?) -> UIBarButtonItem {\n        return UIBarButtonItem(image: image, style: .plain,\n                              target: self, action: #selector(popIfPushed))\n    "
  },
  {
    "name": "init(title:action:)",
    "kind": "Instance Method",
    "offset": 422713,
    "length": 125,
    "sourcetext": " init(title: String, action: @escaping () -> Void) {\n            self.title = title\n            self.action = action\n        "
  },
  {
    "name": "presentActionSheet(title:message:actions:cancel:)",
    "kind": "Instance Method",
    "offset": 422850,
    "length": 586,
    "sourcetext": " func presentActionSheet(\n        title: String? = nil,\n        message: String? = nil,\n        actions: ActionableTitle...,\n        cancel: String\n    ) {\n        let alert = UIAlertController(title: title, message: message, preferredStyle: .actionSheet)\n        actions.forEach { actionableTitle in\n            alert.addAction(UIAlertAction(title: actionableTitle.title, style: .default, handler: { _ in\n                actionableTitle.action()\n            }))\n        }\n        alert.addAction(UIAlertAction(title: cancel, style: .cancel))\n        present(alert, animated: true)\n    "
  },
  {
    "name": "add(_:)",
    "kind": "Instance Method",
    "offset": 423480,
    "length": 141,
    "sourcetext": " func add(_ child: UIViewController) {\n        addChild(child)\n        view.addSubview(child.view)\n        child.didMove(toParent: self)\n    "
  },
  {
    "name": "remove()",
    "kind": "Instance Method",
    "offset": 423627,
    "length": 180,
    "sourcetext": " func remove() {\n        guard parent != nil else {\n            return\n        }\n\n        willMove(toParent: nil)\n        view.removeFromSuperview()\n        removeFromParent()\n    "
  },
  {
    "name": "addSupportButtonView()",
    "kind": "Instance Method",
    "offset": 423851,
    "length": 530,
    "sourcetext": " func addSupportButtonView() {\n        let supportButton = SupportButton()\n        view.addSubview(supportButton)\n        let action = UIAction { _ in\n            Resolver.optional(DeeplinkNavigatable.self)?.navigate(to: .support)\n        }\n        supportButton.addAction(action, for: .touchUpInside)\n        supportButton.snp.makeConstraints {\n            $0.trailing.equalTo(view.safeAreaLayoutGuide).inset(SupportButtonConfiguration.Constants().viewTrailing)\n            $0.top.equalTo(view.safeAreaLayoutGuide)\n        }\n    "
  },
  {
    "name": "removeLargeTitlesForNavBar()",
    "kind": "Instance Method",
    "offset": 424425,
    "length": 112,
    "sourcetext": " func removeLargeTitlesForNavBar() {\n        navigationController?.navigationBar.prefersLargeTitles = false\n    "
  },
  {
    "name": "backBarButton()",
    "kind": "Instance Method",
    "offset": 424581,
    "length": 491,
    "sourcetext": " func backBarButton() -> UIBarButtonItem? {\n        if let leftBarButtonItem = navigationItem.leftBarButtonItem {\n            return leftBarButtonItem\n        }\n        if #available(iOS 16.0, *),\n           let backButton = navigationItem.leadingItemGroups.first?.barButtonItems.first {\n            return backButton\n        }\n        if let backButton = navigationItem.backBarButtonItem {\n            return backButton\n        }\n        return navigationItem.leftBarButtonItems?.first\n    "
  },
  {
    "name": "applyShadow(color:opacity:x:y:blur:)",
    "kind": "Instance Method",
    "offset": 426021,
    "length": 469,
    "sourcetext": " func applyShadow(\n        color: UIColor = DesignSystem.shared.colors.surfacePrimary.default,\n        opacity: Float = 0.12,\n        x: CGFloat = 0,\n        y: CGFloat = 4,\n        blur: CGFloat = 9\n    ) {\n        shadowColor = color.cgColor\n        shadowOpacity = opacity\n        shadowOffset = CGSize(width: x, height: y)\n        shadowRadius = blur\n        shouldRasterize = true\n        rasterizationScale = UIScreen.main.scale\n        masksToBounds = false\n    "
  },
  {
    "name": "substring(_:)",
    "kind": "Instance Method",
    "offset": 426880,
    "length": 568,
    "sourcetext": " func substring(_ range: Range<Int>) -> String? {\n        guard range.lowerBound >= 0,\n              range.lowerBound < range.upperBound else { return nil }\n        let startIndex = index(self.startIndex, offsetBy: range.lowerBound)\n        let limitIndex = index(self.startIndex, offsetBy: count)\n        guard let endIndex = index(\n            self.startIndex,\n            offsetBy: range.upperBound,\n            limitedBy: limitIndex\n        ) else {\n            return nil\n        }\n        let range = startIndex..<endIndex\n        return String(self[range])\n    "
  },
  {
    "name": "formatter(for:)",
    "kind": "Static Method",
    "offset": 428610,
    "length": 177,
    "sourcetext": " static func formatter(for dateFormat: String) -> DateFormatter {\n        let formatter = DateFormatter()\n        formatter.dateFormat = dateFormat\n        return formatter\n    "
  },
  {
    "name": "onKeyboardVisibilityChanged(perform:)",
    "kind": "Instance Method",
    "offset": 429648,
    "length": 143,
    "sourcetext": " func onKeyboardVisibilityChanged(perform: @escaping (Bool) -> Void) -> some View {\n        onReceive(keyboardPublisher, perform: perform)\n    "
  },
  {
    "name": "bindWithKeyboardVisibility(bindable:)",
    "kind": "Instance Method",
    "offset": 429797,
    "length": 140,
    "sourcetext": " func bindWithKeyboardVisibility(bindable: Binding<Bool>) -> some View {\n        modifier(KeyboardObserverModifier(bindable: bindable))\n    "
  },
  {
    "name": "body(content:)",
    "kind": "Instance Method",
    "offset": 430026,
    "length": 124,
    "sourcetext": " func body(content: Content) -> some View {\n        content\n            .onKeyboardVisibilityChanged { bindable = !$0 }\n    "
  },
  {
    "name": "isRTL(for:)",
    "kind": "Static Method",
    "offset": 430509,
    "length": 182,
    "sourcetext": " static func isRTL(for semanticContentAttribute: UISemanticContentAttribute) -> Bool {\n        UIView.userInterfaceLayoutDirection(for: semanticContentAttribute) == .rightToLeft\n    "
  },
  {
    "name": "publisher(for:)",
    "kind": "Instance Method",
    "offset": 431286,
    "length": 137,
    "sourcetext": " func publisher(for events: UIControl.Event) -> UIControlPublisher<Self> {\n        UIControlPublisher(control: self, events: events)\n    "
  },
  {
    "name": "init(control:events:)",
    "kind": "Instance Method",
    "offset": 431708,
    "length": 122,
    "sourcetext": " init(control: Control, events: UIControl.Event) {\n        self.control = control\n        self.controlEvents = events\n    "
  },
  {
    "name": "receive(subscriber:)",
    "kind": "Instance Method",
    "offset": 431843,
    "length": 401,
    "sourcetext": " func receive<S>(subscriber: S) where S: Subscriber,\n                                                S.Failure == UIControlPublisher.Failure,\n                                                S.Input == UIControlPublisher.Output {\n        let subscription = UIControlSubscription(subscriber: subscriber, control: control, event: controlEvents)\n        subscriber.receive(subscription: subscription)\n    "
  },
  {
    "name": "init(subscriber:control:event:)",
    "kind": "Instance Method",
    "offset": 432528,
    "length": 227,
    "sourcetext": " init(subscriber: SubscriberType, control: Control, event: UIControl.Event) {\n        self.subscriber = subscriber\n        self.control = control\n        control.addTarget(self, action: #selector(eventHandler), for: event)\n    "
  },
  {
    "name": "request(_:)",
    "kind": "Instance Method",
    "offset": 432761,
    "length": 229,
    "sourcetext": " func request(_ demmand: Subscribers.Demand) {\n        // We do nothing here as we only want to send events when they occur.\n        // See, for more info: https://developer.apple.com/documentation/combine/subscribers/demand\n    "
  },
  {
    "name": "cancel()",
    "kind": "Instance Method",
    "offset": 432996,
    "length": 46,
    "sourcetext": " func cancel() {\n        subscriber = nil\n    "
  },
  {
    "name": "eventHandler()",
    "kind": "Instance Method",
    "offset": 433062,
    "length": 68,
    "sourcetext": " func eventHandler() {\n        _ = subscriber?.receive(control)\n    "
  },
  {
    "name": "configureBackgroundView(type:)",
    "kind": "Instance Method",
    "offset": 433977,
    "length": 868,
    "sourcetext": " func configureBackgroundView(type: BackgroundScreenType = .pattern) {\n        let restorationIdentifier = \"background-view-identifier\"\n\n        subviews\n            .filter { $0.restorationIdentifier == restorationIdentifier }\n            .forEach { $0.removeFromSuperview() }\n\n        let configuration: SNBCommon.Configuration? = Resolver.optional()\n        let backgroundView: UIView\n        switch type {\n        case .pattern:\n            backgroundView = UIImageView(image: configuration?.images.patternBackground)\n        case .plain:\n            backgroundView = UIImageView(image: configuration?.images.gradientBackground)\n        }\n        backgroundView.restorationIdentifier = restorationIdentifier\n        addSubview(backgroundView)\n        sendSubviewToBack(backgroundView)\n        backgroundView.snp.makeConstraints { $0.edges.equalToSuperview() }\n    "
  },
  {
    "name": "configureDefaultCardContentView(backgroundType:)",
    "kind": "Instance Method",
    "offset": 435267,
    "length": 321,
    "sourcetext": " func configureDefaultCardContentView(backgroundType: BackgroundScreenType = .pattern) -> UIView {\n        configureBackgroundView(type: backgroundType)\n        let cardContentView = CardContentView()\n        addSubview(cardContentView)\n        cardContentView.makeDefaultConstraints()\n        return cardContentView\n    "
  },
  {
    "name": "init(arrangedSubviews:axis:alignment:distribution:spacing:)",
    "kind": "Instance Method",
    "offset": 436040,
    "length": 434,
    "sourcetext": " init(\n        arrangedSubviews: [UIView] = [],\n        axis: NSLayoutConstraint.Axis = .horizontal,\n        alignment: UIStackView.Alignment = .fill,\n        distribution: UIStackView.Distribution = .fill,\n        spacing: CGFloat = 0\n    ) {\n        self.init(arrangedSubviews: arrangedSubviews)\n        self.axis = axis\n        self.alignment = alignment\n        self.distribution = distribution\n        self.spacing = spacing\n    "
  },
  {
    "name": "addArrangedSubview(_:insets:)",
    "kind": "Instance Method",
    "offset": 437136,
    "length": 314,
    "sourcetext": " func addArrangedSubview(_ subview: UIView, insets: UIEdgeInsets) -> UIView {\n        let containerView = UIView()\n        containerView.addSubview(subview)\n        subview.snp.makeConstraints { $0.edges.equalToSuperview().inset(insets) }\n        addArrangedSubview(containerView)\n        return containerView\n    "
  },
  {
    "name": "addArrangedSubview(_:spaceBefore:)",
    "kind": "Instance Method",
    "offset": 437891,
    "length": 327,
    "sourcetext": " func addArrangedSubview(_ subview: UIView, spaceBefore: CGFloat) {\n        let lastViewBeforeAddition = arrangedSubviews.last\n        addArrangedSubview(subview)\n\n        guard let safeLastViewBeforeAddition = lastViewBeforeAddition else { return }\n        setCustomSpacing(spaceBefore, after: safeLastViewBeforeAddition)\n    "
  },
  {
    "name": "removeArrangedSubviews()",
    "kind": "Instance Method",
    "offset": 438291,
    "length": 157,
    "sourcetext": " func removeArrangedSubviews() {\n        arrangedSubviews.forEach {\n            removeArrangedSubview($0)\n            $0.removeFromSuperview()\n        }\n    "
  },
  {
    "name": "adding(key:value:)",
    "kind": "Instance Method",
    "offset": 439909,
    "length": 127,
    "sourcetext": " func adding(key: Key, value: Value) -> Dictionary {\n        var copy = self\n        copy[key] = value\n        return copy\n    "
  },
  {
    "name": "preferredLocalisedText(en:ar:)",
    "kind": "Static Method",
    "offset": 442456,
    "length": 205,
    "sourcetext": " static func preferredLocalisedText(en: String, ar: String) -> String {\n        switch AppLanguageManager.currentLanguage() {\n        case .arabic: return ar\n        case .english: return en\n        }\n    "
  },
  {
    "name": "init(iso8601String:)",
    "kind": "Instance Method",
    "offset": 443043,
    "length": 620,
    "sourcetext": " init?(iso8601String: String) {\n        let timeZoneString = String(iso8601String.suffix(6))\n        let sign = String(timeZoneString.prefix(1))\n\n        guard [\"+\", \"-\"].contains(sign) else {\n            return nil\n        }\n\n        let fullTimeString = timeZoneString.filter(\"0123456789\".contains)\n\n        guard fullTimeString.count == 4 else {\n            return nil\n        }\n\n        guard let hours = Int(sign + fullTimeString.prefix(2)),\n              let minutes = Int(sign + fullTimeString.suffix(2)) else {\n            return nil\n        }\n\n        self.init(secondsFromGMT: hours * 3600 + minutes * 60)\n    "
  },
  {
    "name": "equal(_:)",
    "kind": "Static Method",
    "offset": 444672,
    "length": 94,
    "sourcetext": " static func equal(_ size: CGFloat) -> CGSize {\n        CGSize(width: size, height: size)\n    "
  },
  {
    "name": "setInvertedNaturalTextAlignment()",
    "kind": "Instance Method",
    "offset": 445168,
    "length": 131,
    "sourcetext": " func setInvertedNaturalTextAlignment() {\n        textAlignment = UIView.isRTL(for: semanticContentAttribute) ? .left : .right\n    "
  },
  {
    "name": "primaryButton(title:show:disabled:loading:topSpacing:horizontalPadding:action:)",
    "kind": "Instance Method",
    "offset": 445736,
    "length": 592,
    "sourcetext": " func primaryButton(\n        title: String,\n        show: Bool = true,\n        disabled: Bool = false,\n        loading: Bool = false,\n        topSpacing: CGFloat = DesignSystem.shared.spacer.lg,\n        horizontalPadding: CGFloat = DesignSystem.shared.spacer.md,\n        action: @escaping () -> Void\n    ) -> some View {\n        modifier(PrimaryButtonModifier(\n            title: title,\n            show: show,\n            disabled: disabled,\n            loading: loading,\n            topSpacing: topSpacing,\n            horizontalPadding: horizontalPadding,\n            action: action))\n    "
  },
  {
    "name": "body(content:)",
    "kind": "Instance Method",
    "offset": 446558,
    "length": 500,
    "sourcetext": " func body(content: Content) -> some View {\n        VStack {\n            content\n            if show {\n                Spacer()\n                    .frame(height: topSpacing)\n                Button(action: action) {\n                    Text(title)\n                }\n                .buttonStyle(.primary(isEnabled: !disabled, isLoading: loading))\n                .padding(.horizontal, horizontalPadding)\n                .disabled(disabled || loading)\n            }\n            Spacer()\n        }\n    "
  },
  {
    "name": "encrypt(with:)",
    "kind": "Instance Method",
    "offset": 448696,
    "length": 740,
    "sourcetext": " func encrypt(with publicKey: String?) -> String? {\n        guard let publicKey = publicKey?.trimedPublicKey, let data = Data(base64Encoded: publicKey) else {\n            return nil\n        }\n\n        let attributes: CFDictionary = [\n            kSecAttrKeyType: kSecAttrKeyTypeRSA,\n            kSecAttrKeyClass: kSecAttrKeyClassPublic,\n            kSecAttrKeySizeInBits: 2048,\n            kSecReturnPersistentRef: true as NSObject\n        ] as CFDictionary\n\n        var error: Unmanaged<CFError>?\n        guard let secKey = SecKeyCreateWithData(data as CFData, attributes, &error) else {\n            Backbase.logError(self, message: error.debugDescription)\n            return nil\n        }\n        return encryptToBase64(with: secKey)\n    "
  },
  {
    "name": "encryptToBase64(with:)",
    "kind": "Instance Method",
    "offset": 449450,
    "length": 441,
    "sourcetext": " func encryptToBase64(with publicKey: SecKey) -> String? {\n        var error: Unmanaged<CFError>?\n        guard let data = data(using: .utf8),\n              let encryptedData = SecKeyCreateEncryptedData(publicKey, .rsaEncryptionPKCS1, data as CFData, &error) as? Data\n        else {\n            Backbase.logError(self, message: error.debugDescription)\n            return nil\n        }\n\n        return encryptedData.base64EncodedString()\n    "
  },
  {
    "name": "sanitizeAmountForInput(amount:)",
    "kind": "Static Method",
    "offset": 450134,
    "length": 336,
    "sourcetext": " static func sanitizeAmountForInput(amount: String?) -> String? {\n        let numberLocale = DesignSystem.Formatting.numberLocale\n        let groupingSeparator = numberLocale.groupingSeparator ?? \" \"\n        return amount?.replacingOccurrences(of: groupingSeparator, with: \"\")\n            .replacingOccurrences(of: \".00\", with: \"\")\n    "
  },
  {
    "name": "trimmed()",
    "kind": "Instance Method",
    "offset": 450896,
    "length": 100,
    "sourcetext": " func trimmed() -> String {\n        return self.trimmingCharacters(in: .whitespacesAndNewlines)\n    "
  },
  {
    "name": "body(content:)",
    "kind": "Instance Method",
    "offset": 451393,
    "length": 177,
    "sourcetext": " func body(content: Content) -> some View {\n        return content\n            .environment(\\.layoutDirection, LocaleSelector.shared.isArabic ? .rightToLeft : .leftToRight)\n    "
  },
  {
    "name": "forceCorrectSementicContentAttribute()",
    "kind": "Instance Method",
    "offset": 451602,
    "length": 103,
    "sourcetext": " func forceCorrectSementicContentAttribute() -> some View {\n        modifier(LocaleViewModifier())\n    "
  },
  {
    "name": "popToRootViewControllerWithHandler(animated:completion:)",
    "kind": "Instance Method",
    "offset": 452165,
    "length": 275,
    "sourcetext": " func popToRootViewControllerWithHandler(animated: Bool = true, completion: @escaping () -> Void) {\n        CATransaction.begin()\n        CATransaction.setCompletionBlock(completion)\n        self.popToRootViewController(animated: animated)\n        CATransaction.commit()\n    "
  },
  {
    "name": "popToViewController(ofClass:animated:)",
    "kind": "Instance Method",
    "offset": 452453,
    "length": 242,
    "sourcetext": " func popToViewController(ofClass: AnyClass, animated: Bool = true) {\n        if let viewController = viewControllers.last(where: { $0.isKind(of: ofClass) }) {\n            popToViewController(viewController, animated: animated)\n        }\n    "
  },
  {
    "name": "init()",
    "kind": "Instance Method",
    "offset": 453494,
    "length": 9,
    "sourcetext": " init() {"
  },
  {
    "name": "getImage(forKey:)",
    "kind": "Instance Method",
    "offset": 453972,
    "length": 45,
    "sourcetext": " func getImage(forKey key: String) -> UIImage"
  },
  {
    "name": "init()",
    "kind": "Instance Method",
    "offset": 454175,
    "length": 75,
    "sourcetext": " init() {\n       cache.totalCostLimit = 20 * 1024 * 1024 // 20MB limit\n    "
  },
  {
    "name": "getImage(forKey:)",
    "kind": "Instance Method",
    "offset": 454262,
    "length": 105,
    "sourcetext": " func getImage(forKey key: String) -> UIImage? {\n       return cache.object(forKey: key as NSString)\n    "
  },
  {
    "name": "cacheImage(_:forKey:)",
    "kind": "Instance Method",
    "offset": 454373,
    "length": 117,
    "sourcetext": " func cacheImage(_ image: UIImage, forKey key: String) {\n        cache.setObject(image, forKey: key as NSString)\n    "
  },
  {
    "name": "loadImage(withURL:)",
    "kind": "Instance Method",
    "offset": 454744,
    "length": 624,
    "sourcetext": " func loadImage(withURL url: URL) async throws -> UIImage? {\n        // Check if the image is already cached\n        if let cachedImage = imageCache.getImage(forKey: url.absoluteString) {\n            return cachedImage\n        }\n\n        // Load data asynchronously from the URL\n        let data = try await loadData(withURL: url)\n\n        // Convert the loaded data to an image\n        guard let image = UIImage(data: data) else {\n            throw ImageLoadingError.invalidData\n        }\n\n        // Cache the image for future use\n        imageCache.cacheImage(image, forKey: url.absoluteString)\n\n        return image\n    "
  },
  {
    "name": "cancelImageLoading(forURL:)",
    "kind": "Instance Method",
    "offset": 455429,
    "length": 397,
    "sourcetext": " func cancelImageLoading(forURL url: URL) {\n        // Find the tasks that match the provided URL\n        let tasksToCancel = loadingTasks.filter { $0.originalRequest?.url == url }\n\n        // Cancel each matching task\n        tasksToCancel.forEach { $0.cancel() }\n\n        // Remove the canceled tasks from the loadingTasks array\n        loadingTasks.removeAll { tasksToCancel.contains($0) }\n    "
  },
  {
    "name": "loadData(withURL:)",
    "kind": "Instance Method",
    "offset": 455903,
    "length": 390,
    "sourcetext": " func loadData(withURL url: URL) async throws -> Data {\n        // Perform the data loading task\n        let config = URLSessionConfiguration.default\n        config.urlCache = nil\n        config.requestCachePolicy = .reloadIgnoringLocalCacheData\n        let urlSession = URLSession(configuration: config)\n        let (data, _) = try await urlSession.data(from: url)\n        return data\n    "
  },
  {
    "name": "init()",
    "kind": "Instance Method",
    "offset": 457295,
    "length": 9,
    "sourcetext": " init() {"
  },
  {
    "name": "changeLocale()",
    "kind": "Instance Method",
    "offset": 457972,
    "length": 57,
    "sourcetext": " func changeLocale() {\n        showRestartAppAlert()\n    "
  },
  {
    "name": "updateSemanticContentAttribute()",
    "kind": "Instance Method",
    "offset": 458042,
    "length": 2419,
    "sourcetext": " func updateSemanticContentAttribute() {\n        if isArabic {\n            UIView.appearance().semanticContentAttribute = .forceRightToLeft\n            UIButton.appearance().semanticContentAttribute = .forceRightToLeft\n            UITextView.appearance().semanticContentAttribute = .forceRightToLeft\n            UITextField.appearance().semanticContentAttribute = .forceRightToLeft\n            UITableView.appearance().semanticContentAttribute = .forceRightToLeft\n            UITableViewCell.appearance().semanticContentAttribute = .forceRightToLeft\n            UILabel.appearance().semanticContentAttribute = .forceRightToLeft\n            UIScrollView.appearance().semanticContentAttribute = .forceRightToLeft\n            TextInput.appearance().semanticContentAttribute = .forceRightToLeft\n            UIImageView.appearance().semanticContentAttribute = .forceRightToLeft\n            UISearchBar.appearance().semanticContentAttribute = .forceRightToLeft\n            UITextField.appearance(whenContainedInInstancesOf: [UISearchBar.self]).textAlignment = .right\n            UINavigationBar.appearance().semanticContentAttribute = .forceRightToLeft\n            TextArea.appearance().semanticContentAttribute = .forceRightToLeft\n        } else {\n            UIView.appearance().semanticContentAttribute = .forceLeftToRight\n            UIButton.appearance().semanticContentAttribute = .forceLeftToRight\n            UITextView.appearance().semanticContentAttribute = .forceLeftToRight\n            UITextField.appearance().semanticContentAttribute = .forceLeftToRight\n            UITableView.appearance().semanticContentAttribute = .forceLeftToRight\n            UITableViewCell.appearance().semanticContentAttribute = .forceLeftToRight\n            UILabel.appearance().semanticContentAttribute = .forceLeftToRight\n            UIScrollView.appearance().semanticContentAttribute = .forceLeftToRight\n            TextInput.appearance().semanticContentAttribute = .forceLeftToRight\n            UIImageView.appearance().semanticContentAttribute = .forceLeftToRight\n            UISearchBar.appearance().semanticContentAttribute = .forceLeftToRight\n            UITextField.appearance(whenContainedInInstancesOf: [UISearchBar.self]).textAlignment = .left\n            UINavigationBar.appearance().semanticContentAttribute = .forceLeftToRight\n            TextArea.appearance().semanticContentAttribute = .forceLeftToRight\n        }\n    "
  },
  {
    "name": "showRestartAppAlert()",
    "kind": "Instance Method",
    "offset": 460762,
    "length": 784,
    "sourcetext": " func showRestartAppAlert() {\n        let alert = UIAlertController(\n            title: Strings.LocaleSelector.alertTitle,\n            message: Strings.LocaleSelector.alertMessage,\n            preferredStyle: .alert\n        )\n        let cancelAction = UIAlertAction(title: Strings.LocaleSelector.alertCancel, style: .cancel, handler: nil)\n        let okAction = UIAlertAction(title: Strings.LocaleSelector.alertOk, style: .destructive) { [weak self] action in\n            self?.changeAppLocale()\n        }\n        alert.addAction(cancelAction)\n        alert.addAction(okAction)\n        guard let viewController = UIApplication.shared.windows.first?.rootViewController else {\n            return\n        }\n        viewController.topViewController()?.present(alert, animated: true)\n    "
  },
  {
    "name": "changeAppLocale()",
    "kind": "Instance Method",
    "offset": 461560,
    "length": 382,
    "sourcetext": " func changeAppLocale() {\n        if let locale = useCase.supportedLocales.first(where: {$0.identifier != preferredLanguageCode}) {\n            useCase.savedLocale = locale\n            UserDefaults.standard.set([locale.identifier], forKey: \"AppleLanguages\")\n            NotificationCenter.default.post(name: .onNeoLocaleChangeDone, object: nil)\n            closeApp()\n        }\n    "
  },
  {
    "name": "closeApp()",
    "kind": "Instance Method",
    "offset": 461956,
    "length": 240,
    "sourcetext": " func closeApp() {\n        UIControl().sendAction(#selector(URLSessionTask.suspend), to: UIApplication.shared, for: nil)\n        DispatchQueue.main.asyncAfter(deadline: .now() + 0.1, execute: {\n            exit(EXIT_SUCCESS)\n        })\n    "
  },
  {
    "name": "init(withCountryCode:)",
    "kind": "Instance Method",
    "offset": 463067,
    "length": 768,
    "sourcetext": " init?(withCountryCode countryCode: String) {\n        switch countryCode {\n        case \"AA\": self = .AAA\n        case \"SA\": self = .SAR\n        case \"US\": self = .USD\n        case \"EU\": self = .EUR\n        case \"GB\": self = .GBP\n        case \"AE\": self = .AED\n        case \"AU\": self = .AUD\n        case \"BH\": self = .BHD\n        case \"CA\": self = .CAD\n        case \"HK\": self = .HKD\n        case \"EG\": self = .EGP\n        case \"IN\": self = .INR\n        case \"JP\": self = .JPY\n        case \"JO\": self = .JOD\n        case \"KW\": self = .KWD\n        case \"MA\": self = .MAD\n        case \"OM\": self = .OMR\n        case \"QA\": self = .QAR\n        case \"SG\": self = .SGD\n        case \"CH\": self = .CHF\n        case \"TR\": self = .TRY\n        default: return nil\n        }\n    "
  },
  {
    "name": "getLogo(with:)",
    "kind": "Instance Method",
    "offset": 466561,
    "length": 244,
    "sourcetext": " func getLogo(with bankCode: String) -> UIImage {\n        guard let logo = UIImage.named(bankCode.uppercased(), in: .snbCommon) else {\n            return UIImage.named(\"placeholder_bank_logo\", in: .snbCommon)!\n        }\n        return logo\n    "
  },
  {
    "name": "getProviderLogos(with:)",
    "kind": "Instance Method",
    "offset": 466877,
    "length": 286,
    "sourcetext": " func getProviderLogos(with bankCode: String) -> UIImage {\n        guard !bankCode.isEmpty,\n              let logo = UIImage.named(bankCode.uppercased(), in: .snbCommon) else {\n            return UIImage.named(\"placeholder_bank_logo\", in: .snbCommon)!\n        }\n        return logo\n    "
  },
  {
    "name": "getProviderBanner(with:)",
    "kind": "Instance Method",
    "offset": 467176,
    "length": 250,
    "sourcetext": " func getProviderBanner(with bankCode: String) -> UIImage? {\n        guard !bankCode.isEmpty,\n              let logo = UIImage.named(\"Provider_\\(bankCode.uppercased())\", in: .snbCommon) else {\n            return nil\n        }\n        return logo\n    "
  },
  {
    "name": "init()",
    "kind": "Instance Method",
    "offset": 467440,
    "length": 47,
    "sourcetext": " init() {\n        // No code required here\n    "
  },
  {
    "name": "getFlag(with:)",
    "kind": "Instance Method",
    "offset": 468041,
    "length": 239,
    "sourcetext": " func getFlag(with code: String) -> UIImage? {\n        guard let flag = UIImage.named(code.uppercased(), in: .snbCommon) else {\n            return UIImage.named(\"placeholder_country_flag\", in: .snbCommon)\n        }\n        return flag\n    "
  },
  {
    "name": "init()",
    "kind": "Instance Method",
    "offset": 468294,
    "length": 9,
    "sourcetext": " init() {"
  },
  {
    "name": "init(coder:)",
    "kind": "Instance Method",
    "offset": 468958,
    "length": 89,
    "sourcetext": " init?(coder: NSCoder) {\n        fatalError(\"init(coder:) has not been implemented\")\n    "
  },
  {
    "name": "init(viewModel:)",
    "kind": "Instance Method",
    "offset": 469053,
    "length": 124,
    "sourcetext": " init(viewModel: PDFReaderViewModel) {\n        self.viewModel = viewModel\n        super.init(nibName: nil, bundle: nil)\n    "
  },
  {
    "name": "viewDidLoad()",
    "kind": "Instance Method",
    "offset": 469231,
    "length": 200,
    "sourcetext": " func viewDidLoad() {\n        super.viewDidLoad()\n        view.backgroundColor = .black\n        view.configureDefaultCardContentView(backgroundType: .pattern)\n        addSubviews()\n        bind()\n    "
  },
  {
    "name": "viewWillAppear(_:)",
    "kind": "Instance Method",
    "offset": 469446,
    "length": 766,
    "sourcetext": " func viewWillAppear(_ animated: Bool) {\n        super.viewWillAppear(animated)\n        navigationController?.navigationBar.prefersLargeTitles = false\n        navigationController?.navigationItem.largeTitleDisplayMode = .never\n        let attributes: [NSAttributedString.Key: Any] = [\n            .font: DesignSystem.shared.fonts.preferredFont(.body, .medium),\n            .foregroundColor: DesignSystem.shared.colors.text.default.dark\n        ]\n\n        let appearance = UINavigationBarAppearance()\n        appearance.configureWithTransparentBackground()\n        appearance.titleTextAttributes = attributes\n        navigationController?.navigationBar.standardAppearance = appearance\n        navigationController?.navigationBar.scrollEdgeAppearance = appearance\n    "
  },
  {
    "name": "viewWillDisappear(_:)",
    "kind": "Instance Method",
    "offset": 470227,
    "length": 270,
    "sourcetext": " func viewWillDisappear(_ animated: Bool) {\n        super.viewWillDisappear(animated)\n        navigationController?.navigationBar.prefersLargeTitles = true\n        navigationController?.navigationItem.largeTitleDisplayMode = .automatic\n        view.endEditing(true)\n    "
  },
  {
    "name": "addSubviews()",
    "kind": "Instance Method",
    "offset": 470859,
    "length": 59,
    "sourcetext": " func addSubviews() {\n        view.addSubview(pdfView)\n    "
  },
  {
    "name": "bind()",
    "kind": "Instance Method",
    "offset": 470924,
    "length": 891,
    "sourcetext": " func bind() {\n        viewModel.$pdfDocument\n            .compactMap { $0 }\n            .sink { [weak self] pdfDoc in\n                self?.update(with: pdfDoc)\n            }.store(in: &viewModel.cancellables)\n\n        viewModel.$title\n            .sink { [weak self] screenTitle in\n                self?.title = screenTitle\n            }.store(in: &viewModel.cancellables)\n\n        viewModel.$fileURL\n            .compactMap { $0 }\n            .sink { [weak self] fileURL in\n                self?.presentShareActivity(with: fileURL)\n            }.store(in: &viewModel.cancellables)\n\n        viewModel.$screenProperties\n            .sink { [weak self] screenProperties in\n                guard let self else { return }\n                self.setupNavBar(with: screenProperties)\n                screenProperties.pdfViewStyle?(self.pdfView)\n            }.store(in: &viewModel.cancellables)\n    "
  },
  {
    "name": "setupNavBar(with:)",
    "kind": "Instance Method",
    "offset": 471853,
    "length": 1251,
    "sourcetext": " func setupNavBar(with screenConfig: ScreenProperties) {\n        let closeView = UIImageView(image: screenConfig.closeImage)\n        closeView.tintColor = .white\n        screenConfig.closeButtonHeight.flatMap { size in\n            closeView.snp.makeConstraints { make in\n                make.width.height.equalTo(size)\n            }\n        }\n\n        let closeGesture = UITapGestureRecognizer(\n            target: viewModel,\n            action: #selector(viewModel.closeTapped)\n        )\n        closeView.addGestureRecognizer(closeGesture)\n        navigationItem.leftBarButtonItem = UIBarButtonItem(customView: closeView)\n\n        let shareView = UIImageView(image: screenConfig.shareImage)\n        shareView.tintColor = .white\n        screenConfig.shareIconSize.flatMap { size in\n            shareView.snp.makeConstraints { make in\n                make.width.height.equalTo(size)\n            }\n        }\n\n        let shareGesture = UITapGestureRecognizer(\n            target: viewModel,\n            action: #selector(viewModel.shareTapped)\n        )\n        shareView.addGestureRecognizer(shareGesture)\n        navigationItem.rightBarButtonItem = UIBarButtonItem(customView: shareView)\n        screenConfig.navigationItemStyle?(navigationItem)\n    "
  },
  {
    "name": "update(with:)",
    "kind": "Instance Method",
    "offset": 473118,
    "length": 415,
    "sourcetext": " func update(with document: PDFDocument) {\n        pdfView.document = document\n        pdfView.goToFirstPage(nil)\n        adjustPDFSize()\n\n        DispatchQueue.main.async { [weak self] in\n            guard let self else { return }\n\n            self.pdfView.autoScales = true\n            self.pdfView.maxScaleFactor = 4.0\n            self.pdfView.minScaleFactor = self.pdfView.scaleFactorForSizeToFit\n        }\n    "
  },
  {
    "name": "adjustPDFSize()",
    "kind": "Instance Method",
    "offset": 473547,
    "length": 313,
    "sourcetext": " func adjustPDFSize() {\n        pdfView.snp.removeConstraints()\n        pdfView.snp.makeConstraints { make in\n            make.top.equalTo(view.safeAreaLayoutGuide).offset(DesignSystem.shared.spacer.lg)\n            make.leading.trailing.equalToSuperview()\n            make.bottom.equalToSuperview()\n        }\n    "
  },
  {
    "name": "presentShareActivity(with:)",
    "kind": "Instance Method",
    "offset": 473874,
    "length": 419,
    "sourcetext": " func presentShareActivity(with fileURL: URL) {\n        pdfView.document?.write(to: fileURL)\n        let source = PDFActivityItemSource(fileURL: fileURL)\n        let activityViewController = UIActivityViewController(activityItems: [source], applicationActivities: nil)\n        activityViewController.popoverPresentationController?.sourceView = self.view\n        self.present(activityViewController, animated: true)\n    "
  },
  {
    "name": "init(fileURL:)",
    "kind": "Instance Method",
    "offset": 474613,
    "length": 57,
    "sourcetext": " init(fileURL: URL) {\n        self.fileURL = fileURL\n    "
  },
  {
    "name": "activityViewControllerPlaceholderItem(_:)",
    "kind": "Instance Method",
    "offset": 474676,
    "length": 125,
    "sourcetext": " func activityViewControllerPlaceholderItem(_ activityViewController: UIActivityViewController) -> Any {\n        fileURL\n    "
  },
  {
    "name": "activityViewController(_:itemForActivityType:)",
    "kind": "Instance Method",
    "offset": 474807,
    "length": 201,
    "sourcetext": " func activityViewController(\n        _ activityViewController: UIActivityViewController,\n        itemForActivityType\n        activityType: UIActivity.ActivityType?\n    ) -> Any? {\n        fileURL\n    "
  },
  {
    "name": "activityViewControllerLinkMetadata(_:)",
    "kind": "Instance Method",
    "offset": 475014,
    "length": 412,
    "sourcetext": " func activityViewControllerLinkMetadata(_ activityViewController: UIActivityViewController) -> LPLinkMetadata? {\n        let metadata = LPLinkMetadata()\n        metadata.title = title\n        metadata.url = fileURL\n        metadata.originalURL = URL(fileURLWithPath: subtitle)\n        if let image = icon {\n            metadata.iconProvider = NSItemProvider(object: image)\n        }\n        return metadata\n    "
  },
  {
    "name": "build(model:configuration:)",
    "kind": "Static Method",
    "offset": 475807,
    "length": 304,
    "sourcetext": " static func build(model: PDFReader.PDFModel, configuration: PDFReader.Configuration) -> UIViewController {\n        let viewModel = PDFReaderViewModel(model: model, configuration: configuration)\n        let viewController = PDFReaderViewController(viewModel: viewModel)\n        return viewController\n    "
  },
  {
    "name": "init(data:url:title:closeAction:)",
    "kind": "Instance Method",
    "offset": 476559,
    "length": 226,
    "sourcetext": " init(data: Data? = nil, url: URL? = nil, title: String?, closeAction: (() -> Void)?) {\n            self.data = data\n            self.url = url\n            self.title = title\n            self.closeAction = closeAction\n        "
  },
  {
    "name": "init(showShareActivityOnLoad:design:strings:)",
    "kind": "Instance Method",
    "offset": 477413,
    "length": 293,
    "sourcetext": " init(\n            showShareActivityOnLoad: Bool = false,\n            design: Design = Design(),\n            strings: Strings = Strings()\n        ) {\n            self.showShareActivityOnLoad = showShareActivityOnLoad\n            self.design = design\n            self.strings = strings\n        "
  },
  {
    "name": "init()",
    "kind": "Instance Method",
    "offset": 479632,
    "length": 9,
    "sourcetext": " init() {"
  },
  {
    "name": "init()",
    "kind": "Instance Method",
    "offset": 479797,
    "length": 9,
    "sourcetext": " init() {"
  },
  {
    "name": "init(model:configuration:)",
    "kind": "Instance Method",
    "offset": 480566,
    "length": 722,
    "sourcetext": " init(model: PDFReader.PDFModel, configuration: PDFReader.Configuration) {\n        self.model = model\n        self.configuration = configuration\n        self.title = model.title ?? configuration.strings.pdfScreenTitle\n        self.screenProperties = ScreenProperties(\n            shareImage: configuration.design.shareImage,\n            closeImage: configuration.design.closeImage,\n            navigationItemStyle: configuration.design.navigationItemStyle,\n            pdfViewStyle: configuration.design.pdfViewStyle,\n            closeButtonHeight: configuration.design.closeButtonHeight,\n            shareIconSize: configuration.design.shareIconSize\n        )\n\n        setupLoadingPDF()\n        fetchPDF(from: model)\n    "
  },
  {
    "name": "setupLoadingPDF()",
    "kind": "Instance Method",
    "offset": 481337,
    "length": 272,
    "sourcetext": " func setupLoadingPDF() {\n        guard let path = Bundle.snbCommon.path(forResource: \"pdfreader_loading\", ofType: \"pdf\") else { return }\n        let url = URL(fileURLWithPath: path)\n        if let pdf = PDFDocument(url: url) {\n            pdfDocument = pdf\n        }\n    "
  },
  {
    "name": "fetchPDF(from:)",
    "kind": "Instance Method",
    "offset": 481623,
    "length": 500,
    "sourcetext": " func fetchPDF(from model: PDFReader.PDFModel) {\n        DispatchQueue.global(qos: .background).async {\n            if let data = model.data {\n                if let pdfDocument = PDFDocument(data: data) {\n                    self.present(pdfDocument: pdfDocument)\n                }\n            }\n            if let url = model.url {\n                if let pdfDocument = PDFDocument(url: url) {\n                    self.present(pdfDocument: pdfDocument)\n                }\n            }\n        }\n    "
  },
  {
    "name": "present(pdfDocument:)",
    "kind": "Instance Method",
    "offset": 482137,
    "length": 243,
    "sourcetext": " func present(pdfDocument: PDFDocument) {\n        DispatchQueue.main.async {\n            self.pdfDocument = pdfDocument\n            if self.configuration.showShareActivityOnLoad {\n                self.shareTapped()\n            }\n        }\n    "
  },
  {
    "name": "shareTapped()",
    "kind": "Instance Method",
    "offset": 482523,
    "length": 383,
    "sourcetext": " func shareTapped() {\n        let temporaryFolder = FileManager.default.temporaryDirectory\n        let fileName: String\n        if let title = model.title, !title.isEmpty {\n            fileName = title + \".pdf\"\n        } else {\n            fileName = \"\"\n        }\n        let temporaryFileURL = temporaryFolder.appendingPathComponent(fileName)\n        fileURL = temporaryFileURL\n    "
  },
  {
    "name": "closeTapped()",
    "kind": "Instance Method",
    "offset": 482918,
    "length": 55,
    "sourcetext": " func closeTapped() {\n        model.closeAction?()\n    "
  },
  {
    "name": "save(_:)",
    "kind": "Instance Method",
    "offset": 484136,
    "length": 751,
    "sourcetext": " func save(_ image: UIImage) -> Bool {\n        guard let data = image.jpegData(compressionQuality: 1) ?? image.pngData() else {\n            return false\n        }\n\n        guard let directory = try? FileManager.default.url(for: .documentDirectory,\n                                                           in: .userDomainMask,\n                                                           appropriateFor: nil,\n                                                           create: false) as NSURL else {\n            return false\n        }\n\n        removeAvatarImageIfSaved()\n\n        do {\n            try data.write(to: directory.appendingPathComponent(avatarImageFileName)!)\n            return true\n        } catch {\n            return false\n        }\n    "
  },
  {
    "name": "getSavedImage()",
    "kind": "Instance Method",
    "offset": 484900,
    "length": 523,
    "sourcetext": " func getSavedImage() -> UIImage? {\n        if let directory = try? FileManager.default.url(for: .documentDirectory,\n                                                          in: .userDomainMask,\n                                                          appropriateFor: nil,\n                                                          create: false) {\n            return UIImage(contentsOfFile: URL(fileURLWithPath: directory.absoluteString).appendingPathComponent(avatarImageFileName).path)\n        }\n        return nil\n    "
  },
  {
    "name": "removeAvatarImageIfSaved()",
    "kind": "Instance Method",
    "offset": 485436,
    "length": 195,
    "sourcetext": " func removeAvatarImageIfSaved() {\n        guard let imagePath = path(for: avatarImageFileName) else {\n            return\n        }\n        try? FileManager.default.removeItem(at: imagePath)\n    "
  },
  {
    "name": "path(for:)",
    "kind": "Instance Method",
    "offset": 485645,
    "length": 209,
    "sourcetext": " func path(for imageName: String) -> URL? {\n        let directory = FileManager.default.urls(for: .documentDirectory, in: .userDomainMask).first\n        return directory?.appendingPathComponent(imageName)\n    "
  },
  {
    "name": "init()",
    "kind": "Instance Method",
    "offset": 485868,
    "length": 9,
    "sourcetext": " init() {"
  },
  {
    "name": "canOpenURL(_:)",
    "kind": "Instance Method",
    "offset": 486301,
    "length": 35,
    "sourcetext": " func canOpenURL(_ url: URL) -> Boo"
  },
  {
    "name": "open(_:options:)",
    "kind": "Instance Method",
    "offset": 486341,
    "length": 92,
    "sourcetext": " func open(_ url: URL, options: [UIApplication.OpenExternalURLOptionsKey: Any]) async -> Boo"
  },
  {
    "name": "init(application:)",
    "kind": "Instance Method",
    "offset": 486569,
    "length": 83,
    "sourcetext": " init(application: URLOpenerProtocol) {\n        self.application = application\n    "
  },
  {
    "name": "openUrl(url:)",
    "kind": "Instance Method",
    "offset": 486665,
    "length": 141,
    "sourcetext": " func openUrl(url: URL) async {\n        if application.canOpenURL(url) {\n            await application.open(url, options: [:])\n        }\n    "
  },
  {
    "name": "register(_:)",
    "kind": "Instance Method",
    "offset": 487504,
    "length": 171,
    "sourcetext": " func register<Cell>(_ cellType: Cell.Type) where Cell: UITableViewCell, Cell: Reusable {\n        register(cellType, forCellReuseIdentifier: cellType.reuseIdentifier)\n    "
  },
  {
    "name": "registerHeaderFooterView(_:)",
    "kind": "Instance Method",
    "offset": 487681,
    "length": 199,
    "sourcetext": " func registerHeaderFooterView<View>(_ view: View.Type) where View: UITableViewHeaderFooterView, View: Reusable {\n        register(view, forHeaderFooterViewReuseIdentifier: view.reuseIdentifier)\n    "
  },
  {
    "name": "dequeue(_:for:)",
    "kind": "Instance Method",
    "offset": 487886,
    "length": 377,
    "sourcetext": " func dequeue<Cell>(_ cellType: Cell.Type, for indexPath: IndexPath) -> Cell where Cell: UITableViewCell, Cell: Reusable {\n        guard let cell = dequeueReusableCell(withIdentifier: cellType.reuseIdentifier, for: indexPath) as? Cell else {\n            fatalError(\"Cell class \\(cellType.reuseIdentifier) is not registered in \\(description)\")\n        }\n        return cell\n    "
  },
  {
    "name": "dequeue(_:)",
    "kind": "Instance Method",
    "offset": 488269,
    "length": 483,
    "sourcetext": " func dequeue<HeaderFooter>(_ type: HeaderFooter.Type) -> HeaderFooter where HeaderFooter: UITableViewHeaderFooterView,\n                                                                                HeaderFooter: Reusable {\n        guard let cell = dequeueReusableHeaderFooterView(withIdentifier: type.reuseIdentifier) as? HeaderFooter else {\n            fatalError(\"HeaderFooter class \\(type.reuseIdentifier) is not registered in \\(description)\")\n        }\n        return cell\n    "
  },
  {
    "name": "register(_:)",
    "kind": "Instance Method",
    "offset": 488842,
    "length": 180,
    "sourcetext": " func register<Cell>(_ cellType: Cell.Type) where Cell: UICollectionViewCell, Cell: Reusable {\n        register(cellType, forCellWithReuseIdentifier: cellType.reuseIdentifier)\n    "
  },
  {
    "name": "registerSupplementaryView(_:kind:)",
    "kind": "Instance Method",
    "offset": 489028,
    "length": 242,
    "sourcetext": " func registerSupplementaryView<View>(_ viewType: View.Type, kind: String) where View: UICollectionReusableView, View: Reusable {\n        register(viewType, forSupplementaryViewOfKind: kind, withReuseIdentifier: viewType.reuseIdentifier)\n    "
  },
  {
    "name": "dequeue(_:for:)",
    "kind": "Instance Method",
    "offset": 489276,
    "length": 387,
    "sourcetext": " func dequeue<Cell>(_ cellType: Cell.Type, for indexPath: IndexPath) -> Cell where Cell: UICollectionViewCell, Cell: Reusable {\n        guard let cell = dequeueReusableCell(withReuseIdentifier: cellType.reuseIdentifier, for: indexPath) as? Cell else {\n            fatalError(\"Cell class \\(cellType.reuseIdentifier) is not registered in \\(description)\")\n        }\n        return cell\n    "
  },
  {
    "name": "dequeueSupplementaryView(_:kind:for:)",
    "kind": "Instance Method",
    "offset": 489669,
    "length": 539,
    "sourcetext": " func dequeueSupplementaryView<View>(\n        _ viewType: View.Type,\n        kind: String,\n        for indexPath: IndexPath\n    ) -> View where View: UICollectionReusableView, View: Reusable {\n        guard let view = dequeueReusableSupplementaryView(\n            ofKind: kind,\n            withReuseIdentifier: viewType.reuseIdentifier,\n            for: indexPath\n        ) as? View else {\n            fatalError(\"Supplementary View class \\(viewType.reuseIdentifier) is not registered in \\(description)\")\n        }\n        return view\n    "
  },
  {
    "name": "start()",
    "kind": "Instance Method",
    "offset": 490741,
    "length": 12,
    "sourcetext": " func start("
  },
  {
    "name": "finishFlow()",
    "kind": "Instance Method",
    "offset": 490792,
    "length": 80,
    "sourcetext": " func finishFlow() where CompletionResult == Void {\n        onFinished?(())\n    "
  },
  {
    "name": "finishFlow(result:)",
    "kind": "Instance Method",
    "offset": 490878,
    "length": 77,
    "sourcetext": " func finishFlow(result: CompletionResult) {\n        onFinished?(result)\n    "
  },
  {
    "name": "init(nonce:nonceSignature:certificates:cardType:)",
    "kind": "Instance Method",
    "offset": 491700,
    "length": 246,
    "sourcetext": " init(nonce: String, nonceSignature: String, certificates: [String], cardType: String? = nil) {\n        self.nonce = nonce\n        self.nonceSignature = nonceSignature\n        self.certificates = certificates\n        self.cardType = cardType\n    "
  },
  {
    "name": "init(encryptedPassData:wrappedKey:activationCode:)",
    "kind": "Instance Method",
    "offset": 492127,
    "length": 216,
    "sourcetext": " init(encryptedPassData: String, wrappedKey: String, activationCode: String) {\n        self.encryptedPassData = encryptedPassData\n        self.wrappedKey = wrappedKey\n        self.activationCode = activationCode\n    "
  },
  {
    "name": "getWalletStatus()",
    "kind": "Instance Method",
    "offset": 493298,
    "length": 44,
    "sourcetext": " func getWalletStatus() -> DeviceWalletStatu"
  },
  {
    "name": "getCardWalletStatus(card:)",
    "kind": "Instance Method",
    "offset": 493347,
    "length": 67,
    "sourcetext": " func getCardWalletStatus(card: AppleWalletCard) -> CardWalletStatu"
  },
  {
    "name": "openCardInWallet(card:)",
    "kind": "Instance Method",
    "offset": 493419,
    "length": 44,
    "sourcetext": " func openCardInWallet(card: AppleWalletCard"
  },
  {
    "name": "addCardToWallet(card:originViewController:completion:)",
    "kind": "Instance Method",
    "offset": 493468,
    "length": 206,
    "sourcetext": " func addCardToWallet(\n        card: AppleWalletCard,\n        originViewController: UIViewController,\n        completion: @escaping (UIViewController?, Result<PKSecureElementPass, WalletError>) -> Void\n    "
  },
  {
    "name": "deleteAccount()",
    "kind": "Instance Method",
    "offset": 494164,
    "length": 33,
    "sourcetext": " func deleteAccount() async throw"
  },
  {
    "name": "init(client:)",
    "kind": "Instance Method",
    "offset": 494340,
    "length": 122,
    "sourcetext": " init(client: SNBUserServiceClientProtocol = SNBUserServiceClientFactory.makeClient()) {\n        self.client = client\n    "
  },
  {
    "name": "deleteAccount()",
    "kind": "Instance Method",
    "offset": 494475,
    "length": 82,
    "sourcetext": " func deleteAccount() async throws {\n        try await client.deleteAccount()\n    "
  },
  {
    "name": "deleteAccount()",
    "kind": "Instance Method",
    "offset": 495035,
    "length": 33,
    "sourcetext": " func deleteAccount() async throw"
  },
  {
    "name": "deleteAccount()",
    "kind": "Instance Method",
    "offset": 495156,
    "length": 108,
    "sourcetext": " func deleteAccount() async throws {\n        return try await performRequest(endpoint: Endpoint.delete)\n    "
  },
  {
    "name": "makeClient()",
    "kind": "Static Method",
    "offset": 496166,
    "length": 407,
    "sourcetext": " static func makeClient() -> SNBUserServiceClientProtocol {\n        guard let serverURL = URL(string: Backbase.configuration().backbase.serverURL) else {\n            fatalError(\"Invalid or no serverURL found in the SDK configuration.\")\n        }\n        let requestURL = serverURL.appendingPathComponent(\"/api/common-user-service/client-api/v2\")\n        return SNBUserServiceClient(baseURL: requestURL)\n    "
  },
  {
    "name": "refreshTransactions()",
    "kind": "Instance Method",
    "offset": 497116,
    "length": 39,
    "sourcetext": " func refreshTransactions() async throw"
  },
  {
    "name": "init(client:)",
    "kind": "Instance Method",
    "offset": 497340,
    "length": 150,
    "sourcetext": " init(client: SNBTransactionRefreshServiceClientProtocol = SNBTransactionRefreshServiceClientFactory.makeClient()) {\n        self.client = client\n    "
  },
  {
    "name": "refreshTransactions()",
    "kind": "Instance Method",
    "offset": 497502,
    "length": 94,
    "sourcetext": " func refreshTransactions() async throws {\n        try await client.refreshTransactions()\n    "
  },
  {
    "name": "makeClient()",
    "kind": "Static Method",
    "offset": 498172,
    "length": 442,
    "sourcetext": " static func makeClient() -> SNBTransactionRefreshServiceClientProtocol {\n        guard let serverURL = URL(string: Backbase.configuration().backbase.serverURL) else {\n            fatalError(\"Invalid or no serverURL found in the SDK configuration.\")\n        }\n        let requestURL = serverURL.appendingPathComponent(\"api/transaction-refresh-service/client-api/v1\")\n        return SNBTransactionRefreshServiceClient(baseURL: requestURL)\n    "
  },
  {
    "name": "refreshTransactions()",
    "kind": "Instance Method",
    "offset": 499181,
    "length": 39,
    "sourcetext": " func refreshTransactions() async throw"
  },
  {
    "name": "refreshTransactions()",
    "kind": "Instance Method",
    "offset": 499336,
    "length": 115,
    "sourcetext": " func refreshTransactions() async throws {\n        return try await performRequest(endpoint: Endpoint.refresh)\n    "
  },
  {
    "name": "getCount()",
    "kind": "Instance Method",
    "offset": 500422,
    "length": 39,
    "sourcetext": " func getCount() async throws -> String"
  },
  {
    "name": "init(client:)",
    "kind": "Instance Method",
    "offset": 500619,
    "length": 132,
    "sourcetext": " init(client: RequestMoneyServiceClientProtocol = RequestMoneyServiceClientFactory.makeClient()) {\n        self.client = client\n    "
  },
  {
    "name": "getCount()",
    "kind": "Instance Method",
    "offset": 500763,
    "length": 167,
    "sourcetext": " func getCount() async throws -> String? {\n        let response = try await client.fetchRequestCount()\n        return response.count == \"0\" ? nil : response.count\n    "
  },
  {
    "name": "fetchRequestCount()",
    "kind": "Instance Method",
    "offset": 501450,
    "length": 69,
    "sourcetext": " func fetchRequestCount() async throws -> RequestMoneyCountResponseDT"
  },
  {
    "name": "fetchRequestCount()",
    "kind": "Instance Method",
    "offset": 501617,
    "length": 162,
    "sourcetext": " func fetchRequestCount() async throws -> RequestMoneyCountResponseDTO {\n        return try await performRequest(endpoint: Endpoint.count(status: \"PENDING\"))\n    "
  },
  {
    "name": "makeClient()",
    "kind": "Static Method",
    "offset": 503024,
    "length": 427,
    "sourcetext": " static func makeClient() -> RequestMoneyServiceClientProtocol {\n        guard let serverURL = URL(string: Backbase.configuration().backbase.serverURL) else {\n            fatalError(\"Invalid or no serverURL found in the SDK configuration.\")\n        }\n        let requestURL = serverURL.appendingPathComponent(\"api/request-money-integration-service/client-api\")\n        return RequestMoneyServiceClient(baseURL: requestURL)\n    "
  },
  {
    "name": "pushTokens()",
    "kind": "Instance Method",
    "offset": 503972,
    "length": 30,
    "sourcetext": " func pushTokens() async throw"
  },
  {
    "name": "init(client:)",
    "kind": "Instance Method",
    "offset": 504618,
    "length": 140,
    "sourcetext": " init(client: DeviceManagementServiceClientProtocol = DeviceManagementServiceClientFactory.makeClient()) {\n        self.client = client\n    "
  },
  {
    "name": "pushTokens()",
    "kind": "Instance Method",
    "offset": 504771,
    "length": 76,
    "sourcetext": " func pushTokens() async throws {\n        try await client.pushTokens()\n    "
  },
  {
    "name": "pushTokens()",
    "kind": "Instance Method",
    "offset": 505538,
    "length": 263,
    "sourcetext": " func pushTokens() async throws {\n        guard let deviceId = JWTProvider.deviceId,\n              let firebaseToken else {\n            return\n        }\n        try await performRequest(endpoint: Endpoint.pushTokens(deviceId: deviceId, token: firebaseToken))\n    "
  },
  {
    "name": "pushTokens()",
    "kind": "Instance Method",
    "offset": 507170,
    "length": 30,
    "sourcetext": " func pushTokens() async throw"
  },
  {
    "name": "makeClient()",
    "kind": "Static Method",
    "offset": 507738,
    "length": 448,
    "sourcetext": " static func makeClient() -> DeviceManagementServiceClientProtocol {\n        guard let serverURL = URL(string: Backbase.configuration().backbase.serverURL) else {\n            fatalError(\"Invalid or no serverURL found in the SDK configuration.\")\n        }\n        let requestURL = serverURL.appendingPathComponent(\"api/device-management-service/client-api/v1/users/me/devices/\")\n        return DeviceManagementServiceClient(baseURL: requestURL)\n    "
  },
  {
    "name": "getEncrypted(of:)",
    "kind": "Instance Method",
    "offset": 509201,
    "length": 64,
    "sourcetext": " func getEncrypted(of nationalId: String) async throws -> String"
  },
  {
    "name": "init(client:)",
    "kind": "Instance Method",
    "offset": 509414,
    "length": 126,
    "sourcetext": " init(client: SNBCryptoServiceClientProtocol = SNBCryptoServiceClientFactory.makeClient()) {\n        self.client = client\n    "
  },
  {
    "name": "getEncrypted(of:)",
    "kind": "Instance Method",
    "offset": 509552,
    "length": 251,
    "sourcetext": " func getEncrypted(of value: String) async throws -> String? {\n        do {\n            let response = try await client.fetchPublicKey()\n            return value.encrypt(with: response.publicKey)\n        } catch {\n            return nil\n        }\n    "
  },
  {
    "name": "makeClient()",
    "kind": "Static Method",
    "offset": 510307,
    "length": 409,
    "sourcetext": " static func makeClient() -> SNBCryptoServiceClientProtocol {\n        guard let serverURL = URL(string: Backbase.configuration().backbase.serverURL) else {\n            fatalError(\"Invalid or no serverURL found in the SDK configuration.\")\n        }\n        let requestURL = serverURL.appendingPathComponent(\"api/snb-crypto-service/client-api/v1\")\n        return SNBCryptoServiceClient(baseURL: requestURL)\n    "
  },
  {
    "name": "fetchPublicKey()",
    "kind": "Instance Method",
    "offset": 511211,
    "length": 74,
    "sourcetext": " func fetchPublicKey() async throws -> SNBCryptoServicePublicKeyResponseDT"
  },
  {
    "name": "fetchPublicKey()",
    "kind": "Instance Method",
    "offset": 511377,
    "length": 152,
    "sourcetext": " func fetchPublicKey() async throws -> SNBCryptoServicePublicKeyResponseDTO {\n        return try await performRequest(endpoint: Endpoint.publicKey)\n    "
  },
  {
    "name": "getItemsInfo()",
    "kind": "Instance Method",
    "offset": 512828,
    "length": 64,
    "sourcetext": " func getItemsInfo() async throws -> SNBLifeStyleMoreResponseDTO"
  },
  {
    "name": "init(client:)",
    "kind": "Instance Method",
    "offset": 513062,
    "length": 140,
    "sourcetext": " init(client: SNBLifeStyleMoreServiceClientProtocol = SNBLifeStyleMoreServiceClientFactory.makeClient()) {\n        self.client = client\n    "
  },
  {
    "name": "getItemsInfo()",
    "kind": "Instance Method",
    "offset": 513214,
    "length": 153,
    "sourcetext": " func getItemsInfo() async throws -> SNBLifeStyleMoreResponseDTO? {\n        let response = try await client.fetchItemsInfo()\n        return response\n    "
  },
  {
    "name": "makeClient()",
    "kind": "Static Method",
    "offset": 513929,
    "length": 456,
    "sourcetext": " static func makeClient() -> SNBLifeStyleMoreServiceClientProtocol {\n        guard let baseUrl = Backbase.configuration().custom[\"lifestyleBaseUrl\"] as? String, let serverURL = URL(string: baseUrl) else {\n            fatalError(\"Invalid or no serverURL found in the SDK configuration.\")\n        }\n        let requestURL = serverURL.appendingPathComponent(\"/proxy/GamesMetadata/Module\")\n        return SNBLifeStyleMoreServiceClient(baseURL: requestURL)\n    "
  },
  {
    "name": "fetchItemsInfo()",
    "kind": "Instance Method",
    "offset": 514920,
    "length": 65,
    "sourcetext": " func fetchItemsInfo() async throws -> SNBLifeStyleMoreResponseDT"
  },
  {
    "name": "fetchItemsInfo()",
    "kind": "Instance Method",
    "offset": 515091,
    "length": 157,
    "sourcetext": " func fetchItemsInfo() async throws -> SNBLifeStyleMoreResponseDTO {\n        return try await performRequest(endpoint: Endpoint.info(status: \"PENDING\"))\n    "
  },
  {
    "name": "navigate(navigationController:editRequestFrom:)",
    "kind": "Instance Method",
    "offset": 516494,
    "length": 93,
    "sourcetext": " func navigate(navigationController: UINavigationController, editRequestFrom: LimitUpdateFrom"
  },
  {
    "name": "init(configuration:)",
    "kind": "Instance Method",
    "offset": 520354,
    "length": 104,
    "sourcetext": " init(configuration: GenericErrorScreen.Configuration) {\n        self.configuration = configuration\n    "
  },
  {
    "name": "makeUIViewController(context:)",
    "kind": "Instance Method",
    "offset": 520471,
    "length": 404,
    "sourcetext": " func makeUIViewController(context: Context) -> GenericErrorScreenViewController {\n        let viewModel = GenericErrorScreenViewModel(configuration: configuration)\n        let viewController = GenericErrorScreenViewController(viewModel: viewModel,\n                                         configuration: configuration)\n        viewModel.viewController = viewController\n        return viewController\n    "
  },
  {
    "name": "updateUIViewController(_:context:)",
    "kind": "Instance Method",
    "offset": 520888,
    "length": 102,
    "sourcetext": " func updateUIViewController(_ uiViewController: GenericErrorScreenViewController, context: Context) {"
  },
  {
    "name": "preferredFont(_:_:)",
    "kind": "Static Method",
    "offset": 521710,
    "length": 161,
    "sourcetext": " static func preferredFont(_ style: UIFont.TextStyle, _ weight: UIFont.Weight) -> Font {\n        DesignSystem.shared.fonts.preferredFont(style, weight).font\n    "
  }
]